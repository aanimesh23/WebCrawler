			Operator Overloading (continued)

In this lecture we examine how to overload more operators: many fewer than
in the first lecture, but some that perform more interesting (and subtle)
operations -some that get to the core of Python's operation, which we have the
ability to change!
------------------------------------------------------------------------------

Container operators: in Lists/Tuples

We saw that when we call the standard len function with an object argument, it
is translated into a call of the __len__ method on that object: for example,
calling len(x) returns the value x.__len__(); Python does the same with the
reversed function and and the __reversed__ method. Since __reversed__ is really
an iterator, we will discuss it in depth next week (see how it, and similar
iterators are coded).

The following methods all relate to indexing: using the [] delimiters, which
Python interprets as symbols describing the indexing operator. What appears
inside the brackets is typically either a simple integer (for lists and tuples)
or a slice (ditto: more on slices below). Also [] is an operator that works on
dictionaries (dict and defaultdict), where the value inside [] is the dict's
key, which can be any arbitrary value. Let's look at the laundry list of
methods first, and then use each in a new class that we define. Assume for the
examples below that we have defined l to be a list.

Note that the index parameter can be an int or a slice for lists/tuples (we will
focus on lists here). We discuss three different forms of using an index, each
calling a different double underscore method; a fourth related operator, "in",
is translated into a call on the  __contains__ method and is discussed below
too.

__getitem__(self,index)        : index: l[3] or l[1:-1]
__setitem__(self,index,value)  : store list: l[3]='a' or l[2:4]=('a','b','c')
__delitem__(self,index)        : delete: del l[3] or del l[1:-1]
__contains__(self,item)        : called by the in operator: 'a' in l

To illustrate these methods, let's write a class that allows us to specify
a list that is indexed staring at 1 (not 0). Really we should think in terms
of defining a class for a new type of data (lists, tuples, sets, frozensets,
dicts, and defaultdicts are all types of data; we can use inheritance, discussed
later in the quarter, to define variants of these data types more easily), but
for now let's look at adapting/using standard lists in this new way, to simplify
what we are learning (we could do the same with strings, writing Str1). This
example also uses delegation, where an operation on a List1 is translated into
a "similar" operation on the list it stores/delegates to. We start with

class List1:
    def __init__(self,iterable):
        self._plist = list(iterable)
        
    def __str__(self):
        return str(self._plist)

So, we can write

x = List1(['a', 'b', 'c', 'd', 'e'])
print(x)

which prints as

  ['a', 'b', 'c', 'd', 'e']

So x looks just like a list when we create one and print one (although we must
use the List1 constructor, not just [...] for these special lists). Its argument
is anything Python can iterate over to create the values in the list, and we
copy that information into a list. We now want to implement list-like behavior,
but with indexes that start at 1 instead of 0. First we look at the __getitem__
method, called by l[...]. We can use either integers or slices inside the
brackets, for now let's look at just integers.

Note that in Python lists, integer indexes are either non-negative (0, 1, ...),
which specify an index from the beginning (e.g., 0 is the first, 1 is the
second...), or negative, which specify an index from the end (e.g., -1 is the
last index, -2 second from last). Note the asymmetry we are now fixing: in List1
we want 1 to be first and -1 be last, 2 to be second and -2 to be 2nd from last,
unlike Python lists, where 0 is the first index and -1 the last.

So we will start with the helper function (static method) _fix_index: the
leading underscore means this method should be used only other methods in the
List1 class. This function demotes positive indexes by 1, but leaves 0 and
negative indexes as is. So _fix_index(1) returns 0, which when used to index
self._plist, the delegated list, denotes the index of the first value. Likewise,
_fix_index(-1) returns -1, which still denotes the index of the last value.

    @staticmethod
    def _fix_index(i):
        return (i-1 if i >= 1 else i)

Recall, because this is a static method, it has no self parameter. We will call
this method (see below) like List1._fix_index(...). Static means it does not
operate on instances of a class: so it uses no self parameter to refer to an
instance of List1. Alternatively, we could have defined _fix_index as a global
function in this module, and called it just as _fix_index(...) in the class
methods, but it is better to define this static method in the class itself.
Again, note that we use a prefix underscore to indicate no function/method
outside the class SHOULD call this function: it is just a helper for the
methods in the class. But there is nothing in Python that disallows us from
calling List1._fix_index anywhere.

With _fix_index defined, we can write __getitem__ as follows. Notice that it
ensures index is an int, otherwise it raises an exception. If index is an int,
it delegates to self._plist to access its information, but when accessing
self._plist, we decrease the index by 1 for positive indexes, but leave zero
and negative indexes alone. For illumination/debugging purposes we have put a
print in __getitem__ which we will comment/uncomment as needed. For the examples
below we will leave it in, so that we can see when __getitem__ is called by
Python, since we don't explicitly call it.

    def __getitem__(self,index):
        print('List1.__getitem__('+str(index)+')') # for illumination/debugging
        if type(index) is int:
            return self._plist[List1._fix_index(index)]
        else:
            raise TypeError('List1.__getitem__ index('+str(index)+') must be int')

Running the following script illustrates how __getitem__ is called.

x = List1(['a','b','c','d','e'])
print(x)
print(x[1], x[2], x[-2], x[-1])

Python produces the following output, printing the entire list, the first,
second, last, and second to last values. Notice the calls that Python
automatically makes to __getitem__ when we use the [] operator.

  ['a', 'b', 'c', 'd', 'e']
  List1.__getitem__(1)
  List1.__getitem__(2)
  List1.__getitem__(-2)
  List1.__getitem__(-1)
  a b d e

Two things about this method. First, we should probably raise an exception if
the index is 0 because that value should not be a legal index in a List1 list.
But for purposes of illustration later, when we discuss the "in" method, we will
not do this (so index 0 will be the same as index 1). Second, we need to talk
about slices and how List1 objects will can process them. 

----------
Interlude: slices

To finish writing __getitem__ we must take a short detour to talk about slices.
Recall that for Python lists we can write indexes like x[1:4], x[2:-2], x[:-1]
and even x[::2]. Each of these slices translates into an actual slice object
(yes there is a slice class defined in the builtins module which is
automatically imported into every python module) that is passed to __getitem__.
Each slice object has three atrributes that we can access: start, stop and step.

x[1:4]  translates to x[slice(1,4,None)]
x[2:-2] translates to x[slice(2,-2,None)]
x[:-1]  translates to x[slice(None,-1,None)]
x[::2]  translates to x[slice(None,None,2)]

The __getitem__ methods for lists know how to process slices. We can delegate
these slices to be used on self._plist, but we need to fix the start and stop
indexes (as done above for pure int indexes, with the same function), but leave
the step as is. Also, since slices can specify None, we need to update
_fix_index to leave None unchanged.

So, we update the _fix_index and __getitem__ methods as shown below. Now for
slices, we construct a fixed slice from the one passed as an argument (fixed for
start and stop in 1-origin lists) and use this slice when delegating to
self._plist.

    @staticmethod
    def _fix_index(i):
        if i == None:
            return None
        else:
            return (i-1 if i >= 1 else i)
            # for + indexes, 1 smaller: 1 -> 0
            # for - indexes, the same: -1 (still last), -2 (still 2nd to last)
        
    def __getitem__(self,index):
        print('List1.__getitem__('+str(index)+')') # for illumination/debugging
        if type(index) is int:
            return self._plist[List1._fix_index(index)]
        elif type(index) is slice:
            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)
            return self._plist[s]
        else:
            raise TypeError('List1.__getitem__ index('+str(index)+') must be int/slice')

Running the following script illustrates how __getitem__ works with slices; we
left the print statement in __getitem__ and the __str__ for slice objects prints
as slice(start, stop, step)

x = List1(['a','b','c','d','e'])
print(x)
print(x[1:4], x[2:-2], x[:-1], x[::2])

Python produces the following output, printing the entire list, and then the
specified slices of that list (again, where the index of the first item is 1).
Notice the calls that Python automatically makes to __getitem__ when we use the
[] operator with slices. Remember that slices include indexes up to but not
including the stop index (we could fix this too, if we didn't like, by always
incrementing the stop index by 1, therefore using one more index; this would be
a problem, though for incrementing -1 to 0 which would be wrong and we'd need
a special way to fix that: incrementing -1 to None: here, x[1:] would be slice
with all valus in a List1).

  ['a', 'b', 'c', 'd', 'e']
  List1.__getitem__(slice(1, 4, None))
  List1.__getitem__(slice(2, -2, None))
  List1.__getitem__(slice(None, -1, None))
  List1.__getitem__(slice(None, None, 2))
  ['a', 'b', 'c'] ['b', 'c'] ['a', 'b', 'c', 'd'] ['a', 'c', 'e']
----------

Now that we know how to handle indexes that are integers or slices (by fixing
them and delgating their use to self._plist),  we can easily write the remaining
methods. For example the __setitem__(self,index,value) method is supposed to
assign value to object at the specified index(es). Its structure is identical
to __getitem__, processing int indexes, slice indexes, or raising TypeError.
Here, though, we are assigning to self._plist, not returning a value. Because
there are no return statements in this method, Python will automatically return
None when it finishes executing; we could also specify this explicitly as
return None: both have the same effect in Python.

    def __setitem__(self,index,value):
        print('List1.__setitem__('+str(index)+')') # for illumination/debugging
        if type(index) is int:
            self._plist[List1._fix_index(index)] = value
        elif type(index) is slice:
            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)
            self._plist[s] = value
        else:    
            raise TypeError('List1.__setitem__ index('+str(index)+') must be int/slice')

Running the following script illustrates how __setitem__ works with int and
slice indexes; we again left the print statement in __setitem__.

x = List1(['a','b','c','d','e'])
print(x)
x[1] = 1
x[4:5] = (4,5)
print(x)

Python produces the following output, printing the entire list, and then the
updated list. Notice the calls that Python automatically makes to __setitem__
when we use the [] operator with slices.

  ['a', 'b', 'c', 'd', 'e']
  List1.__setitem__(1,1)
  List1.__setitem__(slice(4, 5, None),(4, 5))
  [1, 'b', 'c', 4, 5, 'e']

Next, the __delitem__(self,index) method is supposed to delete/remove values
from the specified index(es). Its structure is identical to __getitem__ and
__set__item, processing int indexes, slice indexes, or raising TypeError. As
with __setitem__ we automatically return None.

    def __delitem__(self,index):
        print('List1.__delitem__('+str(index)+')') # for illumination/debugging
        if type(index) is int:
            del self._plist[List1._fix_index(index)]
        elif type(index) is slice:
            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)
            del self._plist[s]
        else:            
            raise TypeError('List1.__delitem__ index('+str(index)+') must be int/slice')

Running the following script illustrates how __delitem__ works with int and
slice indexes; we again left the print statement in __delitem__.

x = List1(['a','b','c','d','e'])
print(x)
del x[1]	# now ['b','c','d','e'] index 1 deleted
print(x)    
del x[2:4]	# now ['b','e']		indexes 2-3 (not 4) deleted
print(x)

Python produces the following output, printing the entire list, and then the
updated list. Notice the calls that Python automatically makes to __delitem__
when we use the [] operator with slices.

  ['a', 'b', 'c', 'd', 'e']
  List1.__delitem__(1)
  ['b', 'c', 'd', 'e']
  List1.__delitem__(slice(2, 4, None))
  ['b', 'e']

----------

Implementing in via __getitem__

Before defining the __contains__ method, we will learn that if there is no
defined __contains__ method, Python will check "x in l" by first checking if
x == l[0], then x == l[1], then x == l[2], ... until it finds x, or indexing
throws an exception (Python takes this approach instead of compuing len(l) as
an upper bound to index, because the __len__ method might not be defined for
this class).

So if we ran the following script (without defining the __contains__ method)

x = List1(['a','b','c','d','e'])
print('d' in x)
print('z' in x)

Python produces the following output, printing

  List1.__getitem__(0)
  List1.__getitem__(1)
  List1.__getitem__(2)
  List1.__getitem__(3)
  List1.__getitem__(4)
  True
  List1.__getitem__(0)
  List1.__getitem__(1)
  List1.__getitem__(2)
  List1.__getitem__(3)
  List1.__getitem__(4)
  List1.__getitem__(5)
  List1.__getitem__(6)
  False

Let's look at this carefully. For the first print Python executes 'd' in x; it
first calls __getitem__(0) but in the List1 objects there is nothing at index
0; actually if you look at the code a call of __getitem__(0) is translated to
[0] -storing 'a'- which looks at the first value and doesn't find 'd'; then
Python calls getitem(1), which is also translated to [0] -storing 'a'- which
again looks at the first value and doesn't find 'd'; then Python calls
__getitem(2), which is translated to [1] -storing 'b'- which looks at the
 second value and doesn't find 'd'; ...; then Python calls __getitem(4), which
is translated to [3] -storing 'd'- which looks at the fourth value and does
find 'd', so the contains returns True, which is printed.

For the second print Python executes 'z' in x; it calls __getitem__ multiple
times; __getitem(5) is translated to [4] -storing 'e'- which looks at the
fifth/last value and doesn't find 'z'; then Python calls __getitem(6), which
raises an exception indicating that there are no more values to examine, so
using "in" (translated to multiple indexes) returns False, which is printed.

Although using "in" accesses index 0 twice, it does always produce the correct
answer. If we wrote _fix_index to raise an exception for index 0 (which
isn't really a legal index in List1) __contains__ would not automatically work
correctly. But now we will explicitly write a __contains__ method that does not
automatically call the __getitem__ method.
----------

Now, we can define our own contains to just use the in operator for lists.

    def __contains__(self,item):
        for v in self._plist:
            if v == item:
                return true
        return false

but this is just checking whether item is in _plist, so we can simplify it to
delegate to the in operator for standard lists.

    def __contains__(self,item):
        return item in self._plist

So if we ran the following script (defining the __contains__ method above)

x = List1(['a','b','c','d','e'])
print('d' in x)
print('z' in x)

Python now produces the following output, printing just the following, showing
that there are no more calls automatically made to __getitem__.

  True
  False

If we want to iterate over a class (for example, in a for loop) we should
implement the __iter__ and __next__ methods. We will discuss these in detail
in next week's lectures. But like in/__contains__ if those methods aren't
defined, Python calls the __getitem__ method for indexing. For example, if
Python executes

x = List1(['a','b','c','d','e'])
for i in x:
    print(i)

for the List1 class as defined above, it prints the following

  __getitem__(0)
  a
  __getitem__(1)
  a
  __getitem__(2)
  b
  __getitem__(3)
  c
  __getitem__(4)
  d
  __getitem__(5)
  e
  __getitem__(6)

Notice as with the in operator above, it starts calling __getitem__ at index 0,
so that value gets produced/printed twice by the iterator. For the in operator
this wasn't a problem, but here it produces/prints the first value twice, which
we will fix when we define the real __iter__ method. Also as with the in
operator it calls __getitem__ with successively bigger indexes, returning those
values until at __getitem__(6) an exception is raised, because there is no
index 6 in this List1 object: just indexes 1 through 5 and stops by handling
(and not showing) the exception.

So, we really should write _fix_index to raise an exception when supplied the
argument 0, which is not a legal index for objects constructed from List1. Then
we must define explicit __contains__ and iteration methods (__iter__ and
__next__, discussed next week) because using the automatic ones would generate
index 0, for which _fix_index would raise an exception.

It is often the case that we define new classes using combinations of the
builtin classes (like list, tuple, set, dict) so often we delegate operations
for our new class to operations on the classes it is built from.

-------

Container operators: in Dictionaries

We are now coming to the end of this example. Although this example used
integer indexes for list, if we wanted to produce a special kind of dictionary
data type we can use any type of index as a key in the __getitem__, __setitem__,
and __delitem__  methods. Of course we cannot use slices with dictionaries, as
we did above with List1.

For classes that will be used like dicts, there is another special method

__missing__(self,key)

which should be called whenever a dict fails to find a key it is looking up. We
can define the __missing__ method to tell Python what to do in these cases. In
a normal dict class, Python throws an exception; in the defaultdict class, its
__missing__ method associates a special object in the defaultdict (specificied
by an argument in the construction of the defaultdict) with that key, and then
returns that associated object for possible further processing. When we study
inheritance later in the quarter, we will see how to completely define
defaultdict easily, including defining the __missing__ method as described
above.

One last point here. most of these methods return None, because they are
meant to be the result of commands that return no values. But, it might be
useful for them to return a value. For example, in the Java library for maps
(which are like Python dicts), mapping keys to values, calling __setitem__
returns the OLD value associated with the key being set; likewise, __delitem__
returns the value associated with the key being deleted. Using these returned
values sometimes makes for more elegant code. Although Python doesn't do this,
we can write classes that behave any way we want them to.

Finally, although we changed the indexes to start at 1, we did not change the
upper-bound meaning of slices. recall that a standard slice 2:5 correspondes to
indexes 2, 3, and 4 (not including 5). I often find it difficult to remember
or use the fact that the stop index is not included in the slice, so it might
be interesting to change the slices so that the stop index is included (as I
did for irange in my goody module) which can be done simply when the slices are
created/"fixed" and used in __getitem__, __setitem__, and __delitem__ methods.

The main point here (and for the special methods below) is that if we want a
data type to behave a certain way in Python, we can write classes in Python for
that data type and make it exhibit exactly the behavior we want by writing the
class methods.

------------------------------------------------------------------------------

Function Call

We know how Python calls methods on instances of classes: by the Fundamental
Equation of OOP, o.m(...) is translated into type(o).m(o,...). But we can also
define how to use an instance as if it were a function itself, allowing us to
call it as o(...). The way we do this is by defining a method named __call__
in the class. The call o(...) is translated into o.__call__(...), and by FEOOP
type(o).__call__(o,...)

----
In fact, when we use the name of a class like a function call we are using this
mechanism. For example, when calling set([1,2,3]) we are calling a function on
the set class object, which is an instance of a special class named type, and
it is type which defines a __call__ method to call __init__ on set. Below we
will show how to overload __call__ for objects that have already been
constructed from a class.
---

1) Here is a tiny example of overloading __call__ followed by a more interesting
one. When we call the object, it will increment the self.x value: x is stored in
the namespace/__dict__ of the object.

class C:
    def __init__(self):
        self.x = 0
    
    def __call__(self,inc=1):
        self.x += inc

So if we construct objects from class C, we can call them specifying one
argument (to match the inc parameter). We can write

o = C()
print(o.x)
o(2)
print(o.x)
o()
print(o.x)

Note that we can call the object o refers to just by writing parentheses after
o. Python processes o(2) by calling to o.__call__(2) and then calling
type(o).__call__(o,2) which is C.__call__(o,2). It prints

  0
  2
  3

2) The following class is a bit ahead of where we are now, but it shows a more
realistic use of overloading __call__, and we will discuss this class, and
other classes like it, here and in detail later in the quarter. Track_Calls is a
(decorator) class that we can use to remember how many times functions are
called. We illustrate its use with a recursive fibonnaci (fib) function.

When Python constructs an object from the Track_Calls class, it remembers the
function it is given (f) in its _f instance variable, and initializes its calls
instance variable to 0.

An object of class Track_Calls can be called directly: its __call__ method
increments the calls counter and calls and returns the value computed by the
remembered function: delegating to it to compute the actual values we want.
Thus, we can replace a function call with a function call to an object in which
the original function is remembered; and objects can do more than functions:
for example, they can remember information/state, like how many times they are
called.

class Track_Calls:
    def __init__(self,f):
        self._f = f
        self.calls = 0
    
    def __call__(self,x): # or ,*args,**kargs): #to bundle arbitrary arguments
        self.calls += 1
        return  self._f(x)# or ,*args,**kargs)  #to unbundle arbitrary arguments

def fib(n):
    assert n>=0, 'fib cannot have negative n('+str(n)+')'
    if    n == 0: return 1
    elif  n == 1: return 1
    else:         return fib(n-1) + fib(n-2)

fib = Track_Calls(fib)

The script above defines the Track_Calls class, the fib function, and then
rebinds the name fib to an object constructed from the Track_Calls class, when
passed a reference to the fib function object as an argument.

When we call fib(...), Python finds the Trace_Calls object that fib refers to
and calls its __calls__ method. So, it calls fib.__calls__(...) which FEOOP
translates to Track_Calls.__calls__(fib,...) which increments the calls 
instance variables and then calls the original function object bound to fib
(now bound to self._f, which is recursive) and returns that value. Remember
that the fib name is now bound to a Track_Calls object, so any recursive calls
to fib are also handled by the Track_Calls._call__ method (which increments the
calls instance variable). Ultimately the recursive function call returns an
answer and the calls instance variable accumulates how many calls of fib,
called through Track_Calls.__call__, were made.

Here is code that creates a table of the returned values from fib and the
number of calls each required. I directly reset fib.calls to 0, but I could
have created a method in Track_Calls to reset this instance variable, or just
remembered the number of calls before and after a new call and subtracted.

for i in irange(0,31):
    print('fib(',i,') =',fib(i),'and was called',fib.calls,'times')
    fib.calls = 0 # reset instance variable to 0 for next iteration

In this code I am using an instance variabls directly (note calls is not
preceded by an underscore). To avoid using this instance variable directly, I
could have defined this instance variable as _calls and then defined the report
method below to return such a value (and another method to reset it):

    def report_calls(self):
        return self._calls.

    def reset_calls(self):
        self._calls = 0

In this case I would write the code above as

for i in irange(0,31):
    print('fib(',i,') =',fib(i),'and was called',fib.report_calls(),'times')
    fib.reset_calls()

When we discuss decorators later in the course, we will see all sorts of what
I would call fascinating uses of classes that remember a function and define
function calls for the object that delegate to the function, but do something
else too. Thus, they "decorate" the function.

------------------------------------------------------------------------------

Context managers (just skim)

We will review (I think you saw them in ICS-32, and hope you remember something
about using them) context managers, which have the syntax

  with A_Class(...) [as name]:        # as name  is optional
      block  # (possibly using name in its statements)

We write our own context managers by defining only two special methods in the
class. By defining these methods, we can use objects of such a class in the
syntax Python provides for context managers. Thus, defining these methods is
similar to overloading operators, which is why we discuss them here.

Generally, the purpose of a context manager is to simplify the use of exception
handling in a block. Intead of having to write try/except whenever a class is
used, we can put the try/except code in the class itself, defining the
__enter__ and  __exit__ methods, thus easily reusing this exception code
whenever an object from this class is created and used in a context manager.

We can use open with a context manager to ensure a file is closed (see the
__exit__ method in the example below) when the block is done executing (whether
it finished normally or by raising an exception).

Here is a fairly large but useful example of a Logging class. It allows a
programmer to execute code and log messages into a file, including whether or
not the block terminated/exited normally or by having one of its statements
raise an exception.

The __enter__ method takes as an argument an instance of A_Class; if the
"as name" option is to be used, then this method must return self to bind to
name.

The __exit__ method takes four arguments:

  (1) the standard instance of self,
  (2) an exception class object
  (3) the raised exception object: type(3) is 2
  (4) a traceback (which we can print, and typically is formatted to print
      nicely; in this example we print it in the log file.

These parameters receive special values automatically if an actual exception is
raised in the block, if no exception is raised then 2-4 receive the value None.
The __exit__ method looks at these parameters and does what it wants: if it
returns True the exception is considered handled and does not propagate; if it
returns False Python propagates the exception (re-raises it, signaling an error
to be handled by other/outer code). If it returns None there was no exception.

Note in __exit__ below we just look to see whether or not there was an
exception, not differentiating what exception was raised. But we could have
written code like the following, to handle different exceptions in different
ways.

if exc_type in (AssertiontError, KeyError, ... ):
    handle these errors the same way
elif exc_type in (...)
    etc.  

import prompt,traceback
class Logging:
    def __init__(self, file_name, should_i_propagate_exception):
        self._file = open(file_name,'w')
        self._should_i_propagate_exception = should_i_propagate_exception
        self._count = 0
        
    def log(self,message):
        self._file.write(message+'\n') # or print(message,file=self._file)
        self._count += 1
        
    def __enter__(self):
        self.log('Entered Logging context')
        return self # so the log method can be called in block
    
    def __exit__(self, exc_type, exc_value, exc_traceback):
        if exc_type == None:
            self.log('Exited Logging context with no exception')
        else:
            self.log('Exited with exception that is ' +
              ('propagated' if self._should_i_propagate_exception else 'stopped here'))
            traceback.print_tb(exc_traceback,file=self._file)
        self.log('Logged ' + str(self._count+1)+' messages')
        self._file.close()
        return (None if exc_type == None else not self._should_i_propagate_exception)

 
# code using this context manager
            
with Logging('log1.txt',should_i_propagate_exception=True) as now:
    print('do some operations')
    now.log('successfully did some operations without an exception')
    print('do some more operations')
    now.log('successfully did some more operations without an exception')
    if prompt.for_bool('pretend final operation raised exception?'):
        raise AssertionError('raised by user')
    now.log('successfully did final operations without an exception')
    
print('Continuing after block (exception didn't propagate)')

Execute this code 3 ways, entering False to the bool prompt in the block
(_should_i_propagate_exception doesn't matter), answering True to the bool
prompt in the block (when should_i_propagate_exception=True); answering False
to the bool prompt in the block (when should_i_propagate_exception=False).

Note that when passing bool arguments, it is great to use the named-argument
form (even if you could write it positionally), so the reader of the program
(mostly you!) has an idea what the True/False means. Of course, choose a good
parameter name in this case too.

------------------------------------------------------------------------------

Attribute:

In this last section we will discuss some of the methods that are at the heart
of how Python executes our code. All require careful use or they will cause
big problems (often infinite recursion) that stop the execution of all Python
code. All concern getting and setting the values of attributes in the namespaces
of objects (what classes are all about). Here is the complete laundry list.

__getattr__(self,name)	     	     : when cannot find name attribute
__setattr__(self,name,value)	     : set name attribute to value
__delattr__(self,name)		     : delete name attribute
__getattribute__(self,name)	     : access name attribute (very tough to use)

Whenever we refer to an attribute in some object's namespace (recall __dict__
stores the namespaces for objects, containing the bindings of their instance
variables) Python calls one of a few double-underscore method: if we do NOT
define these methods for a class, Python uses inheritance (a topic that we will
cover later) to determine what to do.

We will look at __getattr__ first (it is the safest) which is called when a
attribute CANNOT be found in a namespace (much like __missing__ for
dictionaries, discussed briefly above). Here is a small class that defines this
method to return a string that includes the name of the nonexistant attribute,
instead of raising the NameError exception. We could also easily return None
for such non-existant attributes when they are "gotten".

class C:
    def __getattr__(self,name): # call when name (a str) isn't in the namespace
        print('Attribute for ' + name + ' not found')
        return name+'?'

o = C()
print(o.a_name)
print(o.a_name)
o.a_name = 0
print(o.a_name)

Running this code prints the results

Attribute for a_name not found
a_name?
Attribute for a_name not found
a_name?
0

When the a_name attribute of o is referred to in the first print, it doesn't
exist, so Python calls __getattr__ for its result, which returns the
attribute's name with a ? appended. This doesn't change whether that name is
bound to anything, so the same thing happens if it is called again. When the
a_name attribute of o is referred to in the second print, it has already been
bound to a value (see o.a_name = 0) so Python doesn't call the __getattr__
method. IMPORTANT __getattr__ is called only for attributes that don't exist;
it is not called for all attributes (that is what __getattribute__ is for, but
it is very tough to use correctly because it is as the core of everything in
Python: getting some attribute of an object).

Let's first look at the standard meaning of __setattr__ for a class; if we do
not define our own __setattr__, the class uses one (through inheritance, a topic
we cover later in ICS-33) that is equivalent to defining the following one.

    def __setattr__(self,name,value):
        self.__dict__[name] = value

This code translates o.a = v into a method call on __setattr__: it executes
o.a = v by executing o.__setattr__('a', v), which executes o.__dict__['a'] = v.
Notice that the attribute name is converted into a string when calling
__setattr__, which is used as a key in __dict__.

One thing we should NEVER DO is write

    def __setattr__(self,name,value):    # NEVER DO THIS
        pass                             # NEVER DO THIS

This code executes o.a = v by doing nothing! It does not bind this attribute to
anything. By not definining our own __setattr__, the standard one will execute.

Now let's looks at a sophisticated use of the __setattr__ method. The class
below defines the __setattr_ method so that it uses a dict to remember all the
values ever bound to an attribute (stored in self._history).

from collections import defaultdict # for elegance; with __setattr__ we need it

class C:
    def __init__(self):
        self._history = defaultdict(list)   # empty list when initially accessed
        self.s = 0

    def bump(self):     # resets attribute s: bind s to a value one bigger
        self.s += 1	# equivalent to self.s = self.s + 1
        
    def __setattr__(self,name,value):
        # print('C.__setattr__',name,value) # helps for debugging
        if '_history' in self.__dict__:     # False (skip append) 1st time only:
                                            #   self._history = ... in __init__
           self._history[name].append(value)# Do this every time but 1st
        self.__dict__[name] = value         # always do this too, to update name
            
    def report(self):
        print('History Report:') 
        for k,v in sorted(self._history.items()):
            print('  ',k,' had the values:', v)

First, whenever __setattr__ is called, it checks to see if '_history' is already
an attribute name; if not yet, it means that self._history is being set for the
first time, in __init__, by executing the self._history = defaultdict(list),
so __setattr__ shouldn't update the history by appending a new value, because
there is no history dictionary yet to append to!

Next, __setattr__ sets the attribute by using __dict__ directly, using the
string name as the key, and thus bypasses another (recursive) call to
__setattr__. So, if there is no '_history' attribute, this statement creates
one; if there already is a '_history' attribute, this statement updates
whatever attribute is being set.

If we ran the following script

x = C()
x.s = 3    # resetts attribute initialized to 0 in __init__
x.bump()
x.bump()
x.y = 11   # create a new attribute not created in __init__
x.s = 8
x.y += 1
x.report()

Calling x.report would show a history of all the values the two instance
variables stored.  Recall that the name parameter in __setattr__ is passed a
string argumen: x.s = passes 's' as the name of the attribute to set, and
8 as its value.

History Report:
   s  had the values: [0, 3, 4, 5, 8]
   y  had the values: [11, 12]

Note that x._history['s'][-1] is the current value bound to x.s (the last one
in the list), and x._history['s'][-2] is the previous one to that. We might
call this an Elephant class: it never forgets the binding for a name, even
after the name is rebound to another value.

The method __delattr__ is not so useful (and __getattribute__ is so dangerous
to use that we will byplass it now). But here is a short example of a class that
keeps a list of names that have been deleted from it and what their last
bindings were (like remembering the old bindings of instance varaibles). Recall
that name is a string: del o.y calls type(o).__delattr__ and passes 'y' as the
name of the attribute to delete.

class C:
    def __init__(self):
        self._deleted = {}

    def __delattr__(self,name):
        self._deleted[name] = self.__dict__[name]
        del self.__dict__[name]

    def report(self):
        print('Deleted attributes and their final values:',self._deleted)

o = C()
o.x = 1
o.y = 2
o.z = 3
del o.x
del o.y
o.report()

Calling o.report prints: 

  Deleted attributes and their final values when deleted : {'y': 2, 'x': 1}


------------------------------------------------------------------------------

The double-underscore methods __iter__ and __next__ are so useful (everything
about iteration is useful) we will spend next week examining this protocol
and various ways to implement it.

------------------------------------------------------------------------------

FYI, here is the entire List1 class with all the methods described above.

class List1:
    def __init__(self,_plist):
        self._plist = list(_plist)
        
    def __str__(self):
        return str(self._plist)

    def _fix_index(i):
        if i == None:
            return None
        else:
            # for positive indexes, 1 smaller: 1 -> 0
            # for - indexes, the same: -1 (still last), -2 (still 2nd to last
            return (i-1 if i >= 1 else i)
        
    def __getitem__(self,index):
        print('List1.__getitem__('+str(index)+')') # for illumination/debugging
        if type(index) is int:
            return self._plist[List1._fix_index(index)]
        elif type(index) is slice:
            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)
            return self._plist[s]
        else:
            raise TypeError('List1.__getitem__ index('+str(index)+') must be int/slice')
  
    def __setitem__(self,index,value):
        print('List1.__setitem__('+str(index)+','+str(value)+')') # for illumination/debugging
        if type(index) is int:
            self._plist[List1._fix_index(index)] = value
        elif type(index) is slice:
            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)
            self._plist[s] = value
        else:    
            raise TypeError('List1.__setitem__ index('+str(index)+') must be int/slice')
        
    def __delitem__(self,index):
        print('List1.__delitem__('+str(index)+')') # for illumination/debugging
        if type(index) is int:
            del self._plist[List1._fix_index(index)]
        elif type(index) is slice:
            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)
            del self._plist[s]
        else:            
            raise TypeError('List1.__delitem__ index('+str(index)+') must be int/slice')

    def __len__(self):
        return len(self.thislist)
    
    def __contains__(self,item):
        return item in self._plist


Note that we could define the following __getattr__ method for List1.

    def __getattr__(self,attr):        # if attr not here, try self._plist
        return getattr(self._plist,attr)

This says, if we try to access any attribute that is not defined for List1,
get that attribute from self._plist. Generally this is called delegation:
where an "outer" object that does not have some attribute delegates the
attribute reference to an inner object. Doing so allows us the inner object 
implicitly to do all processing not explicitly done by the outer object.

So for example, if we wrote

x = List1([1,2,3])
x.append(4)
print(x[4])

it would print 4. There is no append attribute defined in List1, so instead we
get that attribute from self._plist, in which case the attribute is a method
that we can call (we call it here with the argument 4).

Generally this is called delegation: where an "outer" object that does not have
some attribute delegates the attribute reference to an inner object. Decorators
often use exactly this form of delegation, so the decorator object can process
its attributes and all the attributes of the decorated object.

In fact, with this __getattr__ method we can omit defininig __len__ and
__contains__ letting those attributes be accessed in the self._plist. Such
delegation would work for all method that are index independent. We would still
have to define, in List1, all the methods using list indexes because the whole
purpose of this class is to shift the original from index 0 to index 1.

------------------------------------------------------------------------------

FYI, here is a list of operators and the double-underscore methods that we can
define to overload them. We've covered most but not all.

Relational operators: < > <= >= eq ne
__lt__  __gt__  __le__  __ge__  __eq__  __ne__

Unary operators/functions: + - abs ~ round floor ceil trunc
__pos__  __neg__  __abs__  __invert__  __round__  __floor__  __ceil__

Arithmetic: + - * / // % divmod ** << >> & | ^
__add__  __sub__  __mul__  __truediv__  __floordiv__  __mod__  __divmod__
__pow__ __lshift__  __rshift__  __and__  __or__  __xor__

Reflected (right) arithmetic 
__radd__  __rsub__  __rmul__  __rtruediv__  __rfloordiv__  __rmod__  __rdivmod__
__rpow__  __rlshift__  __rrshift__  __rand__  __ror__  __rxor__

Incrementing Arithmetic: += -= *= /= //= %= **= <<= >>= &= |= ^=
__iadd__  __isub__  __imul__  __idiv__  __ifloordiv__  __imod__  __idivmod__
__ipow__ __lishift__  __irshift__  __iand__  __ior__  __ixor__


Type conversion: int float complex oct hex index trunc coerce
__int__  __float__  __complex__  __oct__  __hex__  __index__  __trunc__  
__coerce__

Class representation:
__str__  __repr__  __unicode__  __format__  __hash__  __nonozero__  __dir__


Attribute:
__getattr__  __setattr__  delattr__  __getattribute__


Containers:
__len__  __getitem__  __setitem__  __delitem__ __iter__  __reversed__
__contains__  __missing__

Misc:

__call__  __copy__  __deepcopy__
getattr/setattr: special classes, wrapped, inheritance soon, and decorators

Context managers

__enter__  __exit__

Descriptors:
__get__  __set__  __delete__



Do you want to build your own context manager: overload the __enter__ and
__exit__ methods


__iter__ and __next_ for generators


------------------------------------------------------------------------------

Problems:

1) Write a class named Indexed_Set that defines an __init__ method taking
anything that can be iterated over as an argument (e.g., list, tuple, set) and
stores all these values in a set. Although sets don't have indexes, define a
__getitem__ method such that for int index i it returns the ith value produced
when iterating over the set (raising IndexError for too small/too large
indexes); for a slice index, __getitem__ produces a set containing all the the
indexed values; for any other index (non-int, non-slice) raise the TypeError
exception. Of course Python can iterate over an Indexed_Set using __getitem__.
Hint: write a _getitem helper method that implements the requirements for int
indexes, which is called from __getitem__ when necessary (once for an int index,
multiple times for a slice index; build the resulting set with a comprehension).


2) Write a class name Count_Argument_Use that defines an __init__ method taking
a function of one parameter as an argument. Define a __call__ method that keeps
a dictionary of what argument the function was called with and how often it
was called with each argument. Define a report method that prints each argument
in this dictionary, followed by the number times it was used, in decreasing
order of the times it was used. Test this code on the fibonacci function defined
in these notes. For fib(10), calling report() should print:

Argument | Times Called
---------+-------------
       1 |           55
       0 |           34
       2 |           34
       3 |           21
       4 |           13
       5 |            8
       6 |            5
       7 |            3
       8 |            2
       9 |            1
      10 |            1

3) Write a class named Copying that can be used as context manager for writing
simple scripts that copy information an input file to an output file. It
defines an __init__ method taking the name of the input and output files as
arguments. It defines an __enter__ method that opens these file names for
reading/writing and prints 'Starting Copy' on the console. Copying defines a
read method that calls readline on the open input file and either (a) returns
the next line of the input file or (b) or raises the EOFError exception if that
line comes back empty; it defines a write method (with a string parameter) that
writes its parameter into the open output file. Finally, Copying defines an
__exit__ method that prints 'Stopping Copy....successfully on EOF' if that was
the exception that terminated the block (and considers the exception handled)
and prints 'Stopping Copy....on exception' if any other exception that
terminated the block (and considers the exception not handled). Here are three
examples of code using the Copying class as a context manager.

#pure copy
with Copying('input.txt','output.txt') as copy:
    while True:
        copy.write(copy.read())

#duplicate input lines for output
with Copying('input.txt','output.txt') as copy:
    while True:
        to_write = copy.read()
        copy.write(to_write)
        copy.write(to_write)

#only copy lines matching the string pattern
with Copying('input.txt','output.txt') as copy:
    re_pattern = re.compile(pattern)
    while True:
        to_write = copy.read()
        if re_pattern.match(to_write):
            copy.write(to_write)
  
4) Write the class Store_Once that defines an __init__ method taking a anything
that can be iterated over to produce strings as an argument (e.g., list of
strings, tuple of string, set of string) and stores all these strings in a set.
Define a __setattr__ method that allows currently unbound attributes to be set,
but raises Exception (with a reasonable message) if attempting to change the
binding of a currently bound attribute in the stored set. Raise the exception
only if the value is to be changed, not just rebound to the same (check using
the is or is not operator).
