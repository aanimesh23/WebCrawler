The final exam is worth 200 points (the midterm/in-lab exams were 150 points).
I have not written this exam yet, but I expect it to be like the midterm in
form: about 10 questions (some might have multiple parts), each covering about
1 week of material for the 10 week quarter. So, it is cumulative. Over this 120
minute test, that is about 12 minutes per question (to read and answer it).

We have covered way too much material for you to re-read everything. I suggest
primarily reviewing the quizzes and midterm, and then the programming
assignments: not reading them in depth, but being familiar with them and their
major themes. Of course you will be analyzing and writing code on the final
exam, but I expect there also to be a small number of questions to be answered
in English or with pictures/diagrams.

I will write in more detail over the weekend, after I have written the exam.
I will provide the same kind of preview I provided for the midterm.

Here is my view of the material that we covered.

------------------------------------------------------------------------------

Preliminaries/Basics
  EBNF
  Tokenization
  Defining and IMporting Names/Modules (binding them to objects they refer to)

Expressions
  Reading Function Headers and Calling Functions from modules
    the print ubiquitous function
       arbitrary number of arugments (str called on each)
       named parameters sep/end and their meanings
    parameter/argument binding
    functions from prompt/predicate modules
  Operators (individual meanings)	  
  Expressions built from literals, names, operators, and functions
    operator precedence, associativity, and parentheses 
    (eventually including conditional expressions, lambdas, and comprehensions)

Statements
  if, if/else, if{/elsif}/else
  for (with many objects to iterate over)
  while (boolean-test, or if/break)
  try/except
  return, assert, raise (typically used in functions)

Abstraction
  modules   (using-importing/writing-scripts and libraries)
  functions (using/writing)

Data Types
  "simple" types
      int, float, str, bool
  data structures
    lists (sorting lists, using lambdas)
    tuple (like list but no mutation)/named tuple (not used much)
    set
    dictonary/defaultdict
    combinations: e.g., lists/sets as dict values; dict keys are mostly str
  building data structures with comprehensions
  iterating over data structures with for loops
    iterating using sorted
    3 ways to iterative over dicts: keys, values, and items (producing 2-tuples)

Classes
  using prewritten classes: construction and calling methods
    standard classes (e.g., list) special classes (e.g. Dict)
  writing simple classes
    the __init__ method for construction
    methods: accessor/query (e.g., pip_sum) and mutatator/command (e.g., roll)

Special Topics
  program synthesis by iterative enhancement
  debugging (using simple print statements and the debugger)
  passing (uncalled) functions as arguments
    prompt functions using predicate functions to filter bad data

