<html><head><title>
ECHT'94:Chimera:Related Work</title>
</head><p>

<BODY TEXT="#000000" LINK="#0000FF" VLINK="#FF0000" ALINK="#00BB00" BGCOLOR="#FFFFFF">
<TABLE WIDTH=100%>
<TR ALIGN=CENTER VALIGN=MIDDLE>
<TD ALIGN=CENTER><A HREF="index.html#TOC">Table of Contents</A></TD>
<TD ALIGN=CENTER><A HREF="future.html">Future Work</A></TD>
<TD ALIGN=CENTER><A HREF="conclusions.html">Conclusions</A></TD>
</TR>
</TABLE>
<HR>
<H2>6. Related Work</H2>
There has been substantial evolution of hypertext functionality during the last decade and several significant efforts to apply hypertext to the software development problem (or similar). The systems described below are discussed in chronological order of appearance and were chosen either for their historical importance or because of their close relation to and impact upon the design of Chimera.
<H3><A NAME="Dexter">6.1 The Dexter Hypertext Reference Model</A></H3>
The Dexter Hypertext Reference Model (Dexter) is a framework for comparing hypertext systems developed as the result of two NIST workshops in 1988 [13]. It attempts to provide a standard hypertext terminology and also describe the important abstractions found in hypertext systems. At least one system has been developed based on Dexter (DeVise [12]) and Dexter itself has also been extended (AHM [16]).<p>

Dexter defines three layers: the run-time layer, the storage layer, and the within-component layer. The storage layer sits in the middle and interfaces with the run-time layer via presentation specifications, and the within-component layer via anchors. The storage layer creates a network of components of three types: atomic, composite, and link. Atomic components contain data stored in the within-component layer and presented by tools in the run-time layer. In addition, atomic components contain anchors which index directly into the data and allow the data to be linked. Composite components allow scalable hyperwebs to be constructed. Link components contain specifiers which describe how atomic and composite components are linked together.<p>

Chimera cannot be completely modeled in Dexter. For instance, Chimera can handle the presence of links with zero or one anchors (dangling links). Dexter's intolerance for such constructs has been widely criticized [12, 16, 21]. Also Chimera's notion of a view cannot be adequately modeled by a composite component, because a Chimera view contains information about the object being viewed and the viewer used to create the view. A composite component on the other hand only contains references to atomic components which only contain data. In Dexter, anchors are created directly on the data referenced by atomic components, whereas in Chimera, anchors are created on views not on the objects (i.e. data) themselves. This additional level of abstraction is not possible in Dexter. In fact, we believe that Dexter cannot model the case where the same object (atomic component) is displayed differently by two or more viewers with each viewer accessing a different set of anchors and links. Chimera's view concept handles this example easily while in Dexter there would be no way to specify it. Finally, a viewer is free to define its anchors with respect to anything in its view including objects which exist only at run-time e.g. a graphical widget. We believe that Dexter would be unable to specify this type of anchor, since a graphical widget lies in the domain of Dexter's "presentation specifications" and anchors can not be created in Dexter with respect to these specifications.
<H3><A NAME="VNS">6.2 Virtual Notebook System</A></H3>
The Virtual Notebook System (VNS) was built at the Baylor College of Medicine to support collaborative biomedical research via distributed hypertext services in a heterogeneous computing environment [28]. VNS is implemented by a set of work group servers (WGSs) distributed throughout a network. Each WGS is used to store text, graphics, and link information. Users typically store all their data with the WGS on their local machine but can also access information stored on another machine. The VNS Gatekeeper is used to integrate external tools with VNS, whereby information from these tools is copied and stored in a WGS. One interesting aspect of VNS is that while users may share data, they do not share links. Thus two users can see the same page but view different links. Link information for each user is stored separately from the data that makes up a page. After a page is constructed dynamically, a user's link information for that page is retrieved and displayed. Chimera is able to provide this functionality with its link filtering and can go one step further with its anchor filtering which allows users to see different anchors on a shared view.<p>

VNS, in contrast to Chimera, requires that all system information be stored in a database under its control. Integration in VNS is concerned with providing the ability to copy information out of an external tool and into a VNS database. At that point, the external tool is taken out of the loop; VNS handles the display of the data from then on. Integration in Chimera is only concerned with getting a viewer to communicate with the Chimera server. Chimera makes no attempt to display a viewer's objects.
<H3><A NAME="LinkService">6.3 Sun's Link Service</A></H3>
Sun's Link Service (LS) was a commercial product which defined a protocol for an extensible and loosely coupled hypertext system [25]. An application integrates with the LS by loading in a library which implements the protocol. This library allows communication with the LS control process which facilitates communication between link-aware applications. Applications provide call-back procedures to the LS so that they can receive link-related messages. Links are binary and are stored in a database managed by the LS control process.<p>

Chimera and the Link Service differ in three aspects. The LS promotes applications creating anchors on the underlying object via its data model. Chimera's anchors are created on a view of an object, not the object itself. This allows a Chimera viewer to store anchor information separately from the object (or objects) to which it refers. Links are hidden in the LS; that is, an application cannot retrieve links and manipulate them. This is not the case with Chimera, where links can be retrieved by an appropriate viewer and displayed in a variety of ways. This enables the creation of hierarchical hyperwebs. Finally Chimera's links are <I>n</I>-ary.
<H3><A NAME="Hyperform">6.4 Hyperform</A></H3>
Hyperform is an approach to creating flexible hyperbase support based on the notion of extensibility. It is joint work of the University of Aalborg and the Hypermedia Research Laboratory [37]. The Hyperform system is a simple framework which provides several built-in classes that perform basic hyperbase features such as concurrency control, notification control, access control, version control, and search and query. A user of Hyperform takes this initial framework and extends the built-in classes to produce a hyperbase system tailored for the hypermedia applications in the user's environment. The object-oriented language used to implement the Hyperform server is the key to its extensibility and allows for new data objects and methods to be added at run-time which in turns produces an environment conducive to rapid prototyping.<p>

The Chimera approach differs greatly from the Hyperform approach. The authors of Hyperform assert that a fixed hypermedia model hinders the development of new tools by forcing developers to make compromises in their applications to match the existing model [37]. Thus, the Hyperform approach has an implicit assumption that developers of hypermedia systems want to develop one system for a certain set of tools and another system for a different set of tools which require a different hypermedia model. After several iterations of this approach a user ends up with several hypermedia systems which we believe could be incompatible with each other. Thus, objects managed by one of these systems cannot be linked to objects in another of these systems, and presumably the effort required to update applications which use one data model to the other data model is non-trivial. This implicit assumption is simply not tenable in a software development environment which is already extremely heterogeneous. It seems counter-productive to introduce more diversity in such an environment with the addition of multiple potentially incompatible hypermedia systems. There is another assumption here that all of the objects in a hypermedia system are stored in a single database. This assumption is not valid in a software development environment in which multiple heterogeneous object management systems can exist and yet it is desirable to link objects stored in these diverse object repositories.<p>

Thus Chimera provides a flexible hypermedia model which was developed specifically for the needs of tools in a software development environment. This greatly reduces the chance that a specific tool cannot use the model provided by Chimera and not be able to participate in a Chimera hyperweb. In fact Chimera's hypermedia model was designed with the assumption that Chimera would enter an environment with many pre-existing tools which would eventually be integrated with it. Thus the model had to be as flexible as possible.
<H3><A NAME="Microcosm">6.5 Microcosm</A></H3>
Microcosm is an open hypertext system developed at the University of Southampton [5, 6, 15]. It is a link service that attempts to keep all aspects of the system such as the hypertext model, the messages passed from applications to Microcosm, and Microcosm's response to such messages open and tailorable. Microcosm-aware applications send selections and action pairs to the Microcosm Document Control System (DCS). The DCS sends the message through a chain of filters which act on the message by blocking it or passing it on, perhaps modifying it along the way. A special type of filter is a linkbase which upon finding the source of a link in the message attaches the destination of the link to the message.  The message emerges from the filter chain into the link dispatcher which presents to the user any actions contained in the resulting message. Microcosm can integrate non-aware Microcosm viewers through the use of a shared clipboard. However this is a worst-case situation that is rarely used as most applications that users want to use with Microcosm contain the hooks needed to integrate with Microcosm. Microcosm has been applied to situations involving several hundred megabytes of information and can handle multiple sets of links over the same set of data (by swapping in or out various linkbases in the filter chain).<p>

There are three distinctions between Chimera and Microcosm.
<OL TYPE="1" START="1">
	<LI>Microcosm uses a message-based API while Chimera uses a multi-lingual programmer's API.  Microcosm messages are in a tagged ASCII format. Filters act on tags in the ASCII message that they recognize and ignore all other tags. In addition, each filter can introduce any tag and its associated data into any message. In contrast, the details of Chimera's message format are hidden from Chimera clients by the Chimera API and the Chimera server by a message ADT. This use of abstraction allows the Chimera developers to freely change the format of the messages without affecting the rest of the system. This allows the message format to be as simple (ASCII text) or as complex (an Ada variant record) as needed to effectively support the semantics of the Chimera API. This freedom to change message formats is not available in Microcosm but their approach can potentially integrate more tools into their system since they do not have to modify each participating tool to use a programmer's API. Chimera's approach to integrating non-aware viewers is to create a wrapper or proxy program which uses both the Chimera API and whatever mechanism the non-aware viewer has to communicate with external systems.<p>

	<LI>All Microcosm-aware applications must provide all hypertext functionality via a menu-based interface. While this promotes a common interaction style between viewers, it may also prevent some applications (such as those without a graphical user interface) in participating in the system. Chimera does not prescribe or restrict a viewer's interface in any way, with the idea that in a software development environment, developers will tolerate inconsistency in interface in return for using a powerful tool within a Chimera hyperweb.<p>

	<LI>Microcosm has no analogous concept for Chimera's view concept. Each document in Microcosm has a user-defined physical type. Each physical type is associated with one viewer. When a particular document is the destination of a link traversal, Microcosm invokes the associated viewer on the specified document. Chimera's view concept is independent of where a particular data element is stored. This allows Chimera greater flexibility in handling multiple views of a single object, and also handles easily the case where a single view consists of data accessed from multiple sources.
</OL>
<H3><A NAME="SP">6.6 System Prototype 0, 1, 2, and 3</A></H3>
The Hypermedia Research Laboratory (HRL) at Texas A&M University has engaged in the building of several hypermedia systems (SP 0-3) since 1991 [19, 21]. At the same time, the HRL has also built a series of hyperbase systems (HB 0-3) to support the data storage requirements of these hypermedia systems [26, 27]. SP3 defines a flexible hypertext model. Applications manage components which have persistent selections created upon them. These persistent selections are attached to anchors which are then associated with links. These links create association sets that are modeled in the underlying hyperbase.<p>

This matches Chimera's hypertext concepts fairly well. The only difference being that multiple persistent selections can be associated with a single anchor. In Chimera, if the viewer wanted to associate multiple regions of its view to one anchor it could do so, but this would necessarily make the mapping function between anchors and regions of the view more complex. Typically Chimera viewers map one region per anchor, which would be the equivalent of mapping one persistent selection to anchor in SP3.  A distinctive feature of the HRL work is that anchors and links are first-class executing programs that can provide a wide range of run-time semantics.  It also allows user interaction with hypertext services to be handled by the anchor and link processes taking this burden off of the client applications. (This is handled by virtue of the fact that anchors and links are supplied as classes which have a default set of behaviors which applications can subclass and modify as desired.) SP3 and HB3 provide a sophisticated environment that represents a first attempt at providing hypermedia-in-the-large.<p>

The differences between Chimera and the HRL work are many. For instance, Chimera is not yet at a state where it can support multi-user collaboration on a shared hyperweb. A few additional differences are outlined below.
<UL TYPE=DISK>
	<LI>Chimera has taken a different approach with respect to anchors and links. They are objects managed by viewers and the Chimera server respectively as opposed to being first-class processes. This allows for anchors to be specifically tailored to a viewer while placing a burden on viewer developers to implement this functionality for each new viewer. It allows links to be handled in a consistent manner at the price of implementing special link behaviors in the Chimera server.<p>

	<LI>SP3 requires applications to use its object manager (HB3) to store application data; this allows SP3 to support versioning of application data and hypertext information. Chimera, in contrast, places no such restrictions on its viewers requiring viewer cooperation to provide reliable versioning.<p>

	<LI>Chimera associates anchors with views, while SP3 associates anchors with persistent selections which refer directly to an application's data. This enables Chimera, when combined with a viewer mechanism such as Chiron, to provide greater flexibility in displaying an anchor, supporting the ability of several viewers (concurrently) providing different views of the same object, where the anchors and their presentation are view-specific (and this all separated by Chiron from any application code). This is similar, though, to SP3's notion of a context. In SP3, depending on the context, different sets of anchors and links will be made available to an application displaying the object. Contexts are handled in Chimera through a combined use of attribute-value pairs and the filtering of anchors and links by the Chimera server for a particular view.<p>

	<LI>SP3 links are not "ordinary" objects and thus anchors cannot be defined upon them and thereby participate in hierarchical webs. Thus Chimera appears to have a scalability advantage.
</UL>
<HR>
<TABLE WIDTH=100%>
<TR ALIGN=CENTER VALIGN=MIDDLE>
<TD ALIGN=CENTER><A HREF="index.html#TOC">Table of Contents</A></TD>
<TD ALIGN=CENTER><A HREF="future.html">Future Work</A></TD>
<TD ALIGN=CENTER><A HREF="conclusions.html">Conclusions</A></TD>
</TR>
</TABLE><HR><p>


<h4>
<hr size=1 noshade>
This page is part of the <A HREF="http://www.ics.uci.edu/pub/chimera/">Chimera</A> web site.<BR>
Send feedback and questions to <A HREF="mailto:kanderso@ics.uci.edu">Ken Anderson</A>.<BR>
Last updated on Thu, Sep 19, 1996 at 12:35:11 PM. 
</h4>
</body></html>
