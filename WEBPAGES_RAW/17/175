<html>
<head>
<title> User-Interface </title>
</head>

<body>
<h1> User Interface </h1>
<h3> Goals: Problems </h3>
  <ul>
  <li> Display information: textually and graphically
  <li> Get information: usually text, sometimes numerics.
  <li> Respond to events
  </ul>
<h3> Solutions </h3>
  <ul>
     <li> Component are standard displayable units (user-interface
elments), e.g  menus, buttons, labels, lists, textFields, etc
     <li> Containers allows us to compose components. They include
      Panels,  Windows, Diaglog, Frame, etc.
     <li>  LayoutManagers are  interfaces that provide
   reasonable ways to size and position objects  within a container.
   We can turn this off if we want to work hard.
     <li> Graphics provide a way to control individual
  pixels and colors, giving  complete control over the image.
     <li> Registering and implementing Listeners provide a means to attach
      particular actions  to selected/choosen events.
   </ul>

<pre>
                                   / -> Button
                                  /
              Object --> Component  -->  List
                                   \ 
                                    \ --> Textfield
                                     \
                                      \ --> Choice ....

</pre>

<h3> Important Methods in Object and Component: </h3>
 <ul>
  <li><b>paint:</b>  redraws the visual  object
  <li> <b> setBounds(x,y,w,d):</b> sets location to x,y and size to w,d   
  <li> <b> setSize(w,d): </b> ...
  <li> <b> getSize(): </b> returns Dimension  (two-tuple with fields width and height)
  <li> <b> setEnabled(Boolean b): </b> sets control to active or inactive, ie
    whether it responds to events(?).
  <li> <b> getBackground(): </b> returns  a Color 
  <li> <b> setBackground(Color c): </b> ...
  <li> <b> setVisible(Boolean b): </b>  whether you can see control.
  <li> <b> isEnable(): </b> returns boolean. Whether control is selectable
  by user. 
  <li> <b> isVisible(): </b> returns boolean 
  <li> <b> getLocation():</b> returns a Dimension
  <li> <b> setLocation(x,y): </b> ..
  <li> <b> getComponent(): </b> Gives reference to event source.
  <li> <b>repaint(): </b> schedules painting.
  <li> <b> requestFocus(): </b> Asks system of give  Focus to control (?).
  <li> <b> setFont(Font f): </b>  Sets font to f, which include size, font,
and style.
  </ul>
<h3> Components or Visual Controls  </h3>

 These descriptions are deliberately not complete, however they
provide the flavor of these controls. The capabilities of these
objects will probably change. Use a web-browser to get the latest
Java.api details.

  <ul>
   <li> Button
      <ul>
       <li> Purpose: get simple selection from from user, i.e. button chosen.
       <li> Constructors:    = new Button() or new Button(String)
       <li> Method: addActionListener(ActionListener actlist)
       <li> Note; actlist must implement actionPerformed (i.e. implements
             ActionListener)
       </ul>
   <li> Label
       <ul>
         <li> Purpose: display unchangeable text on screen
         <li> Constructors: new Label() or new Label(String,alignment) where
     alignment is LEFT, CENTER or RIGHT.
         <li> Labels have a size and text can be aligned within it, e.g. via
        method setAlignment(Label.LEFT).
         <li> As a component it fires (responds to) component, mouse,
           and mouse-motion events.
       </ul>
   <li> Radio button
        <ul>
          <li> Purpose: allows multiple  choices
          <li> label with on/off button
          <li> appearance may change with different browsers.
          <li> Can be initialized 
          <li> Ex. TBD
          <li> Method: TBD
         </ul>
   <li> Checkbox
       <ul>
           <li> Purpose: get multiple choices from users
           <li> independent clickable labelled box
           <li> Constructors: Checkbox(String), Checkbox(String,boolean) 
           <li> methods: getState, getLabel, addItemListener
           <li> listener must implement itemStateChanged(ItemEvent)
       </ul>
   <li> CheckboxGroup
        <ul>
           <li> Purpose: to allow only one choice from a set of choices.
           <li> Requires that CheckboxGroup be constructed with added parameter
           <li> Example
   <pre>
         CheckboxGroup cbg = new CheckboxGroup();
         Checkbox happy = new Checkbox("happy",t,cbg);
         Checkbox sad   = new Checkbox("sad",f,cbg);
   </pre>
          </ul>
   <li> Choice
      <ul>
        <li> Purpose: display and get as many selections as needed, e.g.
  the number of choices is larger than will fit on screen. 
        <li> Constructor: Choice()
        <li> Methods: add(String item), remove(item), insert(item, position),
       removeall.
        <li> Generates events for selection and deselection
      </ul>

  <li> TextComponent 
      <ul>
        <li> Purpose: displaying and capturing text
        <li> Children: TextField and TextArea
   <br> note: text can be parsed into numerics with a little work.
        <li> String getText()
        <li> setText(String)
        <li> boolean isEditable()
        <li> setEditable() : determines if user can write in area
        <li> void addTextListener(TextListener)
      </ul>
  <li> TextField
    <ul>
      <li> Constructors: TextField(), TextField(String), TextField(int columns),...
      <li> inherits from TextComponent
      <li> Single line area for text io.
     <li> TextField tf = TextField("Hi there");
     <li> TextField tf = TextField(10); 
     <br> size of display, more can be in it  but you won't see it.
     <li> TextField tf = TextField();
     <li> setEchoChar(char) : for passwords and the like
     <li>  Method: addActionListener(ActionListener) 
     </ul>
   <li> TextArea
     <ul>
       <li> Constructor: TextArea(), TextArea(rows,columns), ...
       <li> inherits from TextComponent
       <li> Multi-line area for text io.
       <li> Methods: addActionListener
     </ul>
   <li> Canvas
     <ul>
       <li> Purpose: making drawings or images. Complete control
       <li> Constructor: Canvas()
       <li> Typically you inherit your own Canvas class from Canvas
      and override the paint() method.
       <li> Methods: addActionListener
     </ul>
   <li> Panel
     <ul>
      <li> Purpose: organize a group of related grahical objects.
      <li> Constructors: Panel(), Panel(LayoutManager)
      <li> Containers have the method add(Component)
      <li> default layout manager: FlowLayout, which displays objects
         left to right as they fit.
      <li> Like a canvas, you can draw directly on it.
      </ul>
   <li> ScrollBar
     <ul>
       <li> Purpose: to get or display  values and to scroll
       <li> Constructor:  ScrollBar(), ScrollBar(orientation),...
       <li> can be horizontal or vertical
       <li> ranges and increments can be set
       <li> usually part of a panel or another component
       <li> method addAdjustmentListener
     </ul>
   <li> Scrollpane
       <ul>
         <li> Purpose: create vertical, horizontal or both scrollable viewarea
         <li> Constructor: ScrollPane(), ScrollPane(scrollbarDisplayPolicy)
         <li> allows only 1 component to be displayed at a time.
         <li> takes over most old uses of ScrollBar (a better ScrollBar)
         <li> new to JDK1.1
       </ul>
   <li> List
     <ul>
       <li> Purpose: get selections from users
       <li> Constructors: List(), List(rows), List(rows, mode)
       <li> scrollable list of text entries
       <li> constructor: List(int,boolean) where int is number of
     items displayed and boolean controls whether multiple selections allowed.
       <li> Some methods: add and delete items, select and deselect,
            allow/disallow multiple selections 
     </ul>

   <li> Menu
      <ul>
        <li> Purpose: allow nested selections
        <li> Constructors: Menu(), Menu(title), Menu(title, boolean tearoff)
        <li> Contains menus or menuitems.
        <li> Tedious to code
        <li> Methods: add, insert, remove etc.
       </ul>
   <li> Menubar
       <ul>
        <li> Purpose: holds pop-up menus.
        <li> Constructor: MenuBar() 
        <li> horizontal display of selectable menus.
        <li> Methods: add, insert, remove, etc
       </ul>
   <li> MenuItem
        <ul>
            <li> Purpose: Permits selections
            <li> Constructors: MenuItem(), MenuItem(String),...
        </ul>
   <li> DialogBox
       <ul>
         <li> Purpose: Get user response.
         <li> Modal dialogboxes require that user respond
          <li> Modeless dialogboxes can be ignored.
        </ul>
<!-- see page 8 in Graphic Java   -->
  </ul>



There currently are about a dozen graphic widgets,  each with as many
as 70 methods and sometimes lots of constants. Do not try to learn
them, but instead understand their general structure and how to use
them. Moreover this number keeps changing. And you can create
your own user-interface elements with them.
Typically one builds the type of display
desired by combining inheritance and composition.
<p>
<b>Warning</b>: The list of methods and graphical objects is not complete.


<h3> Graphics Methods, in java.awt.Graphics </h3>
 All of this methods apply to a graphics object, e.g. to
 write "don't press" to the screen you would use:
  <pre>
        Graphics g = getGraphics();
        g.drawString("don't press",100,200);
   </pre>
  <ul>
   <li> drawString(String s, int x, int y)
   <li> drawLine(int x1, int y1, int x2, int y2)
   <li> drawPolygon(int[] xPoints, int[] yPoints, int nPoints)
    <br> nPoints is the number of points
   <li> drawPolygon(Polygon p)
     <br> To creat a Polygon: Polygon p = new Polygon();
     <br> To add a point to it: p.addPoint(x,y);
   <li> drawArc(int x, int y, int width, int height, int startAngle, int arcAngle)
   <br> startAngle is measured from the horizontal, counterclockwise
   <br> arcAngle is measured relative to  the start angle
   <li> drawRect(int x, int y, int width, int height) 
   <li> etc: ovals, 3d rectangles, rounded rectangles, filled shapes, ...
   <li> images also, but we will not cover these.
</ul>

<h3> Layout Managers </h3>

  Layout managers can be nested. They permit reasonable 
ways to organize the graphical layout.  You can define
your own Layout Manager.
  <ul>
     <li> setLayout(null);
        <ul>
          <li> turns off any default layout manager
          <li> requires that you place each object on display via
   explicit locations
          <li> not fun and usually avoided.
       </ul> 
     <li> FlowLayout()
        <ul>
         <li> Often the default, e.g. default for Panels.
         <li> established via: setLayout(new FlowLayout());
        <li> Like wrap-around text layout. 
          <li> Components are placed left to right as they fit.
          <li> Note: resizing window will change appearance.
        </ul>
     <li> BorderLayout()
        <ul>
            <li> Divides component into 5 areas: North, South, East, West
                and Center.
            <li> E.G. to a button to cmp  to the East:
        <br> cmp.add(new Button("Hi"),"East");
           <li> Often a useful way to layout a window or a subcomponent
          of a window, especially when combined with panels.
          <li> Components take as much room as available.
          <li> not all pieces need be specified.
    </ul>
        <li> GridLayout(int row, int col)
        <ul>
            <li> Divides component into "row" rows and "col" columns.
            <li> add(component) goes into the next available (row,col).
            <li> to skip an entry do add(new Label("")), i.e. add an empty
        label.
        </ul>
       <li> CardLayout(int hgap, int vgap)
         <ul>
           <li> This displays one component at a time.
           <li> This layout manager requires a parent container.
           <li> individual items are display one at a time.
           <li> You can move thru item in natural ways, ie.
         next, previous, first, last.
          <li> Example
           <pre>
                Button next = new Button("Next");
                next.addActionListener(this);
                ... more buttons
                Panel movement = New Panel();
                movement.add(next);
                ... more additions of buttons
                Panel display = New Panel();
                display.setLayout(new CardLayout());
                display.add(component1);
                ... 
          public void actionPerformed(ActionEvent ae)
        {
          if (ae.getSource() = next) display.next()
        }
        </pre>      
         </ul>
       <li> GridBagLayout
         <ul>
           <li> Permits great control over display
           <li> Complex. Read about it.
         </ul>

  </ul>
</body>