<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- Page automatically generated from latex_to_html converter. -->
<!-- by cc_extract_html, $Revision: 3.19 $ -->
<!-- LaTeX source file: './Nef_S2_ref/Nef_polyhedron_S2.tex' -->
<html> <head>  
<title>Nef_polyhedron_S2&lt;Traits&gt;</title>
</head>  
<link href="../latex_to_html.css" rel="STYLESHEET">
<body bgcolor="white">
<!-- ------------------------------------------------------------------- -->


<!-- Top Navigation ---------------------------------------------------- -->
<div class="NavTop">
<hr>
  <strong>Navigation:</strong>
<a href="Chapter_intro.html">Up</a>, 
  <a href="../contents.html">Table of Contents</A>,
  <a href="../biblio.html">Bibliography</a>,
  <a href="../manual_index.html">Index</a>,
  <a href="../title.html">Title Page</a>
<hr><!-- End of Top Navigation ----------------------------------------- -->
</div>


<A NAME="Cross_link_anchor_726"></A>

<A NAME="Cross_link_anchor_727"></A>

      
     
     
     
<A NAME="Index_anchor_759"></A> 

   
<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC="cc_Class.gif"></TD></TR></TABLE>


    <A NAME="ccRef_CGAL::Nef_polyhedron_S2<Traits>"></A>
<h2><I>CGAL::Nef_polyhedron_S2&lt;Traits&gt;</I></h2>
<P>

<H3>Definition</H3>
<P>

An instance of data type <I><A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;</I> is a subset of
the sphere <MATH><I>S<SUB>2</SUB></I></MATH> that is the result of forming complements and 
intersections starting from a finite set <I>H</I> of halfspaces 
bounded by a plane containing the origin. Halfspaces correspond to 
hemispheres of <MATH><I>S<SUB>2</SUB></I></MATH> and are therefore modeled by oriented great 
circles of type <I>Sphere_circle</I>. <I><A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A></I> is 
closed under all binary set operations <I><A HREF="../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221">intersection</A></I>, <I>union</I>,
<I>difference</I>, <I>complement</I> and under the topological
operations <I>boundary</I>, <I>closure</I>, and <I>interior</I>.
<P>

<I>#include &lt;<A HREF="../../../include/CGAL/Nef_polyhedron_S2.h">CGAL/Nef_polyhedron_S2.h</A>&gt;</I>
<P>

<H3>Parameters</H3>
<P>

<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>

<I>template &lt;</I> 
        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I>class Nef_polyhedronTraits_S2,</I>
    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>

        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I>class Nef_polyhedronItems_S2 = CGAL::SM_items,</I>
    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>

        </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I>class Nef_polyhedronMarks = bool</I>
    </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I>class <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>;</I>

</TD></TR></TABLE>
<P>

The first parameter requires one of the following exact kernels:
<I><A HREF="../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18">Homogeneous</A></I>, <I><A HREF="../Kernel_23_ref/Class_Simple_homogeneous.html#Cross_link_anchor_32">Simple_homogeneous</A></I> 
parametrized with <I><A HREF="../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364">Gmpz</A></I>, <I><A HREF="../NumberTypeSupport_ref/Class_leda_integer.html#Cross_link_anchor_1388">leda_integer</A></I> or any other number type
modeling  <IMG BORDER=0 WIDTH=10 HEIGHT=12 ALIGN=BOTTOM SRC="cc_mathbb_Z.gif"> , or <I><A HREF="../Kernel_23_ref/Class_Cartesian.html#Cross_link_anchor_6">Cartesian</A></I>, <I><A HREF="../Kernel_23_ref/Class_Simple_cartesian.html#Cross_link_anchor_30">Simple_cartesian</A></I> parametrized with 
<I><A HREF="../NumberTypeSupport_ref/Class_Gmpq.html#Cross_link_anchor_1362">Gmpq</A></I>, <I><A HREF="../NumberTypeSupport_ref/Class_leda_rational.html#Cross_link_anchor_1389">leda_rational</A></I>,<I><A HREF="../NumberTypeSupport_ref/Class_Quotient.html#Cross_link_anchor_1404">Quotient</A>&lt;<A HREF="../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364">Gmpz</A>&gt;</I> or any other number 
type modeling  <IMG BORDER=0 WIDTH=12 HEIGHT=25 ALIGN=MIDDLE SRC="cc_mathbb_Q.gif"> .
<P>

The second parameter and the third parameter are for future considerations.
Neither <I>Nef_polyhedronItems_S2</I> nor <I>Nef_polyhedronMarks</I> is
specifed, yet. Do not use other than the default types for these two 
template parameters.
<P>

<H3>Types</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2-Traits---Sphere_point.html#Cross_link_anchor_729">Nef_polyhedron_S2&lt;Traits&gt;::Sphere_point</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    points in the sphere surface.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2-Traits---Sphere_segment.html#Cross_link_anchor_731">Nef_polyhedron_S2&lt;Traits&gt;::Sphere_segment</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    segments in the sphere surface.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2-Traits---Sphere_circle.html#Cross_link_anchor_733">Nef_polyhedron_S2&lt;Traits&gt;::Sphere_circle</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    oriented great circles modeling spatial
  half-spaces.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SVertex_const_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    non-mutable handle to svertex.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SHalfedge_const_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    non-mutable handle to shalfedge.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SHalfloop_const_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    non-mutable handle to shalfloop.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SFace_const_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    non-mutable handle to sface.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SVertex_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    non-mutable iterator over all svertices.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SHalfedge_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    non-mutable iterator over all shalfedges.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SHalfloop_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    non-mutable iterator over all shalfloops.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SFace_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    non-mutable iterator over all sfaces.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SHalfedge_around_svertex_const_circulator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    circulating the
  adjacency list of an svertex <I>v</I>.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SHalfedge_around_sface_const_circulator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    circulating the
  sface cycle of an sface <I>f</I>.
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::SFace_cycle_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterating all sface cycles of
  an sface <I>f</I>.  The iterator has method <I>bool is_svertex()</I>,
  <I>bool is_shalfedge()</I>, <I>bool is_shalfloop()</I>, and can be
  converted to the corresponding handles <I>SVertex_const_handle</I>,
  <I>SHalfedge_const_handle</I>, or <I>SHalfloop_const_handle</I>.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::Mark
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    attributes of objects (vertices, edges, faces).
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::size_type
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    size type
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Function_Boundary"></A>
<A NAME="Enum_Boundary"></A>
<A HREF="../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum">enum</A> <A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">Boundary</A> { <A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">EXCLUDED</A><A NAME="Function_Boundary"></A>
, <A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">INCLUDED</A><A NAME="Function_Boundary"></A>
};
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    construction selection.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Function_Content"></A>
<A NAME="Enum_Content"></A>
<A HREF="../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum">enum</A> <A HREF="Class_Nef_polyhedron_S2#Enum_Content">Content</A> { <A HREF="Class_Nef_polyhedron_S2#Enum_Content">EMPTY</A><A NAME="Function_Content"></A>
, <A HREF="Class_Nef_polyhedron_S2#Enum_Content">COMPLETE</A><A NAME="Function_Content"></A>
};
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    construction selection.
<P>

</TD></TR>
        </TABLE>
<P>

<H3>Creation</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt; N ( <A HREF="Class_Nef_polyhedron_S2#Enum_Content">Content</A> sphere = <A HREF="Class_Nef_polyhedron_S2#Enum_Content">EMPTY</A>);
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates
  an instance <I>N</I> of type <I><A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;</I> and
  initializes it to the empty set if <I>sphere == <A HREF="Class_Nef_polyhedron_S2#Enum_Content">EMPTY</A></I> and to the
  whole sphere if <I>sphere == <A HREF="Class_Nef_polyhedron_S2#Enum_Content">COMPLETE</A></I>.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt; N ( Sphere_circle c,  <A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">Boundary</A> circle = <A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">INCLUDED</A>);
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates a Nef polyhedron <I>N</I> containing the
  half-sphere left of <I>c</I> including <I>c</I> if
  <I>circle==<A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">INCLUDED</A></I>, excluding <I>c</I> if <I>circle==<A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">EXCLUDED</A></I>.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    template &lt;class Forward_iterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt; N ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Forward_iterator first,<BR>

Forward_iterator beyond,<BR>

<A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">Boundary</A> b = <A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">INCLUDED</A>);</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates a Nef polyhedron <I>N</I>
  from the set of sphere segments in the iterator range
  <I>[first,beyond)</I>. If the set of sphere segments is a simple
  polygon that separates the sphere surface into two regions, then the
  polygonal region that is left of the segment <I>*first</I> is
  selected. The polygonal region includes its boundary if <I>b =     <A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">INCLUDED</A></I> and excludes the boundary otherwise.
  <I>Forward_iterator</I> has to be an iterator with value type
  <I>Sphere_segment</I>.
<P>

</TD></TR>
        </TABLE>
<P>

<H3>Operations</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_clear6Content_plane_=_EMPTY9_;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.clear ( <A HREF="Class_Nef_polyhedron_S2#Enum_Content">Content</A> plane = <A HREF="Class_Nef_polyhedron_S2#Enum_Content">EMPTY</A>)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    makes <I>N</I> the
  empty set if <I>plane == <A HREF="Class_Nef_polyhedron_S2#Enum_Content">EMPTY</A></I> and the full plane if <I>plane     == <A HREF="Class_Nef_polyhedron_S2#Enum_Content">COMPLETE</A></I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_empty69_;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    N.is_empty ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns true if <I>N</I> is empty, false
  otherwise.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_sphere69_;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    N.is_sphere ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns true if <I>N</I> is the whole
  sphere, false otherwise.
        </TD></TR>
        </TABLE>
<P>

<H3>Constructive Operations</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Nef_polyhedron_S26K9_complement69_;"></A>
<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    N.complement ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the complement
  of <I>N</I> in the plane.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Nef_polyhedron_S26K9_interior69_;"></A>
<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    N.interior ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the interior of
  <I>N</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Nef_polyhedron_S26K9_closure69_;"></A>
<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    N.closure ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the closure of
  <I>N</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Nef_polyhedron_S26K9_boundary69_;"></A>
<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    N.boundary ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the boundary of
  <I>N</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Nef_polyhedron_S26K9_regularization69_;"></A>
<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.regularization ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the
  regularized polyhedron (closure of interior).
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Nef_polyhedron_S26K9_intersection6const_Nef_polyhedron_S26K9__N19_;"></A>
<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.<A HREF="../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221">intersection</A> (  <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt; N1)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>N</I> <MATH><I> <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC="cc_cap.gif"> </I></MATH> <I>N1</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Nef_polyhedron_S26K9_join6const_Nef_polyhedron_S26K9__N19_;"></A>
<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.join (  <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt; N1)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>N</I> <MATH><I> <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC="cc_cup.gif"> </I></MATH> <I>N1</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Nef_polyhedron_S26K9_difference6const_Nef_polyhedron_S26K9__N19_;"></A>
<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.difference (  <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt; N1)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>N</I> <MATH><I>-</I></MATH> <I>N1</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Nef_polyhedron_S26K9_symmetric_difference6_const_Nef_polyhedron_S26K9__N19_;"></A>
<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.symmetric_difference (  <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;K&gt; N1)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the symmectric difference
  <I>N - T</I> <MATH><I> <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC="cc_cup.gif"> </I></MATH> <I>T - N</I>.
        </TD></TR>
        </TABLE>
<P>

Additionally there are operators <I>*,+,-,^,!</I> which implement the
binary operations <I><A HREF="../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221">intersection</A></I>, <I>union</I>,
<I>difference</I>, <I>symmetric difference</I>, and the unary
operation <I>complement</I> respectively. There are also the
corresponding modification operations <I>*=,+=,-=,^=</I>.
<P>

There are also comparison operations like <I>&lt;,&lt;=,&gt;,&gt;=,==,!=</I> which
implement the relations subset, subset or equal, superset, superset or
equal, equality, inequality, respectively.
<P>

<H3>Statistics and Integrity</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Size_type_number_of_svertices69_;"></A>
Size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.number_of_svertices ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of
  svertices.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Size_type_number_of_shalfedges69_;"></A>
Size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.number_of_shalfedges ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of
  shalfedges.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Size_type_number_of_sedges69_;"></A>
Size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.number_of_sedges ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of sedges.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Size_type_number_of_shalfloops69_;"></A>
Size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.number_of_shalfloops ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of
  shalfloops.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Size_type_number_of_sloops69_;"></A>
Size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.number_of_sloops ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of sloops.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Size_type_number_of_sfaces69_;"></A>
Size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.number_of_sfaces ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of sfaces.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Size_type_number_of_sface_cycles69_;"></A>
Size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.number_of_sface_cycles ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of
  sface cycles.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Size_type_number_of_connected_components69_;"></A>
Size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.number_of_connected_components ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    calculates the
  number of connected components of <I>P</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_print_statistics6std::ostream__os_=_std::cout9_;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.print_statistics ( std::ostream&amp; os = std::cout)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    print
  the statistics of <I>P</I>: the number of vertices, edges, and faces.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_check_integrity_and_topological_planarity6bool_faces=true9_;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    N.check_integrity_and_topological_planarity ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    bool faces=true)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    checks the link structure and the genus of <I>P</I>.
        </TD></TR>
        </TABLE>
<P>

<H3>Exploration - Point location - Ray shooting</H3> As Nef
polyhedra are the result of forming complements and intersections
starting from a set <I>H</I> of half-spaces that are defined by
oriented lines in the plane, they can be represented by an attributed
plane map <MATH><I>M = (V,E,F)</I></MATH>. For topological queries within <I>M</I> the
following types and operations allow exploration access to this
structure.
<P>

<H3>Types</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>&lt;Traits&gt;::Object_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    a generic handle to an object of the
  underlying plane map. The kind of object <I>(vertex, halfedge,     face)</I> can be determined and the object can be assigned to a
  corresponding
  handle by the three functions:<BR>

<I>bool <A HREF="../Kernel_23_ref/Function_assign.html#Cross_link_anchor_90">assign</A>(Vertex_const_handle&amp; h, Object_handle)</I><BR>

<I>bool <A HREF="../Kernel_23_ref/Function_assign.html#Cross_link_anchor_90">assign</A>(Halfedge_const_handle&amp; h, Object_handle)</I><BR>

<I>bool <A HREF="../Kernel_23_ref/Function_assign.html#Cross_link_anchor_90">assign</A>(Face_const_handle&amp; h, Object_handle)</I><BR>

where each function returns <I>true</I> iff the assignment to <I>h</I>
  was done.
<P>

</TD></TR>
        </TABLE>
<P>

<H3>Operations</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_contains6Object_handle_h9_;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.contains ( Object_handle h)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns true iff the
  object <I>h</I> is contained in the set represented by <I>N</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_contained_in_boundary6Object_handle_h9_;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.contained_in_boundary ( Object_handle h)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns true
  iff the object <I>h</I> is contained in the <MATH><I>1</I></MATH>-skeleton of <I>N</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Object_handle_locate6const_Sphere_point__p9_;"></A>
Object_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.locate (  Sphere_point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a
  generic handle <I>h</I> to an object (face, halfedge, vertex) of the
  underlying plane map that contains the point <I>p</I> in its relative
  interior. The point <I>p</I> is contained in the set represented by
  <I>N</I> if <I>N.contains(h)</I> is true. The location mode flag
  <I>m</I> allows one to choose between different point location
  strategies.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Object_handle_ray_shoot6const_Sphere_point__p+_const_Sphere_direction__d9_;"></A>
Object_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    N.ray_shoot (  Sphere_point p,  Sphere_direction d)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a handle <I>h</I> with
  <I>N.contains(h)</I> that can be converted to a
  <I>Vertex_/Halfedge_/Face_const_handle</I> as described above. The
  object returned is intersected by the ray starting in <I>p</I> with
  direction <I>d</I> and has minimal distance to <I>p</I>.  The
  operation returns the null handle <I>NULL</I> if the ray shoot along
  <I>d</I> does not hit any object <I>h</I> of <I>N</I> with
  <I>N.contains(h)</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Object_handle_ray_shoot_to_boundary6const_Sphere_point__p+_const_Sphere_direction__d9_;"></A>
Object_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    N.ray_shoot_to_boundary ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Sphere_point p,<BR>

Sphere_direction d)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a handle <I>h</I> that can be
  converted to a <I>Vertex_/Halfedge_const_handle</I> as described
  above. The object returned is part of the <MATH><I>1</I></MATH>-skeleton of <I>N</I>,
  intersected by the ray starting in <I>p</I> with direction <I>d</I>
  and has minimal distance to <I>p</I>.  The operation returns the null
  handle <I>NULL</I> if the ray shoot along <I>d</I> does not hit any
  <MATH><I>1</I></MATH>-skeleton object <I>h</I> of <I>N</I>. The location mode flag
  <I>m</I> allows one to choose between different point location
  strategies.
        </TD></TR>
        </TABLE>
<P>

<H3>Iteration</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_has_shalfloop69_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    N.has_shalfloop ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns true iff there is 
  a shalfloop.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_SHalfloop_const_handle_shalfloop69_const;"></A>
SHalfloop_const_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    N.shalfloop ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns access to the
  sloop.
        </TD></TR>
        </TABLE>
<P>

The list of all objects can be accessed via iterator ranges.
For comfortable iteration we also provide iterations macros. 
The iterator range access operations are of the following kind:<BR>

<I>SVertex_iterator   svertices_begin()/svertices_end()</I><BR>

<I>SHalfedge_iterator shalfedges_begin()/shalfedges_end()</I><BR>

<I>SHalfloop_iterator shalfloops_begin()/shalfloops_end()</I><BR>

<I>SFace_iterator     sfaces_begin()/sfaces_end()</I>
<P>

The macros are then <I>CGAL_forall_svertices(v,M)</I>,
<I>CGAL_forall_shalfedges(e,M)</I>, <I>CGAL_forall_sfaces(f,M)</I>,
<I>CGAL_forall_sface_cycles_of(fc,F)</I> where <I>M</I> is a sphere map
and <I>F</I> is a sface.
<P>

<H3>Input and Output</H3> A Nef polyhedron <I>N</I> can be
visualized in an open GL window. The output operator is defined in the
file <I>CGAL/IO/Nef_-poly-hedron_2_-Win-dow_-stream.h</I>.
<P>

<H3>Implementation</H3>
<P>

Nef polyhedra are implemented on top of a halfedge data structure and
use linear space in the number of vertices, edges and facets.
Operations like <I>empty</I> take constant time. The operations
<I>clear</I>, <I>complement</I>, <I>interior</I>, <I>closure</I>,
<I>boundary</I>, <I>regularization</I>, input and output take linear
time. All binary set operations and comparison operations take time
<MATH><I>O(n </I></MATH>log<MATH><I>n)</I></MATH> where <MATH><I>n</I></MATH> is the size of the output plus the size of the
input.
<P>

The point location and ray shooting operations are implemented in the
naive way. The operations run in linear query time without any
preprocessing.
<P>

<H3>Example</H3>
<P>

Nef polyhedra are parameterized by a standard CGAL kernel. The example
computes the <A HREF="../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221">intersection</A> of two Nef polyhedra <I>N1</I> and <I>N2</I>.
<P>

<pre class="ExampleCode">// examples/Nef_S2/simple.C

#include &lt;CGAL/<A HREF="../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1364">Gmpz</A>.h&gt;
#include &lt;CGAL/<A HREF="../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_18">Homogeneous</A>.h&gt;
#include &lt;CGAL/<A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_727">Nef_polyhedron_S2</A>.h&gt;

typedef <A HREF="../NumberTypeSupport_ref/Class_Gmpz.html#Cross_link_anchor_1363">CGAL::Gmpz</A> RT;
typedef <A HREF="../Kernel_23_ref/Class_Homogeneous.html#Cross_link_anchor_17">CGAL::Homogeneous</A>&lt;RT&gt; <A HREF="../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0">Kernel</A>;
typedef <A HREF="Class_Nef_polyhedron_S2.html#Cross_link_anchor_726">CGAL::Nef_polyhedron_S2</A>&lt;<A HREF="../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0">Kernel</A>&gt; Nef_polyhedron;
typedef Nef_polyhedron::Sphere_circle Sphere_circle;

int main()
{
  Nef_polyhedron N1(Sphere_circle(1,0,0));
  Nef_polyhedron N2(Sphere_circle(0,1,0), Nef_polyhedron::<A HREF="Class_Nef_polyhedron_S2#Enum_Boundary">EXCLUDED</A>);
  Nef_polyhedron N3 = N1 * N2;
  return 0;
}
</pre>
<P>

<div class="NavNext"><hr> <b>Next:</b> <a href="Class_Nef_polyhedron_S2-Traits---Sphere_point.html"><I>Nef_polyhedron_S2&lt;Traits&gt;::Sphere_point</I></a> 


    
<div class="NavBottom">
<hr><!-- Bottom Navigation --------------------------------------------- -->
  <strong>Navigation:</strong>
<!Up_chapter_link_14!>
  <a href="../contents.html">Table of Contents</A>,
  <a href="../biblio.html">Bibliography</a>,
  <a href="../manual_index.html">Index</a>,
  <a href="../title.html">Title Page</a>
<!-- End of Bottom Navigation ------------------------------------------ -->


<hr><!-- --------------------------------------------------------------- -->
<div class="NavAddress">

The <A HREF=http://www.cgal.org>CGAL Project</A> .

Tue, December 21, 2004 .
<hr></div>
</body>  </html>  
