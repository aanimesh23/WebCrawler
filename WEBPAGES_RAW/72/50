<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
  <title>Outline</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Outline for ICS-21 Written Final Exam</h1>
<p>
</center>
<hr align="left" width="100%">
<p>

I have collected together in this one handout the list of topics that we have
  covered in the second half of ICS-21.
This list is quite extensive (not as long as for the first half of the course,
  but the topics are a bit more subtle and have many connections with each
  other and the material that we studied earlier), and there is no way that I
  can ask questions covering all of it; likewise, there is no way that you can
  learn all this material starting now (I'm assuming that you've been learning
  it during the entire quarter).
<p>
Therefore, you should concentrate on reviewing the most important analysis and
  synthesis skills that we have studied.
Use the quizzes (and to a lesser extent the programming assignments and daily
  homework assignments) as a guide for what material is of primary importance.
Understand the material on its own terms, and how to use this material when
  writing code.
<p>
My written exams are not designed to determine if you understand obscure
   material; instead, they are designed to determine if you understand
  important material, and can use your knowledge to understand and answer
  questions <b>quickly</b>.
My exams are long (some students will not finish them): it you don't
  immediately know the answer to a question, skip it, and come back to it
  later, if you have time (sometimes working problems later in the exam will
  remind you of something relevant to the answer to earlier questions).
<p>
<b>Important:</b>Recall  that the final exam can also cover topics from the
   first half of the course.
   I would suggest reviewing the the earlier quizzes and midterm exam.
   Fundamentally, the second "half" of the quarter dealt with writing classes,
     using arrays, and using interfaces.
   Here is a <a href="writtenexam1.html">Topics from the first half
     of the class</a> link.
<p>


<h2>Outline of Lecture Topics</h2>


<ul>
<li>Static Methods<ul>
  <li>Definitions (including parameter/argument terminology)
  <li>The <b>return</b> statement
  <li>Hand simulation via call frames (primitive and reference variables)
  <li>Constant/final parameters
  </ul>

<li>Writing Static Methods in Classes<ul>
  <li>The main method
  <li>Writing methods in applications
  <li>Writing methods in libraries (like <b>SUM</b>)
  <li>Throwing exceptions with <b>String</b> arguments indicating the problem:
         e.g., <b>IllegalArgumentException</b>, <b>IllegalStateException</b>
  <li>Eclipse tools (editor/debugger) and their connection to <b>static</b>
        methods
  </ul>

<li>Writing Classes<ul>
  <li>Defining constructors, methods, fields
  <li>Name conflicts (between parameters/locals and instance variables) and
       the meaning and uses of <b>this</b>.
  <li>Writing constuctors (name conflicts, the special use of <b>this</b>)
  <li>Writing methods (illustrating <b>this</b>, the implicit parameter, in
        call frames) 
  <li>Defining fields: instance variables vs. static fields; initialization of
        both
  <li>Eclipse tools (editor/debugger) and their connection to methods/instance
         variables
  </ul>

<!---
<li>Model Classes<ul>
  <li>The MVC Pattern: How GUI Application Works
  <li>Simple Model Classes: how their methods are called; how they update the view
  </ul>
--->
<li>Array Classes<ul>
  <li>Declaring arrays and constructing array objects
  <li>Accessing arrays: members via subscripting (<b>[]</b>) and the
        <b>length</b> instance variable
  <li>Processing arrays: <b>for</b> loops and variants
  <li>How Strings are like arrays (e.g., <b>length</b> and <b>charAt</b>
        methods
  <li>Methods processing arrays; arrays as arguments/parameters to methods
  <li>Drawing array objects
  <li>Eclipse tools (debugger) and its connection to arrays
  </ul>

<li>Generalizing Collections: The <b>Object</b> class<ul>
  <li>The <b>Object</b> class
  <li>Wrapper classes and the <b>Object</b> class
  <li>Reference casting
  <li>The instanceof operator
  <li>An RPN Calculator using Stack
  <li>Priority Queues (from programming assignment #7)
  <li>Drawing complicated objects (whose instance variables are reference to
        other objects).
  </ul>

<li>Arrays in Classes<ul>
  <li>non-filled arrays: the <b>top</b>/<b>rear</b>/<b>used</b> instance
        variable; the  <b>doubleLength</b>/<b>trim</b>) methods
  <li>Processing non-filled arrays in methods: scanning, rearranging members
<!---
  <li>Interfaces: filters and iterators
  <li>Performance analysis of array length doubling
--->
  </ul>

<li>Implementing Collections via Arrays in Classes<ul>
  <li>Collections in general
  <li>Stacks and LIFO processing (RPN calculators)
  <li>Queues and FIFO processing
  </ul>

<li>Interfaces<ul>
  <li>Interfaces are types; how they are declared
  <li>How classes implement interfaces
  <li>Calling methods on variables whose types are interfaces
  <li>Simple uses: filters in prompting, functions to integrate (and later,
        priority queues)
  <li>Storing "interfaces" (really, objects constructed from classes
       implementing interfaces) in instance variables
  </ul>

<!---

<li>More on Classes<ul>
  <li>Many main methods
  <li>Interfaces for collection classes
  <li>Inner Classes: an introduction
  </ul>

<li>Inheritance<ul>
  <li>Hierarchies of Classes (subclasses via <b>extends</b>)
  <li><b>Object</b> class as tthe root of all class hierarchies
  <li>Inherited Fields: drawing objects, use of <b>protected</b> as an access modifier
  <li>Inherited Methods and Overriding Inherited Methods
  <li>The two uses of <b>super</b>: in constructors and methods in subclases
  <li>Reading JavaDoc Classes with Inheritance
  <li>Casting: Upcasting and Downcasting (and the <b>ClassCastException</b>)
  <li><b>instanceof</b>: its meaning in class hierarchies
  <li>Polymorphism: Variables Types (for compile time behvaior) and Object Classes (for runtime behavior)
  <li>Example: The <b>Secretary</b> Class Hierarchy
  <li>Example: The <b>Counter</b> interface and the <b>IntCounter</b> Class Hierarchy
  <li>Abstract Classes (the four big rules and the two uses of <b>super</b>: in constructors and methods)
  </ul>

<li>Inheritance and Exceptions<ul>
  <li>The Exception Class hierarchy (starting with <b>throwable</b>)
  <li>Generalizing exception catching via this class hierarchy
  <li>Checked vs. Unchecked Exceptions (implications in <b>try</b>/<b>catch</b> in methods)
  </ul>

<li>Analyzing Algorithms<ul>
  <li>Complexity Classes via Big O Notation
  <li>Asymptotic Analysis (when complexity classes are important)
  <li>Analyzing code to determine its complexity class
  <li>Using complexity classes and timings to predict running times
  <li>O(N) and O(Log<sub>2</sub>N) Searching in Arrays: linear and binary searching
  <li>O(N<sup>2</sup>) and O(N Log<sub>2</sub>N) Sorting for Arrays
  <li>Analyzing Classes: N insertions/deletions
  <li>Efficiency pragmatics: the rule of 90/10
  </ul>

<li>Recursion<ul>
  <li>General Form
  <li>Hand Simulation
  <li>Three Proof Rules (and their use in method synthesis)
  <li>Simple <b>int</b> and <b>String</b> examples
  </ul>
<p>

--->
<hr align="left" width="100%">
</body>
</html>
