<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
  <title>Program 1</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Program 1</h1>
<h1>
Programming using the ICS-46 Template Library<br>
Stack, Queue, Priority Queue, Set, and Map
</h1>
<p>
<h2>ICS-46: Data Structure Implementation and Analysis<br>
</h2>
<p>
</center>


<!-- Introduction -->

<a name="Introduction">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Introduction</b></td>
<td width ="80%">
This programming assignment is designed to ensure that you know how to use
  combinations of Python's most important data types to model and
  compactly write code that solves a wide variety of different programming 
  problems.
The kind of abstract thinking that goes into modeling solutions to these
  programming problems with these data types (and iteration over them) is
  critical to your development as computer scientists.
<p>
There are five parts to this assignment.
<!--- (and and extra credit part at the end). --->
In each you will be asked to write a module that contains a few functions
  and a script at the bottom, which ties these functions together to solve
  the problem.
<p>
You should download the 
  <a href="program1.zip">program1</a> project folder and use it to create an
  Eclipse project.
The project folder contains files for all the modules in which to write your
  functions and scripts; it also contains all the data files that you need to
  test/debug your modules; finally, it contains all the batch self-check files
  I will use when grading your programs.
In your modules, you may import additional standard/courselib modules and you
  may write additional helper functions.
<p>
I recommend that you work on this assignment in pairs, and I recommend that you
  work with someone in your lab section (so that you have 4 hours each week of
  scheduled time together).
These are just recommendations.
Try to find someone who lives near you, with similar programming skills,
  and work habits/schedule: e.g., talk about whether you prefer to work
  mornings, nights, or weekends; what kind of commitment you will make to submit
  program early.
<p>
<b>Only one student should submit all parts of the the assignment</b>, but both
  students' UCInetID and name should appear in a comment at the <b>top</b> of
  <b>each submitted .py file</b>.
A special grading program reads this information.
The format is a comment starting with <b>Submitter</b> and <b>Partner</b> (when
  working with a partner), followed by a <b>colon</b>, followed by the student's <b>UCInetID</b> (in all lower-case), followed by the student's <b>name in
  parentheses</b> (last name, comma, first name -capitalized appropriately).
If you omit this information, or do not follow this exact form, it will require
  extra work for us to grade your program, so we will deduct points.
<p>
For example if Romeo Montague (whose UCInetID is romeo1) submitted a program
  that he worked on with his partner Juliet Capulet (whose UCInetID is jcapulet)
  the comment at the top of each .py file would appear as:
<pre><b># Submitter: romeo1(Montague, Romeo)
# Partner  : jcapulet(Capulet, Juliet)
# We certify that we worked cooperatively on this programming
#   assignment, according to the rules for pair programming</b></pre>
If you do not know what the terms <b>cooperatively</b> and/or
  <b>rules for pair programming</b> mean, please read about
  <a href="../../../common/handouts/pairprogramming.html">Pair Programming</a> 
  <b>before</b> starting this assignment.
Please turn in each program <b>as you finish it</b>, so that I can more
  accurately assess the progress of the class as a whole during this assignment.
<p>
Print this document and carefully read it, marking any parts that contain
  important detailed information that you find (for review before you turn in
  the files).
The code you write should be as elegant and compact as possible, using 
  appropriate Python idioms.
You should familiarize yourselves with the <b>safe_open</b> function in the
  <b>goody</b> module and all the functions in the <b>prompt</b> module, both
  of which you should have installed in your <b>courselib</b> folder as part
  of the Eclipse/Python installation.
Recall how to use the <b>sep</b> and <b>end</b> parameters in the <b>print</b>
  function.
<p>
Reread the section on <b>Time Management</b> from Programming Assignment 0
  before starting this assignment.
<p>
<b>IMPORTANT 1</b>:
Before starting this assignment, download the
  <a href="xref.zip">xref</a> project folder which contains a small Python
  script <b>xref.py</b> that produces a cross-reference of all the words
  (converted to lower case) in a file (where words appear with spaces between
  them: see <b>xrefin.txt</b> for an example): the words are listed in
  alphabetic order followed by a set (i.e., no duplicates) of the line numbers
  it appears on (listed in increasing numeric order).
Before solving the problems in this programming assignment, ensure you
  understand all the details of how this program works: look at features and
  functions like <b>safe_open</b>, <b>defaultdict</b> (and how it is used),
  <b>enumerate</b>, <b>rstrip</b> and <b>lower</b>, <b>split</b> and
  <b>join</b>, <b>sorted</b>, <b>for</b> loops with two (unpacked) indexes, the
  two comprehensions (in the call to <b>max</b> and <b>join</b>), and
  <b>format</b>.
These are the building blocks for many parts of this assignment; explore
  and experiment with this code to understand how all the parts work together
  to achieve the desired result.
Run this code on more complicated data files.
<p>
<b>IMPORTANT 2</b>:
This assignment has 5 parts: pairs should work on each part together, not split
  them up and do them separately.
Parts 1-3 are going to be worth 12 points each; parts 4-5 are to be worth 7
  points each.
This skewing of points towards the simpler parts means students finishing the
  first 3 parts correctly will yield a 72% average; those finishing the first 4 
  parts correctly will have an 86% average; but to get an A on this  assignment
  requires solving all parts correctly.
I strongly recommend finishing the first part by the weekend, and then
  finishing another part every few days.
Waiting until the last few days and then trying to write all the solutions is
  a recipe for learning little and getting a poor grade (or worse, cheating
  and being caught).
Remember that I'm going to be running MOSS on all the parts of this assignment,
  checking for duplicate solutions.
<p>
<b>IMPORTANT 3</b>:
I will <b>mostly</b> grade all these programs automatically, using the batch
  self-check files provided in the download.
Use the <b>driver</b> program (explored in Programming Assignment #0) to run
  the batch-self check files in this assignment; debug any errors that they
  produce.
But the TAs (with some automated tools) will also look at/run the code in some
  of your scripts: so the scripts need to follow exactly what is shown in the
  <b>Sample Interactions</b> part for each problem.
I suggest testing your code first to match the scripts; when those results are
  correct, test it using the batch self-check files.
Finally, if a submitted Python module contains even one syntax error or bad
  import, it will <b>fail all</b> its batch self-checks; ensure that you
  <b>submit modules with no syntax or bad import errors</b> (Python sometimes
  adds strange imports at the top of your file; ensure that all your imports
  are reasonable).
</td>
</tbody>
</table>


<!-- Problem 1 -->

<a name="problem1">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #1: Reachability</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user for the name of a
    file representing a graph;
  reads the file (storing the graph in a dictionary);
  prints the graph/dictionary in a special form;
  repeatedly prompts the user for a starting node name (rejecting those that
    are not keys in the graph);
  computes and prints all the node names that are reachable from it by
    following zero or more edges in the graph (e.g., a node is reachable from
    itself).

<h3>Input and Output:</h3>
Read a file of pairs of node names (representing edges) in a directed
  graph, building a dictionary whose key is a <b>str</b> source node name and
  whose associated value is a <b>set</b> of <b>str</b> destination node names
  that are each reachable directly from the source node name key.
We annotate this dictionary as <b>{str:{str}}</b>.
<p>
In the file, two nodes names appear on each line: first the source node name,
  then the destination node name, with these node names (which may be entire
  words, not just single characters) separated by one semicolon character.
For example, the input file <b>graph1.txt</b> contains the following
  lines (which could appear in this order, or any other order):
<b><pre>  c;f
  b;d
  a;c
  c;e
  d;g
  a;b
  e;d
  f;g
  f;d</pre></b>
which represent the graph
<p>
<image src="images/graph.gif">
<p>
Print the graph, one source node name per line followed by the set of all the
  destination node names that the source can immediately reach.
The graph above would print as
<b><pre>  Graph: source node -> [destination nodes]
    a -> ['b', 'c']
    b -> ['d']
    c -> ['e', 'f']
    d -> ['g']
    e -> ['d']
    f -> ['d', 'g']</pre></b>
<p>
Note that the source node names are <b>sorted</b> alphabetically; the
  <b>set</b> of desintation node names associated with each source appear in a
  <b>list</b> whose values are also <b>sorted</b> alphabetically: it makes no
  sense to talk about sorted <b>sets</b>.
Note that because node <b>g</b> is not a source node (it is only a
  destination node), it does not appear first on any line (and appears only
  in the <b>sets</b> for source nodes <b>d</b> and <b>f</b>).
<p>
There are multiple data files for this program: <b>graph1.txt</b> (shown
  above), <b>graph2.txt</b> and <b>graph3.txt</b>; test/debug your program on
  the first file; when you are done, test it on the remaining files.
Draw the graph represented by each file to ensure that your code correctly
  prints it and computes the node names reachable from any source node (which
  you can do by eyeballing the graphs: they are small).
<p>
Repeatedly prompt the user for a starting node name in the graph (until the user
  enters <b>quit</b>) and compute and print all the node names that are
  reachable from it by following edges in the graph.
Reject any node name that is not a key in the graph.
An example interaction (processing the graph above) might be
<b><pre>  Enter some starting node name (else quit): <i>e</i>
  From e the reachable nodes are {'g', 'e', 'd'}

  Enter some starting node name (else quit): <i>x</i>
    Entry Error: 'x';  Illegal: not a source node
    Please enter a legal String

  Enter some starting node name (else quit): <i>a</i>
  From a the reachable nodes are {'g', 'f', 'e', 'd', 'c', 'b', 'a'}

  Enter some starting node name (else quit): <i>quit</i></pre></b>
<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_graph</b> has an open (file) parameter; it returns the dictionary
     representing the graph
     (body is 5 lines).
<p>
<li><b>graph_as_str</b> has a dictionary parameter (representing the graph); it
    returns a multi-line string (each line is ended by <b>'\n'</b>), which when
    printed shows the contents of the graph in the appropriate textual form
    (body is 4 lines; can you do it in 1?).
<p>
<li><b>reachable</b> has a dictionary parameter (representing the graph) and
    a <b>str</b> start node in the graph (technically a key in the dictionary);
    it returns a <b>set</b> of all the nodes reachable from it by following
    edges in the graph. Hint: I used the <b>get</b> dictionary function, which 
    allows a second argument that specifies what to do if the first argument
    (key) is not in the dictionary, because this function should not mutate
    the dictionary
    (body is 9 lines).
<p>
<li>Write a script at the bottom of this module
   (in <b>if __name__ == '__main__':</b>) that prompts the user for the
   file storing the graph and start node (rejecting any string that is not a
   source node in the graph or the word <b>quit</b>), calls these functions
   to solve the problem, and print the appropriate information: the graph
   and the set containing all the node labels
   (body is 9 lines).
</ul>
Here is the basic algorithm for computing reachability; it is simple to explain
  and not (very) complicated to implement.
But, you have to understand these instructions and carefully translate them into
  Python.
You should hand-simulate this algorithm using the graph above, and verify that
  it produces the results you expect, before coding the algorithm in Python.
You might be tempted to use recursion, but please don't: unless recursion is
  done very carefully, <b>reachable</b> will run forever on graphs that contain
  cycles: one of the input files is a graph that contains cycles.
<ol>
<li>To compute all the reachable nodes in a graph, create a <b>set</b>
   (initially empty) of reached nodes and a <b>list</b> (initially containing
   the  parameter start node) of nodes that we are going to explore (to find
   nodes they can reach).
<p>
<li>While the <b>exploring list</b> still has nodes, remove the first one
    (recall the <b>pop</b> method for <b>lists</b>) and put it into the
    <b>reached set</b>; for all its associated destination nodes that are not
    already in the <b>reached set</b>, put them in the <b>exploring list</b>.
<p>
<li>When the <b>exploring list</b> becomes empty (can you argue that this always
    will happen -there is no infinite looping), return the <b>reached set</b>.
</ol>
<p>
When debugging this algorithm, print the <b>reachable set</b> and
  <b>exploring list</b> after every interesting change, or use the debugger to
  observe these changes.
<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should "match" this one (sets will match if they have the same
  contents, independent of their order).
You should also check that it works for other starting nodes, and
  a variety of starting nodes in the other graphs.

<b><pre>  Enter some graph file name: <i>graph1.txt</i>

  Graph: source node -> [destination nodes]
    a -> ['b', 'c']
    b -> ['d']
    c -> ['e', 'f']
    d -> ['g']
    e -> ['d']
    f -> ['d', 'g']


  Enter some starting node name (else quit): <i>e</i>
  From e the reachable nodes are {'g', 'e', 'd'}

  Enter some starting node name (else quit): <i>x</i>
    Entry Error: 'x';  Illegal: not a source node
    Please enter a legal String

  Enter some starting node name (else quit): <i>a</i>
  From a the reachable nodes are {'g', 'f', 'e', 'd', 'c', 'b', 'a'}

  Enter some starting node name (else quit): quit</pre></b>
</td>
</tbody>
</table>


<!-- Problem #2 -->

<a name="problem6">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #2: Instant Runoff Voting</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user for the name of a
  file representing the preferences of a sequence of voters;
  reads the file (storing its information in a dictionary);
  prints the voter preferences/dictionary in a special form;
  repeatedly displays the vote count for ballots (sorted both by candidate name
  and by vote count), eliminating from the election the candidate(s) receiving
  the fewest votes, until one candidate (the winner) remains or no candidates
  remain (a tie among the candidates on the final ballot).
<p>
This form of election is known as <b>instant runoff voting</b>.
Every voter submits preferences that rank all the candidates in the election,
  from highest preference candidate (most favorite) to lowest preference
  candidate (least favorite): we will use a <b>list</b> for this purpose</b>,
  where "earlier in the <b>list</b>" means "higher preference".
All the candidates appear on the first ballot, so each voter votes for his
  highest preference candidate.
Then the candidate(s) with the fewest number of votes are removed from the
  election: if more than one candidate receives the least number of votes, all
  with that number are removed from the election.
<p>
During the second ballot, votes are allowed only for the
  <b>remaining candidates</b>: there is at least 1 fewer candidate.
If a  voter's highest preference candidate has been removed from the election,
  then his/her second ranked candidate should receive the vote; likewise, if
  his/her second ranked candidate has been removed from the election, then
  his/her third ranked candidate should receive the vote .... this process
  continues until a voter voters for his/her highest preference candidate who
  is still in the election.
<p>
The number of votes cast in each ballot should always be the same as the number
  of voters: each voter votes for his/her most preferred candidate <b>who is
  still in the election</b>.
This ballot process continues until either 1 candidate remains, or 0 candidates
  remain (meaning that all the remaining candidates tallied the same number
  of votes, and all were removed, so the election is a tie among them).
<p>
Read these instructions carefully, a few times.
Do some hand simulations to ensure you understand the algorithm.
Do not attempt to write any Python code to solve this problem until you
  understand this algorithm and can apply it to the data specified below.
You can discuss the algorithm with the class staff and each other; but, you
  cannot discuss your code with other students.

<h3>Input and Output:</h3>
Read a file of voters and their ranking of the candidates (highest to lowest
  preference), separated by semicolons, building a dictionary whose key is each
  voter and whose associated value is a <b>list</b> of candidates ranked by
  that voter (they appear in the file in order, from highest to lowest
  preference).
We annotate this dictionary as <b>{str:[str]}</b>.
<p>
In the file, the voter's name appears first, followed by the names of all the
  candidates in the election in highest to lowest preference (names may be
  entire words, not just single characters) separated by one semicolon
  character.
For example, the input file <b>votepref1.txt</b> contains the following
  lines (which could appear in this order, or any other):
<b><pre>  A;X;Y;Z
  B;Y;Z;X
  C;Y;Z;X
  D;Z;X;Y
  E;Z;X;Y</pre></b>
The first line means, voter <b>A</b> ranks candidate <b>X</b> first,
  candidate <b>Y</b> second, and candidate <b>Z</b> third.
The second line means, voter <b>B</b> ranks candidate <b>Y</b> first,
  candidate <b>Z</b> second, and candidate <b>X</b> third.
Each line will have a unique voter and a permutation of all the 
  candidates in the election.
<p>
Print each voter on a separate line, followed by his/her preferences.
That is, each line contains the voter and his/her complete ranking of the
  candidates.
For example, the file above would print as:
<b><pre>  Voter name -> [Preferences]
     A -> ['X', 'Y', 'Z']
     B -> ['Y', 'Z', 'X']
     C -> ['Y', 'Z', 'X']
     D -> ['Z', 'X', 'Y']
     E -> ['Z', 'X', 'Y']</pre></b>
<p>
Note that the voter names are <b>sorted</b> in alphabetical order;
  the <b>list</b> of preferences appears in the same order they appeared in the
  file.
There are multiple data files for this program: <b>votepref1.txt</b>, 
  <b>votepref2.txt</b>, <b>votepref3.txt</b> and <b>votepref4.txt</b>;
  test/debug your program on the first file; when you are done, test it on the
  remaining files.
<p>
<b>Algorithm:</b>
Start with a <b>set</b> of all the candidates.
Evaluate the ballot to determine how many votes each candidate received.
Print this vote count two ways: sorted by name in alphabetical order and
   sorted by votes in numerical order (in decreasing order).
Remove the candidate(s) receiving the fewest votes, and repeat this process
  until only one or no candidates remain.
Finally, print the outcome of the election: a single candidate winner or a tie.
An example interaction (processing the preferences above) might be
<b><pre>  Vote count on ballot #1: candidates (alphabetically ordered) with remaining candidate set = {'X', 'Y', 'Z'}
    X -> 1
    Y -> 2
    Z -> 2

  Vote count on ballot #1: candidates (numerically ordered) with remaining candidate set = {'Y', 'X', 'Z'}
    Y -> 2
    Z -> 2
    X -> 1

  Vote count on ballot #2: candidates (alphabetically ordered) with remaining candidate set = {'Y', 'Z'}
    Y -> 3
    Z -> 2

  Vote count on ballot #2: candidates (numerically ordered) with remaining candidate set = {'Y', 'Z'}
    Y -> 3
    Z -> 2

  Winner is  {'Y'}</pre></b>
The first ballot consisted of all three candidates, <b>X</b>, <b>Y</b>, 
  and <b>Z</b>.
For this ballot, the votes were counted and printed; candidate <b>X</b>
  received the fewest number of votes so he/she is eliminated from the next
  ballot.
The second ballot consisted of two candidates, <b>Y</b> and <b>Z</b>.
For this ballot: <b>A</b> votes for <b>Y</b>, who is his/her second highest
  preference because <b>X</b>, his first highest preference, was removed from
  the election; <b>B</b> through <b>E</b> vote for their highest preference
  candidate, who all remain in the election.
These votes are counted and printed; candidate <b>Z</b> received the fewest
  number of votes so is eliminated from the next ballot.
There is only one candidate remaining so <b>Y</b> is declared the winner.
An alternative outcome prints
<b>Not any unique winner: election is a tie among all the candidates remaining on the last ballot</b>.

<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_voter_preferences</b> has an open (file) parameter; it returns the
       dictionary representing each voter and his/her preferences
      (body is 5 lines).
<p>
<li><b>dict_as_str</b> has a dictionary, key <b>function</b>
      (default <b>None</b>) and <b>bool</b> (default <b>False</b>) as
       parameters; it returns a multi-line string (each line is ended by
       <b>'\n'</b>), which when, which when printed shows the contents of the
       dictionary in the appropriate textual form.
    The key function determines the ordering and the <b>bool</b> determines
      whether to reverse it: like the <b>key</b> and <b>reverse</b> parameters
      used for <b>sort</b>/<b>sorted</b> in Python.
    This function is used to print both the voter preference dictionary and
      the vote count dictionary for each ballot.
    <p>
    <b>Important:</b> The key function (and its use when iterating over the
      dictionary in <b>dict_as_str</b>) must assume that its argument is a
      <b>key</b> in the dictionary, not an <b>item</b>;
      otherwise the batch self-check test will fail even if your code works.
     (body is 4 lines; can you do it in 1?).
<p>
<li><b>evaluate_ballot</b> has a dictionary of voter preferences
         (see <b>read_voter_preferences</b>) and a <b>set</b> of the remaining
         candidates as parameters; it returns a dictionary whose keys are these
         candidates and whose values are the number of votes they received on
         this ballot, based on the description of the
         <b>instant runnoff voting</b> algorithm.
       Remember to count only one vote per voter, for his/her highest ranked
         candidate who is still in the election; hint: I used a <b>break</b>
         statement in one loop
       (body is 7 lines).
<p>
<li><b>remaining_candidates</b> has a dictionary as a parameter whose keys are
          candidates and whose values are the number of votes they received
          (see <b>evaluate_ballot</b>); it returns a set containing all those
          candidates remaining in the election (the one(s) receiving the
          fewest number of votes are absent).
       Note that if all the candidates receive the same number of votes, then
         this function returns an empty <b>set</b>.
       (body is 2 lines).
<p>
<li><b>run_election</b>  has an open (file) parameter; it returns a <b>set</b>
        that is empty (signifying no winner for this election) or contains one
        value (the winner of the election).
      In the process of computing its result to return, it calls the functions
        above and prints all the required information: see the
        <b>Sample Interaction</b> below
      (body is 13 lines).
<p>
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user for the
    file storing the voter preferences and calls <b>run_election</b> to
    do this task.
</ul>
<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<pre><b>  Enter some voter preferences file name: <i>votepref1.txt</i>

  Voter name -> [Preferences]
    A -> ['X', 'Y', 'Z']
    B -> ['Y', 'Z', 'X']
    C -> ['Y', 'Z', 'X']
    D -> ['Z', 'X', 'Y']
    E -> ['Z', 'X', 'Y']
  
  Vote count on ballot #1: candidates (alphabetically ordered) with remaining candidate set = {'Z', 'Y', 'X'}
    X -> 1
    Y -> 2
    Z -> 2

  Vote count on ballot #1: candidates (numerically ordered) with remaining candidate set = {'Y', 'X', 'Z'}
    Y -> 2
    Z -> 2
    X -> 1

  Vote count on ballot #2: candidates (alphabetically ordered) with remaining candidate set = {'Y', 'Z'}
    Y -> 3
    Z -> 2

  Vote count on ballot #2: candidates (numerically ordered) with remaining candidate set = {'Y', 'Z'}
    Y -> 3
    Z -> 2

  Winner is  {'Y'}</b></pre>
<p>
You can also try processing the <b>votepref2.txt</b> file (which leads to
  printing
  <b>Not any unique winner: election is a tie among all the candidates remaining on the last ballot</b> result),  <b>votepref3.txt</b>, and <b>votepref4.txt</b>.
</td>
</tbody>
</table>



<!-- Problem 3 -->

<a name="problem3">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #3: Finite Automata</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user for the name of a
   file representing a finite automaton: indicating its <b>states</b> and
       input-&gt;state <b>transitions</b>;
   reads the information in the file (storing the finite automaton in a
     dictionary);
   prints the finite-automaton/dictionary in a special form;
   prompts the user for the name of a file storing the start-state
      and inputs to process (each line in the file contains this combination);
   repeatedly processes these lines, computing the results of the finite
      automaton on each input, and then prints the results.
Note that a finite automaton is really a <b>program</b>; in this problem we are
  reading a program from a file and then executing it (running the finite
  automaton) on various inputs.
So, we are really writing a compiler/interpreter for a small programming
  language.
<p>
A <b>finite  automaton</b> (FA) is an machine that is sometimes called a
  Deterministic Finite Automaton (DFA; see the next problem for an NDFA: a
  non-deterministic finite automaton).
An FA is described by its <b>states</b> and its <b>transitions</b>:
  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what
  <b>state</b> in the FA that input leads to.
We can illustrate an FA as a graph with state labels in circles and edge labels
  for transitions (see below).
<p>

<h3>Input and Output:</h3>
Read a file that describes a FA: each line contains a state and an
  arbitrary number of input-&gt;state <b>transitions</b>.
Build a dictionary such that each key is a <b>str</b> state and whose associated
  value is another dictionary specifying all the transitions from that state:
  this second dictionary has keys that are <b>str</b> inputs and associated
  values are <b>str</b> states.
The first token on each line is the <b>str</b> state and the remaining tokens
  (always coming in pairs) are <b>str</b> inputs and their resulting states.
All tokens (which can comprise any number of characters) are separated by one
  semicolon character.
We annotate this dictionary as <b>{str:{str:str}}</b>.
<p>

For example, the input file <b>faparity.txt</b> contains the following lines
  (which could appear in this order, or any other and still specify the same
  FA):
<b><pre>  even;0;even;1;odd
  odd;0;odd;1;even</pre></b>
Here is a picture of the <b>parity</b> FA.
It graphically illustrates the two <b>states</b> (<b>even</b> and <b>odd</b>)
  and their <b>transitions</b>, using <b>inputs</b> (<b>0</b> and <b>1</b>)
  that always lead back to one of these two states.
<p>

<img src="images/parity.jpg"></img>
<p>

Here, the state <b>even</b> (meaning it has seen an even number of <b>1</b>
  inputs so far) is a key in the main dictionary.
It's value is a dictionary with two key/value pairs <b>0</b>-><b>even</b>
  and <b>1</b>-><b>odd</b>.
It means that in the <b>even</b> state, if the input is a <b>0</b> the
  FA stays in the <b>even</b> state; if the input is a <b>1</b> the
  FA goes to the <b>odd</b> state.
And similarly (the next line) means that for the <b>odd</b> state, if the input
  is a <b>0</b> the FA stays in the <b>odd</b> state; if the input is a
  <b>1</b> the FA goes back to the <b>even</b> state.
So, seeing an input of <b>0</b> keeps the FA in the same state;
  seeing an input of <b>1</b> flips the FA into the other state.
<p>

Print the finite automaton, one state (and its transitions) per line;
  the states are printed alphabetically and the transition dictionary
  for each state is printed as a <b>list</b> of input/state items (tuples)
  such that these are printed alphabetically by the inputs.
<p>
For example, the file above would print as:
<b><pre>  The Finite Automaton Description
    even transitions: [('0', 'even'), ('1', 'odd')]
    odd transitions: [('0', 'odd'), ('1', 'even')]</pre></b>
<p>
Note that there are multiple data files for this program: <b>faparity.txt</b>
  and <b>fadivisibleby3.txt</b>; test/debug your program on 
  the first file; when you are done, test it on the last file.
Draw the FA represented by each for to ensure that your code correctly
  prints and computes with it.
<b>Important:</b> This task is <b>not</b> to write a Python code that simulates
  the Parity FA; it is to write code that simulates <b>any</b> FA, whose
  description it reads from a file.
<p>
Next, repeatedly read and process lines from a second input file, computing the
  results of the finite automaton running on the specified start-state and its
  inputs; then print out the results in a special form.
Each line in the file contains a start-state followed by a sequence of inputs
  (all separated by semicolons).
The start-state will be a state in the FA (it is a key in the outer dictionary)
  the inputs may specify legal or illegal transitions (may or may not be keys
  in some inner dictonary).
<p>
For example, the input file <b>fainputparity.txt</b> contains the following
  three lines:
<b><pre>  even;1;0;1;1;0;1
  even;1;0;1;1;0;x
  odd;1;0;1;1;0;1</pre></b>
The first line means, the start-state is <b>even</b> and the
  inputs are <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.
<p>
The result of processing each line is to print the start-state, and then each
  input and the new state it transitions to, and finally print the stop-state.
For the <b>parity</b> FA and the first line in this file, it should print
<b><pre>Start state = even
  Input = 1; new state = odd
  Input = 0; new state = odd
  Input = 1; new state = even
  Input = 1; new state = odd
  Input = 0; new state = odd
  Input = 1; new state = even
Stop state = even</pre></b>
<p>
Note that the second line contains an input <b>x</b> which is not a legal input
  allowed in any state; any such input should stop the simulation for that line
  only, continuing to start a new simulation for all following lines (as
  illustrated in the <b>Sample Interaction</b>).
<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_fa</b> has an open (file) parameter; it returns the dictionary
     representing the finite automaton; <b>hint</b>: I used splicing and the
     <b>zip</b> function to build the inner dictionaries.
     (body is 6 lines).
<p>
<li><b>fa_as_str</b> has a dictionary parameter (representing the FA); it
    returns a multi-line string (each line is ended by <b>'\n'</b>), which when
    printed shows the contents of the FA in the appropriate textual form
    (body is 4 lines; can you do it in 1?).
<p>
<li><b>process</b> has a dictionary parameter (representing the FA),
    a <b>str</b> parameter (representing the start-state), and a <b>list</b>
    parameter (representing a <b>list</b> of <b>str</b> inputs); it returns a
    <b>list</b> that contains the start-state followed by <b>tuples</b> that
    show the input and resulting state after each transition.
    For the example shown above, <b>process</b> returns the following
    <b>list</b>.
<b><pre>['even', ('1', 'odd'), ('0', 'odd'), ('1', 'even'), ('1', 'odd'), ('0', 'odd'), ('1', 'even')]</pre></b>
    Finally, if an input is illegal (is not the key in some transition for the
    current state), say
    <b>'x'</b>, for the parity FA, then <b>process</b> should terminate with
    the last <b>tuple</b> in the <b>list</b> indicating a problem:
     <b>('x', None)</b>
   (body  is 9 lines).
<p>
<li><b>interpret</b> has a <b>list</b> parameter (the <b>list</b> result
    produced by  <b>process</b>); it returns a multi-line string (each line is
    ended by <b>'\n'</b>), which when printed illustrates the results of
    processing an FA on an input in the appropriate textual form.
    See how it prints the example <b>list</b> argument shown above in the
      output further above.
    Also see the <b>Sample Interaction</b> below to see how it prints
    <i>input errors</i>: see the middle example
   (body is 9 lines).
<p>
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user for the
    file describing the FA, prints it, prompts the user for the file containing
    lines of start-states and input, simulates the FA on each line, printing
    the results in the appropriate textual form
    (body is 7 lines).
</ul>
<p>

<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<b><pre>  Enter some finite automaton file name: <i>faparity.txt</i>

  The Finite Automaton Description
    even transitions: [('0', 'even'), ('1', 'odd')]
    odd transitions: [('0', 'odd'), ('1', 'even')]

  Enter some file name with start-state and inputs: <i>fainputparity.txt</i>
  
  Starting up a new simulation
  Start state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
  Stop state = even
  
  Starting up a new simulation
  Start state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = x; illegal input: simulation terminated
  Stop state = None

  Starting up a new simulation
  Start state = odd
    Input = 1; new state = even
    Input = 0; new state = even
    Input = 1; new state = odd
    Input = 1; new state = even
    Input = 0; new state = even
    Input = 1; new state = odd
  Stop state = odd</b></pre>
<p>
You can also try the <b>fadivisibleby3.txt</b> finite automaton file, which
  determines whether an integer (sequence of digits) is divisible by <b>3</b>:
   it is divisible if the  finite automaton stops in state <b>rem0</b>.
Its input file <b>fainputdivisibleby3.txt</b> tries the number
  <b>12,435,711</b>, which is divisible by <b>3</b> and number <b>823</b>,
  which is not divisible by <b>3</b>: dividing <b>823</b> by <b>3</b> leaves a
  remainder of <b>1</b>.
</td>
</tbody>
</table>


<!-- Problem 4 -->

<a name="problem4">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #4: Non-Deterministic FA</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that solve, for a Non-Deterministic
   Finite Automaton, the same problem that was solved for a Deterministic Finite
   Automaton in Problem #3 (above).
Read about the differences between these two automata (below).
Hint: Adapt your code for the FA problem to solve the more general NDFA problem.
<p>
A non-deterministic finite automaton (NDFA) is machine described by its
  <b>states</b> and its <b>transitions</b>:
  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and a
  <b>set</b> of <b>states</b> (more than one is allowed) that input can lead
  to: <b>sets</b> with <b>more than one states</b> is what makes it
  non-deterministic.
We can illustrate a NDFA as a graph with state labels in circles and edge
  labels for transitions (see below).
The critical difference between an FA and an NDFA is that an NDFA can have
  multiple edges with the same label going to different states (we'll see how
  to represent and simulate such transitions below).
<p>

<h3>Input and Output:</h3>
Read a file that describes a NDFA: each line contains a state and an
  arbitrary number of input-&gt;state <b>transitions</b>.
Build a dictionary such that each key is a <b>str</b> state and whose associated
   value is another dictionary specifying all the transitions from that state:
   this second dictionary has keys that are <b>str</b> inputs and associated
   values that are <b>sets</b> of <b>str</b> states: all the states a particular
   input can lead to.
The first token on each line is the <b>str</b> state and the remaining tokens
  (always coming in pairs) are <b>str</b> inputs and states.
All tokens (which can comprise any number of characters) are separated by one
  semicolon character.
We annotate this dictionary as <b>{str:{str:{str}}}</b>.
<p>

For example, the input file <b>ndfaendin01.txt</b> contains the following lines
  (which could appear in this order, or any other and still specify the same
  NDFA):
<b><pre>  start;0;start;1;start;0;near
  near;1;end
  end</pre></b>
Here is a picture of the <b>endin01</b> NDFA.
It graphically illustrates the three <b>states</b> (<b>start</b>, <b>near</b>,
  and <b>end</b>) and their <b>transitions</b>, using <b>inputs</b> (<b>0</b>
  and <b>1</b>).
<p>

<img src="images/endin01.jpg"></img>
<p>

Here, the state <b>start</b> is a key in the main dictionary.
It's value is a dictionary with two key/value pairs: <b>0</b> mapping to the
  <b>set</b> containing <b>start</b> and <b>near</b>, and <b>1</b> mapping to
  the <b>set</b> containing just <b>start</b>.
It means that in the <b>start</b> state, if the input is a <b>0</b> the
  NDFA can stay in the <b>start</b> state or it can go to the <b>near</b>
  state; if the input is a <b>1</b> the NDFA must stay in the <b>start</b>
  state.
And similarly the next line means that in the <b>near</b> state, if the
  input is a <b>1</b> the NDFA must go into the <b>end</b> state.
The last line means that the <b>end</b> state has no transitions out of it.
<p>

Print the NDFA, one state (and its transitions) per line;
  the states are printed alphabetically and the transition dictionary
  for each state is printed as a <b>list</b> of input/set of state items
  (tuples) such that these are printed alphabetically by the inputs.
Note that the state <b>end</b> is a key in the main dictionary, whose
  associated transitions are an empty dictionary.
<p>

For example, the file above would produce:
<b><pre>  The Non-Deterministic Finite Automaton Description
    end transitions: []
    near transitions: [('1', ['end'])]
    start transitions: [('0', ['near', 'start']), ('1', ['start'])]</pre></b>
<p>
Note that there are multiple data files for this program: <b>ndfaendin01.txt</b>
  and <b>ndfatrain.txt</b> and <b>ndfare.txt</b>;; test/debug your program on 
  the first file; when you are done, test it on the last file.
Draw the FA represented by each for to ensure that your code correctly
  prints and computes with it.
<p>
Next, repeatedly read and process lines from a second input file, computing the
  results of the non-determinisitc finite automaton on the specified
  start-state and its inputs ; then print out the results in a special form.
Each line in the file contains a start-state followed by a sequence of inputs
  (all separated by semicolons).
The start-state will be a state in the FA (it is a key in the outer dictionary)
  the inputs may specify legal or illegal transitions (may or may not be keys
  in some inner dictionary).
<p>
For example, the input file <b>ndfainputendin01.txt</b> contains the following
  two lines:
<b><pre>  start;1;0;1;1;0;1
  start;1;0;1;1;0;0</pre></b>
For example, the first line means, the start-state is <b>start</b> and the
  inputs <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.
<p>
The result of processing each line is to print the start-state, and then each
  input and the new states (plural) it could transition to (the <b>could</b>
  is what makes it non-deterministic), and finally print the stop-states.
For the <b>ndfaendin01</b> NDFA and the first line in this file, it should print
<b><pre>  Start state = start
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
  Stop state(s) = ['end', 'start']</pre></b>
<p>
Note that the <b>set</b> of states it might be in are printed as an alphabetized
  <b>list</b>.
Also note especially that in the <b>start</b> state, if the input is a <b>0</b>,
  then the NDFA can either remain in the <b>start</b> state or go into the
  <b>near</b> state.
For this program, we keep track of all states that the NDFA <b>can</b> be in,
  using a <b>set</b> of <b>new possible states</b>.
For the next input, <b>1</b>, we can be either in the <b>start</b> state
  (from the <b>start</b> state; an input of <b>1</b> allows us to stay in the
  <b>start</b> state) or the <b>end</b> state (from the <b>near</b> state; an
  input of <b>1</b> allows us to transition to the <b>end</b> state).
Thus, we keep track of the <b>set</b> of states the NDFA can be in, and the
  new <b>set</b> of states the NDFA can be in after processing the next input.
In this example, because <b>'end'</b> is included in the stop-states, this
  input does end in <b>01</b>.
<p>
For any state that does not have a transition specifying the current input,
  ignore that input for that state.
For example, if <b>near</b> is one of the possible states and <b>0</b> is the
  input, ignore the <b>0</b> for the <b>near</b> state.
<p>
<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_ndfa</b> has an open (file) parameter; it returns the dictionary
     representing the non-deterministic finite automaton; <b>hint</b>: I used
     splicing and the <b>zip</b> function to build the inner dinctionaries, and
     I called the <b>setdefault</b> function for the inner <b>dict</b>:
     alternatively I could have built it as <b>defaultdict</b>s from the
     standard  <b>collections</b> module
     (body is 9 lines).
<p>
<li><b>ndfa_as_str</b> has a dictionary parameter (representing the FA); it
    returns a multi-line string (each line is ended by <b>'\n'</b>), which when
    printed shows the contents of the NDFA in the appropriate textual form
    (body is 4 lines; can you do it in 1?).
<p>
<li><b>process</b> has a dictionary parameter (representing the NDFA),
    a <b>str</b> parameter (representing the start-state), and a <b>list</b>
    parameter (representing a <b>list</b> of <b>str</b> inputs); it returns a
    <b>list</b> that contains the start-state followed by <b>tuples</b> that
    show the input and resulting <b>set</b> of  states after each transition.
    For the example shown above, <b>process</b> returns the following
    <b>list</b>.
<p>
<b><pre>  ['start', ('1', {'start'}), ('0', {'near', 'start'}), ('1', {'end', 'start'}), ('1', {'start'}),
    ('0', {'near', 'start'}), ('0', {'near', 'start'})]</pre></b>
    Finally, remember that if an input is illegal for the current state (is not
      the key  in some transition for the current state), just ignore it.
    But if the input leads to no possible states (the empty set of states)
      terminate processing there
    (body is 12 lines).
<p>
<li><b>interpret</b> has a <b>list</b> parameter (the <b>list</b> result 
    produced by <b>process</b>);  it returns a multi-line string (each line is
    ended by <b>'\n'</b>), which when printed illustrates the results of
    processing an NDFA on an input in the appropriate textual form.
    Note that in this output the <b>sets</b> computed in <b>process</b> appear
      as <b>lists</b> sorted alphabetically by state.
    See how it prints the example <b>list</b> argument shown above in the
       <b>Sample Interaction</b> below
    (body is 5 lines).
<p>    
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user for the
    file describing the DNFA, prints it, prompts the user for the file
    containing lines of start-states and input, and simulates the NDFA on each 
    line, printing  the results in the appropriate textual form
    (body is 7 lines).
</ul>
<p>

<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should "match" this one.
<b><pre>  Enter some non-deterministic finite automaton file name: <i>ndfaendin01.txt</i>

  The Non-Deterministic Finite Automaton Description
    end transitions: []
    near transitions: [('1', ['end'])]
    start transitions: [('0', ['near', 'start']), ('1', ['start'])]

  Enter some file name with start-state and inputs: ndfainputendin01.txt

  Starting up a new simulation
  Start state = start
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
  Stop state(s) = ['end', 'start']
  
  Starting up a new simulation
  Start state = start
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 0; new possible states = ['near', 'start']
  Stop state(s) = ['near', 'start']</pre></b>
<p>
In Week #2 of this course we will cover EBNF and regular expressions, which
  relate to the files below.
You can run these files on your code to ensure they produce the correct results.
<p>
The <b>ndfatrain.txt</b> file is a non-deterministic finite automaton
  that determines whether or not a train (a sequence of characters representing
  different kinds of cars) is a legal train according to Chapter Exercise #7
  in the ENBF lecture.
Its input file is <b>ndfainputtrain.txt</b>, which starts with a legal train
  (one that ends with the state <b>done</b> as one possible state) followed by
  an illegal train (one that does not end with the state <b>done</b> as one
  possible state).
<p>
The <b>ndfare.txt</b> file is a non-deterministic finite automaton translation
  of the regular expression <b>((a*|b)cd)+</b>. 
Its input file is <b>ndfainputre.txt</b>, which starts with a match (one that
  ends with the state <b>last</b> as one possible state) followed by a non-match
   (one that does not end with the state <b>last</b> as one possible state).
</td>
</tbody>
</table>
  


<!-- Problem #5 -->

<a name="problem5">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #5: Google Queries</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user to enter the
  name of a file of text that contains a sequence of Google queries;
  reads the file (storing it in two special <b>prefix</b> and <b>query</b>
    dictionaries);
  repeatedly: prints the dictionaries in a special form; prompts the user to
    enter a query prefix, displays the top three queries with that prefix;
  prompts the user to enter a full query, and then updates the dictionaries
    as if this full query had appeared at the end of the file initially read.
<p>
<h3>Background:</h3>
When we type a word (or a few words) into Google's query box, it shows some of
  the most frequently entered queries starting with those word(s).
For example, when I recently typed the word <b>uci</b> into Google, it showed
  the following as the 3 most frequent queries starting with <b>uci</b>:
<ul>
<li><b>uci law</b>
<li><b>uci medical center</b>
<li><b>uci women's soccer</b>
</ul>
I could have clicked on one of these queries to select it, or continued typing
  more words to specify my own (different) query.
<p>
Here we say <b>uci</b> is a <b>prefix</b>, which is the beginning of some
  <b>full query</b>, like <b>uci medical center</b>.
<p>
Google represents a <b>full query</b> as a <b>tuple</b> of <b>str</b> (words).
For example, <b>('uci', 'medical', 'center')</b> is a <b>full query</b>.
Google also represents a <b>prefix</b> as a <b>tuple</b> of <b>str</b> (words).
For example, <b>('uci',)</b> is a one-word <b>prefix</b> and
  <b>('uci', 'medical')</b> is a two-word <b>prefix</b> of this
  <b>full query</b>.
<p>
From any <b>full query</b> we can compute a <b>set</b> of all its
  <b>prefix</b>es.
For example, the <b>full query</b> <b>('uci', 'medical', 'center')</b> would
  compute the <b>prefix set</b>
  <b>{('uci',), ('uci', 'medical'), ('uci', 'medical', 'center')}</b>.
The <b>prefix set</b> includes a <b>tuple</b> of the first word, 
  a <b>tuple</b> of the first two words, ...
  and finally a <b>tuple</b> of all the words in the <b>full query</b>.
<p>
Google stores information (in dictionaries) that allows it to predict the most
  likely <b>full query</b> from any <b>prefix</b> the user enters in the
  Google search box (as discussed in the example above).
The prediction is based on (1) knowing all the <b>full queries</b> for a
  <b>prefix</b> and (2) knowing how many times each <b>full query</b> was
  used.
Using this information, Google can show the user the most frequently
  entered <b>full queries</b> for the <b>prefix</b> he/she typed.
<p>
Google stores two dictionaries to accomplish this task.
Recall that dictionary keys and <b>set</b> values must be immutable types:
  <b>tuple</b>s are immutable (as are strings and integers) but not
  <b>list</b>s.
<ol>
<li>Google stores a <b>prefix</b> dictionary whose <b>key</b> is a
  <b>prefix</b> (a <b>tuple</b>) and whose <b>associated value</b> is a
  <b>set</b> of all the <b>full queries</b> that have been entered for that
  <b>prefix</b>.
<p>
<li>Google stores a <b>query</b> dictionary whose <b>key</b> is a
  <b>full query</b> (again a <b>tuple</b>) and whose <b>associated value</b>
  is an <b>int</b>: the number of times (the frequency) that that 
  <b>full query</b> was used.
</ol>
<b>IMPORTANT:</b>
Use a <b>defaultdict</b> to store both of these dictionaries.
<p>
In this program you will build these dictionaries and then use them it to
  predict a <b>full query</b> from a <b>prefix</b> entered by the user, and
  update the dictionaries for any new query.
<p>
<h3>Input and Output:</h3>
After prompting the user for the file of full queries, read the file, building
  the <b>prefix</b> and <b>query</b> dictionaries (we are dropping the word
  <b>full</b> now).
<p>
For a simple example, the file <b>googleq0.txt</b> contains the following
  lines (in it, for simplicity and conciseness, we abbreviated
  b = basketball, c = center, l = law, m = medical, s = soccer,  u = uci, and
  w = women's).
<b><pre>  u m c
  u l
  u w s
  u l
  u w s
  u w b
  u w b
  u w b</pre></b>
<p>
The program will first read this file and build the appropriate <b>prefix</b>
  and <b>query</b> dictionaries; then it will print each dictionary.
The <b>prefix</b> dictionary should be sorted by keys, from the shortest to
  longest prefix, with equal-length prefixes sorted in standard lexical order;
  of course the associated sets may print their values in any order.
The <b>query</b> dictionary should be sorted by associated values (integers),
  from largest to smallest integer, with equal integers sorted by their keys in
  standard lexical order.
<p>
For example, the file above would produce the following output:
<b><pre>  Prefix dictionary:
    ('u',) -> {('u', 'm', 'c'), ('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's')}
    ('u', 'l') -> {('u', 'l')}
    ('u', 'm') -> {('u', 'm', 'c')}
    ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
    ('u', 'm', 'c') -> {('u', 'm', 'c')}
    ('u', 'w', 'b') -> {('u', 'w', 'b')}
    ('u', 'w', 's') -> {('u', 'w', 's')}

  Query dictionary:
    ('u', 'w', 'b') -> 3
    ('u', 'l') -> 2
    ('u', 'w', 's') -> 2
    ('u', 'm', 'c') -> 1</pre></b>
<p>
In the <b>prefix</b> dictionary <b>('u',)</b> appears before <b>('u', 'l')</b>
  because it has fewer words; and <b>('u', 'l')</b> appears before
  <b>('u', 'w')</b> because in standard lexical order, when 2-tuples have equal
  first values, they are ordered by their second values, and <b>'l'</b> comes
  before <b>'w'</b>.
<p>
In the <b>query</b> dictionary <b>('u', 'w', 'b')</b> appears before
  <b>('u', 'l')</b> because the first tuple's associated value (<b>3</b>) is
  bigger than the second tuple's (<b>2</b>); and <b>('u', 'l')</b> appears
  before <b>('u', 'w', 's')</b> because when tuples are associated with equal
  values (<b>2</b>), they are ordered lexically, and <b>('u', 'l', ...)</b>
  comes before  <b>('u', 'w', ...)</b> (see the reasoning above).
<p>
Now, repeatedly prompt the user for any query prefix and print the top three
  full queries for the entered prefix: print them in order from most to least
  frequent full query (with ties printed using the standard lexical ordering;
  the same ordering used when printing the Query dictionary above).
Using the dictionaries above the iteraction would be.
<p>
<pre><b>  Enter some prefix (else quit): u
    Top 3 (maybe less) full queries: [('u', 'w', 'b'), ('u', 'l'), ('u', 'w', 's')]</b></pre>
Finally, prompt the user to enter the full query, and update the dictionaries
  and reprint them.
<pre><b>  Enter some full query (else quit): u w s

  Prefix dictionary:
    ('u',) -> {('u', 'm', 'c'), ('u', 'w', 'b'), ('u', 'l'), ('u', 'w', 's')}
    ('u', 'l') -> {('u', 'l')}
    ('u', 'm') -> {('u', 'm', 'c')}
    ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
    ('u', 'm', 'c') -> {('u', 'm', 'c')}
    ('u', 'w', 'b') -> {('u', 'w', 'b')}
    ('u', 'w', 's') -> {('u', 'w', 's')}

  Query dictionary:
    ('u', 'w', 'b') -> 3
    ('u', 'w', 's') -> 3
    ('u', 'l') -> 2
    ('u', 'm', 'c') -> 1</b></pre>
Here, the prefix dictionary stays the same (the full query already was entered
  once; we could have entered a new full query, which would augment the prefix
  dictionary), and the full query <b>('u', 'w', 's')</b> has its query-count
  increased from <b>2</b> to <b>3</b>.
<p>

<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>all_prefixes</b> has a <b>tuple</b> of <b>str</b>
         (words) parameter; it returns a <b>set</b> of <b>tuple</b> of
          <b>str</b>: all the <b>prefixes</b> of the <b>full query</b> argument.
       For example, <b>all_prefixes(('a', 'b', 'c'))</b> returns
         <b>{('a',), ('a', 'b'), ('a', 'b', 'c')}</b>.
       <b>Hints:</b> comprehension and slicing
       (body is 1 line).
<p>
<li><b>add_query</b> has a prefix dictionary, query dictionary, and full query
         (<b>tuple</b> of <b>str</b>) as parameters; it returns <b>None</b> but
         updates these two dictionaries based on the full query.
       It adds the new query's prefixes to the prefix dictionary (each
          associated with the full query) and increments the integer value
          associated with
          that full query in the query dictionary (or, if the full query is
           new, associates that query with 1)
       (body is 3 lines).
<p>
<li><b>read_queries</b> has an open (file) parameter; it returns a 2-tuple
     containing the prefix and query dictionaries (in that order) built by
     reading and processing each full query in this file.
    (body is 5 lines).
<p>
<li><b>dict_as_str</b> has a dictionary, key <b>function</b>
      (default <b>None</b>) and <b>bool</b> (default <b>False</b>) as
       parameters; it returns a multi-line string (each line is ended by
       <b>'\n'</b>), which when printed shows the contents of the dictionary in
       the appropriate textual form.
    The key function determines the ordering and the <b>bool</b> determines
      whether to reverse it: like the <b>key</b> and <b>reverse</b> parameters
      used for the <b>sort</b>/<b>sorted</b> functions in Python.
    This function is used to print both the prefix and query dictionaries.
    <p>
    <b>Important:</b> The key function (and its use when iterating over the
      dictionary in <b>dict_as_str</b>) must assume that its argument is a
      <b>key</b> in the dictionary, not an <b>item</b>;
      otherwise the batch self-check test will fail even if your code works.
     (body is 4 lines; can you do it in 1?).
<p>
<li><b>top_n</b> has a prefix (<b>tuple</b> of <b>str</b>), <b>int</b>, prefix
        dictionary, and query dictionary as parameters; it returns a <b>list</b>
        of full queries (<b>tuple</b> of <b>str</b>) whose length is the
        integer parameter, containing the most frequent full queries with that
         prefix; if the number of full queries with that prefix is less than
         that integer parameter, return all the full queries.
    If no full queries have this prefix, return the empty list.
    Notes: The dictionaries should not be changed.
           If multiple full queries occur the same number of times, prefer
      the full queries that come earlier in the standard lexical ordering: e.g.,
      the same order they are printed in the query dictionary.
      (body is 3 lines; can you do it in 1?).
<p>     
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user for the file
    storing the queries and builds the prefix and query dictionaries from this
    file; then repeated: print these dictionaries; prompt the user for a prefix;
    display the top three full queries with that prefix; prompt the user for
    a full query; and finally update the prefix and query dictionaries with that
    full query
   (13 lines).
</ul>
<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match the form of this one (the order of values in the sets
  may vary).
<pre><b>Enter some full query file: <i>googleq0.txt</i>

Prefix dictionary:
  ('u',) -> {('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's'), ('u', 'm', 'c')}
  ('u', 'l') -> {('u', 'l')}
  ('u', 'm') -> {('u', 'm', 'c')}
  ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
  ('u', 'm', 'c') -> {('u', 'm', 'c')}
  ('u', 'w', 'b') -> {('u', 'w', 'b')}
  ('u', 'w', 's') -> {('u', 'w', 's')}

Query dictionary:
  ('u', 'w', 'b') -> 3
  ('u', 'l') -> 2
  ('u', 'w', 's') -> 2
  ('u', 'm', 'c') -> 1

Enter some prefix (else quit): <i>u</i>
  Top 3 (maybe less) full queries: [('u', 'w', 'b'), ('u', 'l'), ('u', 'w', 's')]

Enter some full query (else quit): <i>u w s</i>

Prefix dictionary:
  ('u',) -> {('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's'), ('u', 'm', 'c')}
  ('u', 'l') -> {('u', 'l')}
  ('u', 'm') -> {('u', 'm', 'c')}
  ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
  ('u', 'm', 'c') -> {('u', 'm', 'c')}
  ('u', 'w', 'b') -> {('u', 'w', 'b')}
  ('u', 'w', 's') -> {('u', 'w', 's')}

Query dictionary:
  ('u', 'w', 'b') -> 3
  ('u', 'w', 's') -> 3
  ('u', 'l') -> 2
  ('u', 'm', 'c') -> 1

Enter some prefix (else quit): <i>u w</i>
  Top 3 (maybe less) full queries: [('u', 'w', 'b'), ('u', 'w', 's')]

Enter some full query (else quit): <i>a b c</i>

Prefix dictionary:
  ('a',) -> {('a', 'b', 'c')}
  ('u',) -> {('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's'), ('u', 'm', 'c')}
  ('a', 'b') -> {('a', 'b', 'c')}
  ('u', 'l') -> {('u', 'l')}
  ('u', 'm') -> {('u', 'm', 'c')}
  ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
  ('a', 'b', 'c') -> {('a', 'b', 'c')}
  ('u', 'm', 'c') -> {('u', 'm', 'c')}
  ('u', 'w', 'b') -> {('u', 'w', 'b')}
  ('u', 'w', 's') -> {('u', 'w', 's')}

Query dictionary:
  ('u', 'w', 'b') -> 3
  ('u', 'w', 's') -> 3
  ('u', 'l') -> 2
  ('a', 'b', 'c') -> 1
  ('u', 'm', 'c') -> 1

Enter some prefix (else quit): <i>quit</i></b></pre>
<p>
You can also try processing the <b>googleq1.txt</b> and <b>googleq2.txt</b>
  files
</td>
</tbody>
</table>



<!-- OLD Problem #5

<a name="problem5">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #5: Word Generator</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user to enter the
    <b>order statistic</b> (a positive number) and the name of a file of text;
  reads the file of text (storing it in a special <b>corpus</b> dictionary);
  prints the dictionary in a special form;
  prompts the user to enter the <b>order statistic</b> number of words, and the
    number of words to generate, then print a <b>list</b> of that many words
    randomly generated from the corpus.
</ul>
Your program will "learn" the word pattern of an author (based on some
  "order statistic" and reading a large sample of the author's writing) and
  then generate random text following the author's word patterns.
<p>
<h3>Input and Output:</h3>
After prompting for the <b>order statistic</b>, read a file of words, building a
  corpus dictionary storing data annotated as <b>{(str):[str]}</b>.
Here the dictionary's keys are <b>tuple</b>s of <b>n</b> words (where <b>n</b>
  is the <b>order statistic</b>) and each key's assocaited value is a
  <b>list</b> of all the words in the text that somewhere follow these words:
  e.g., if <b>n</b> were <b>2</b>, the dictionary would contain a key for every
  pair of words appearing next to each other in the text, and each would have
  an associated value that is a <b>list</b> of all the words following these two
  (no matter where the pair occurs, with NO DUPLICATES allowed in the values
  <b>list</b>).
<p>
An easy way to read the words one at a time is to use the result returned by
  the function <b>goody.read_file_values</b>, which is
  passed an <b>open</b> file to read from: we can (a) call <b>next</b> on the
  result or (b) iterate over the result with a <b>for</b> loop.
For example, if a file named <b>f.txt</b> contained
<b><pre>  a b c d e</pre></b>
then the code
<b><pre>  i = goody.read_file_values(open('f.txt'))
  print(next(i), next(i))  # print next two values in the file
  for c in i:              # iterate over all remaining values in the file
      print(c)</pre></b>   #   and print them
would print
<b><pre>  a b
  c
  d
  e</pre></b>
<p>
We will learn when we examine iterators in depth that the <b>for</b> loop
  implicitly calls <b>next</b> on the object (here <b>i</b>) that it is
  iterating over.
<p>
We can build the dictionary by "prereading" <b>n</b> words (by calling
  <b>next</b> explicitly) into a <b>list</b> (assume that this is always
  possible;
  how might it not be?); then repeatedly read the next word and put it in as a
  value associated with the <b>list</b> of pre-read words; then, drop the
  "oldest" word at the beginning of the <b>list</b>, and add this next word
  as the "youngest" at the end of the <b>list</b> (always keeping the list
  length at <b>n</b>); repeating this process until all the words have been
  read.
Remember to convert this <b>list</b> of words to a <b>tuple</b> of words,
  before using it as a key in the dictionary.
<p>
For a simple example, the file <b>wginput1.txt</b> contains the following
  lines (it could have all this information on one line or more lines):
<b><pre>  a b c b a d c b a d
  c a a b a a d</pre></b>
  
<p>
Print all the associations in the corpus dictionary, one per line in standard
  lexical order; after printing all associations, print the length of the
  smallest and largest <b>list</b> that is a value in the dictionary.
Each line contains an <b>n</b> word <b>tuple</b>, followed by the <b>list</b>
   of unique words (no duplicates) that follow them anywhere in the text.
In standard lexical order, the keys appear in order relative to the first word 
  in the <b>tuple</b>; for all first words that are the same, they appear in
  order relative to the second word in the <b>tuple</b>; for all first and
  second words that are the same, they appear in order relative to the thrid
  word in the <b>tuple</b>; etc. (see the example below).
<p>
For example, the file above would produce:
<b><pre>  Corpus
    ('a', 'a') can be followed by any of ['b', 'd']
    ('a', 'b') can be followed by any of ['c', 'a']
    ('a', 'd') can be followed by any of ['c']
    ('b', 'a') can be followed by any of ['d', 'a']
    ('b', 'c') can be followed by any of ['b']
    ('c', 'a') can be followed by any of ['a']
    ('c', 'b') can be followed by any of ['a']
    ('d', 'c') can be followed by any of ['b', 'a']
  min/max value lengths = 1/2</pre></b>
<p>
For example, <b>('a','d')</b> appears three times in the text above, twice
  followed by <b>'c'</b> and once followed by nothing (at the end of the file);
  <b>('a','b')</b> appears twice in the file above, first followed by
  <b>'c'</b> and second followed by <b>'a'</b>.
<p>

Prompt the user for the words to start with (there are <b>order statistic</b>
  number of them) and the number of random words after that to generate.
Produce such a <b>list</b> of words and print it. 
<p>
A random 10 word <b>list</b>, after the words <b>a</b> and <b>d</b> might
  print as
<pre><b>    Random text = ['a', 'd', 'c', 'a', 'a', 'd', 'c', 'a', 'a', 'd', 'c', 'b']</b></pre>
In the result we start with <b>a d</b> (2 words specified by the user), we
  know only <b>c</b> can come next; then using <b>d c</b> we know that
  either <b>b</b> or <b>a</b> must come next; it randomly chooses <b>a</b>...
<p>

<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_corpus</b> has an <b>order statistic</b> (<b>int</b>) parameter and
     and open (file) parameter; it returns the dictionary representing the
     corpus of words in a file
    (body is 8 lines).
<p>
<li><b>corpus_as_str</b> has a dictionary parameter (representing the corpus);
     it returns a multi-line string (each line is ended by <b>'\n'</b>), which
     when printed shows the contents of the corpus followed by the min/max
     <b>list</b> lengths in the appropriate textual form
     (body is 7 lines; can you do it in 4?).
<p>
<li><b>produce_text</b> has a dictionary parameter (representing the corpus),
    a <b>list</b> parameter (representing the starting words), and an <b>int</b>
    parameter (representing the number of additional words to generate);
    it returns a <b>list</b> that contains the the starting words followed by
    the generated words.
    <p>
    <b>Hints</b>: Let <b>n</b> be the <b>order statistic</b> of the dictionary.
    Construct two <b>lists</b> (<b>[str]</b>), each initially storing these same
      <b>n</b> starting words.
    The first will always contain only the most recent <b>n</b> words (to be
      coverted to a <b>tuple</b> and used as a key in the dictionary); the 
      second will  grow to contain all the generated words.
    Generate a random next word from the dictionary by using the <b>choice</b>
      function in the <b>random</b> module: e.g., <b>choice(['a','b','c'])</b>
      will return a random value in the <b>list</b>, either <b>'a'</b>,
      <b>'b'</b>, or <b>'b'</b>); add it to both <b>lists</b>; then, drop the
      first word from the first <b>list</b>, so it remains a <b>list</b> of
      length <b>n</b>; repeat until you have generated the required number of
      words.
    <p>
    <b>Warning</b>: you might have to stop prematurely if you generate the last
      <b>n</b> words in the text, and if these words occur nowhere else.
    That is because in this case, there is no random word to generate following
      them; in this case append a <b>None</b> to the end of the list of words
      and  immediately return that list.
    <p>
    A slightly more elegant solution in Python uses only one list, copying the
      last <b>order statistic</b> values of it into a tuple when needed for a
      key to the dictionary.
    Ensure that you do not mutate any of the parameters
      (body is 8 lines).
<p>     
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user for (a) the
    <b>order statistic</b> (rejecting non-positive values), (b) the file storing
    the text, (c) <b>order statistic</b> words from the text, and (d) the
    number of random words to generate (reject any negative values); it
    calls these functions to solve the problem, and print the appropriate
    information
   (7 lines).
</ul>
<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match the form of this one (the actual random text my vary).
<pre><b>  Enter order statistic: <i>2</i>
  Enter file to process: <i>wginput1.txt</i>
  Corpus
    ('a', 'a') can be followed by any of ['b', 'd']
    ('a', 'b') can be followed by any of ['c', 'a']
    ('a', 'd') can be followed by any of ['c']
    ('b', 'a') can be followed by any of ['d', 'a']
    ('b', 'c') can be followed by any of ['b']
    ('c', 'a') can be followed by any of ['a']
    ('c', 'b') can be followed by any of ['a']
    ('d', 'c') can be followed by any of ['b', 'a']
  min/max value lengths = 1/2
  
  Enter 2 words to start with
  Enter word 1: <i>a</i>
  Enter word 2: <i>d</i>
  Enter # of words to generate: <i>10</i>
  Random text = ['a', 'd', 'c', 'a', 'a', 'd', 'c', 'a', 'a', 'd', 'c', 'b']</b></pre>
<p>
You can also try reading a much larger file included in this project
  folder <b>wghuck.txt</b>, Mark Twain's, "The Adventures of Huckleberry Finn".
I tried it with an order statistic of 3.
The corpus has over 90,000 entries; the biggest key triple had an
associated value with 46 unique words in it.
The key was <b>('out', 'of', 'the')</b> and its associated value was the list
<pre><b>  ['window', 'face', 'woods', 'fourth', 'front', 'jacket', 'hole', 'canoe', 'middle',
   "ferryboat's", 'cottonwood', "captain's", 'river', 'fog', 'range', 'presbyterian', 'tree',
   'nest', 'wagon-troughs', 'reach', 'store', 'way', 'wigwam', 'ark', 'room', 'corner', 'grave',
   'nonesuch', 'trouble', 'kitchen', 'old', 'first', 'hardest', 'nigger-patch', 'sugar-bowl',
   'window-hole', 'brass', 'spoon', 'house', 'tooleries', 'bag', 'office', 'post-office', 'cabin',
   'path', 'chains']</b></pre>
<p>
With the appropriate modification, we can use this same program to
  read/generate music or DNA sequences or any other data made of symbols.
</td>
</tbody>
</table>

-->

<!-- Extra Credit

<a name="problem5">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Extra Credit</b></td>
<td width ="80%">
Write up all three answers in the file <b>extracredit.txt</b> and drop them off
  on checkmate.
<ol>
<li>Specify a fa that is equivalent to the ndfa that finds inputs that end
      in <b>01</b>.
    It must identify some state that is stopped in only for input ending in 01
    (the <b>end</b> state in the ndfa).
<li>What is interesting about the results of the election using the
      <b>votepref3.txt</b> input file?
    How could we add another voter, such that his/her preferences allow X to
      win on the first ballot?
<li>In the word generator program we used a <b>dict</b> value that was a
      <b>list</b> of words that was to contain no duplicates?
    Why can't we just use a <b>set</b> (what would break in our code)?
    If we wanted to use a set how could we modify the code to work correctly
      (what is the smallest and/or fastest modification)?
</td>
</tbody>
</table>
--->
</html>
