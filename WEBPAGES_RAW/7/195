<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
  <title>Tokens in Java Programs</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Tokens and Java Programs</h1>
<p>
<h2>Introduction to Computer Science I-III
<br>
ICS-21/-22/-23
<br>
</h2>
<p>
</center>


<!-- Introduction -->

<a name="Introduction"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Introduction</b></td>
<td width ="80%">
  In this lecture we will learn about the lowest level of the Java language:
    its tokens.
  We will learn how to recognize and classify every category of token 
    (which is like classifying English words into their parts of speech).
  Towards this end, we will employ ourly new learned EBNF skilss to write and
    analyze descriptions for each category of token.
  In later lectures we will learn about a programming language's higher level
    structures: phrases (expressions), sentences (statements),
    paragraphs (blocks/methods), chapters (classes), and books (packages).
</td>
</tbody>
</table>


<!-- Historical Context -->

<a name="Historical">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The Family History of Java</b></td>
<td width ="80%">
  Before going on to study Java, let's take a brief look, through quotes,
    at the languages on which Java was based, traveling back over 30 years
    to do so.
</td>
</tbody>
</table>


<a name="C">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Where it starts: C <b></td>
<td width ="80%">
  The earliest precursor of Java is C: a language developed  by Ken Thompson
    at Bell Labs in the early 1970s.
  C was used as a system programming language for the DEC PDP-7.
  C began achieving its widespread popularity when Bell's Unix operating 
     system was  rewritten in C.
  Unix was the first operating system written in a high-level language;
    it was distributed to universities for free, where it became popular.
  Linux is currently a popular (it is still free!) variant of Unix.
  <p>
  "C is a general-purpose programming language which features economy of
     expression, modern control flow and data structures, and a rich set of
     operators.
   C is not a "very high level" language, nor a "big" one, and is not
     specialized to any particular area of application."
  <br>
  <div align="right">- B. Kernighan/D. Ritchie: The C Programming Language<br>
    (Kernighan & Ritchie designed and implemented C)
  </div>
</td>
</tbody>
</table>


<!-- Philosophical Context -->

<a name="Philosophy">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>From C to C++</b></td>
<td width ="80%">
  "A programming language serves two related purposes: it provides a vehicle
     for the programmer to specify actions to be executed, and it provides a
     set of concepts for the programmer to use when thinking about what can
     be done.
   The first aspect ideally requires a language that is "close to the
      machine," so that all important aspects of a machine are handled simply
      and efficiently in a way that is reasonably obvious to the programmer.
   The C language was primarily designed with this in mind.
   The second aspect ideally requires a language that is "close to the
     problem to be solved" so that the concepts of a solution can be expressed
    directly and concisely.
   The facilities added to C to create C++ were primarily designed with this
     in mind"
  <div align="right">
    - B. Stroustrup: The C++ Programming Language (2nd Ed)<br>
    (Stroustrup designed and implemented C++)
  </div>
</td>
</tbody>
</table>


<!-- Java -->

<a name="NewJava">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Java as a Successor to C++</b></td>
<td width ="80%">
  "The Java programming language is a general-purpose, concurrent, class-based,
    object-oriented language.
   It is designed to be simple enough that many programmer can achieve fluency
      in the language.
   The Java programming language is related to C and C++ but it is organized 
     rather differently, with a number of aspects of C and C++ omitted and a
      few ideas from other languages included.
   It is intended to be a production language, not a research language, and
     so, as C.A.R. Hoare suggested in his classic paper on language design,
     the design has avoided including new and untested features.
   <br>
   ...
   <br>
   The Java programming language is a relatively high-level language, in that
     details of the machine representation are not available through the
     language.
   It includes automatic storage management, typically using a garbage
     collector, to avoid the safety problems of explicit deallocation (as in
     C's <b>free</b> or C++'s  <b>delete</b>).
   High-performance garbage-collected implementations can have bounded pauses
     to support systems programming and real-time applications.
   The language does not include any unsafe constructs, such as array accesses
     without index checking, since such unsafe constructs would cause a
     program to behave in an unspecified way."
   <div align="right">
    - J. Gosling, B. Joy, G. Steele, G. Bracha: The Java Language Specification
  </div>
</td>
</tbody>
</table>


<!-- Tokens -->

<a name="Tokens">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Overview of Tokens in Java: The Big 6</b></td>
<td width ="80%">
  In a Java program, all characters are grouped into symbols called
    <b>tokens</b>.
  Larger language features are built from the first five categories of tokens
   (the sixth kind of token is recognized, but is then discarded by the Java
   compiler from further processing).
  We must learn how to identify all six kind of tokens that can appear in
    Java programs.
  In EBNF we write one simple rule that captures this structure:
  <p>
  <i>token</i> <= <i>identifier</i> | <i>keyword</i> | <i>separator</i> | <i>operator</i> | <i>literal</i> | <i>comment</i> 
  <p> 
  We will examine each of these kinds of tokens in more detail below, again
    using EBNF.
  For now, we briefly describe in English each token type.
  <p>
  <ol>
    <li>Identifiers: names the programmer chooses
    <li>Keywords: names already in the programming language
    <li>Separators (also known as punctuators): punctuation characters and
          paired-delimiters 
    <li>Operators: symbols that operate on arguments and produce results
    <li>Literals (specified by their <b>type</b>)
      <ul>
        <li>Numeric: <b>int</b> and <b>double</b>
        <li>Logical: <b>boolean</b>
        <li>Textual: <b>char</b> and <b>String</b>
        <li>Reference: <b>null</b>
      </ul>
    <li>Comments
      <ul><li>Line<li>Block</ul>
  </ol>
  Finally, we will also examine the concept of <b>white space</b> which is
    crucial to understanding how the Java compiler separates the characters
     in a program into a list of tokens; it sometimes helps decide where one
     token ends and where the next token starts.
</td>
</tbody>
</table>


<!-- Characters -->

<a name="Characters"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The Java Character Set</b></td>
<td width ="80%">
  The full Java character set includes all the 
    <a href="http://www.unicode.org" target="_blank">Unicode</a>
    characters; there are 2<sup>16</sup> = 65,536 unicode characters.
  Since this character set is very large and its structure very complex, in
   this class  we will use only the subset of unicode that includes all the
   <b>ASCII</b> (pronounced "Ask E") characters; there are 2<sup>8</sup> = 256
   ASCII characters, of which we will still use a small subset containing
   alphabetic, numeric, and some special characters.
<p>
  We can describe the structure of this character set quite simply in EBNF,
   using only alternatives in the right hand sides.
  <p>
  <i>lower-case</i> <= a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z<br>
  <i>upper-case</i> <= A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z<br> 
  <i>alphabetic</i> <= <i>lower-case</i> | <i>upper-case</i><br> 
  <i>numeric</i> &nbsp &nbsp <= 0|1|2|3|4|5|6|7|8|9<br> 
  <i>alphanumeric</i> <= <i>alphabetic</i> | <i>numeric</i><br> 
  <i>special</i> &nbsp &nbsp &nbsp <= !|%|^|&|*|(|)|-|+|=|{|}|||~|[|]|\|;|'|:|"|<|>|?|,|.|/|#|@|`|_<br>
  <i>graphic</i> &nbsp &nbsp <= <i>alphanumeric</i> | <i>special</i>
  <p>
  In the <i>special</i> rule, the bracket/brace characters stand for themselves
    (not EBNF options nor repetitions) and one instance of the vertical bar 
    stands for itself too: this is the problem one has when the character set
    of the language includes special characters that also have meanings in
    EBNF.
  <p>
  White space consists of spaces (from the space bar), horizontal and vertical
    tabs, line terminators (newlines and formfeeds): all are non-printing
    characters, so we must describe them in English.
  White space and tokens are closely related: we can use white space to force
    the end of one token and the start of another token (i.e., white space is
    used to separate tokens).
  For example <b>XY</b> is considered to be a single token, while <b>X Y</b>
    is considered to be two tokens.
  The "white space separates tokens" rule is inoperative inside
     <b>String</b>/<b>char</b> literals, and comments (which are all discussed
     later).
  <p>
  Adding extra white space (e.g., blank lines, spaces in a line -often for
    indenting) to a program changes its appearance but not its meaning to Java:
    it still comprises exactly the same tokens in the same order.
  Programmers mostly use white space for purely stylistic purposes: to
    isolate/emphasize parts of programs and to make them easier to read and
    understand.
  Just as a good comedian know where to pause when telling a joke; a good
    programmer knows where to put white space when writing code. 
</td>
</tbody>
</table>


<!-- Identifiers -->

<a name="Identifiers"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Identifiers</b></td>
<td width ="80%">
  The first category of token is an <b>Identifier</b>.
  Identifiers are used by programmers to name things in Java: things such as
    variables, methods, fields, classes, interfaces, exceptions, packages, etc.
  The rules for recognizing/forming legal identifiers can be easily stated in
    EBNF.
  <p>
  <i>id-start</i> &nbsp &nbsp<= <i>alphabetic</i> | $ | _<br> 
  <i>identifier</i> <= <i>id-start</i>{<i>id-start</i> | <i>numeric</i> }<br> 
  <p>
  Although identifiers can start with and contain the <b>$</b> character,
    we should never include a <b>$</b> in identifiers that we write;
    such identifiers are reserved for use by the compiler, when it needs to
    name a special symbol that will not conflict with the names we write.
  <p>
  Semantically, all characters in an identifier are significant, including the
    case (upper/lower) of the alphabetic characters.
  For example, the identifier <b>Count</b> and <b>count</b> denote different
    names in Java; likewise, the identifier <b>R2D2</b> and <b>R2_D2</b>
    denote different names.
  <p>
  When you read programs that I have written, and write your own program,
    think carefully about the choices made to create identifiers.
  <ul>
    <li>Choose descriptive identifiers (mostly starting with lower-case
          letters).
    <li>Separate different words in an identfier with a case change:
          e.g., <b>idCount</b>; this is called "camel style", with each
          capital letter representing a hump.
    <li>Apply the "Goldilocks Principle": not too short, not too long, just
          right.
   </ul>
  During our later discussions of programming style, we will examine the
    standard naming conventions that are recommend for use in Java code.
<p>
  Carefully avoid identifiers that contain dollar signs; avoid
   <ul>
     <li>homophones (sound alike): <b>aToDConvertor</b> &nbsp <b>a2DConvertor</b>
     <li>homoglyphs (look alike): <b>allOs</b> vs. <b>all0s</b> and
          <b>Allls</b> vs <b>All1s</b> 
       <ul>which contain the letter (capital) O, number 0, letter (small) l,
             letter (capital) I, and number 1</ul>
     <li>mirrors: <b>xCount</b> &nbsp <b>countX</b>
   </ul>
</td>
</tbody>
</table>


<!-- Keywords -->

<a name="Keywords"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Keywords</b></td>
<td width ="80%">
  The second category of token is a <b>Keyword</b>, sometimes called a
    reserved word.
  Keywords are identifiers that Java reserves for its own use.
  These identifiers have built-in meanings that cannot change.
  Thus, programmers cannot use these identifiers for anything other than their
    built-in meanings.
  Technically, Java classifies identifiers and keywords as separate categories
    of tokens.
  <p>
  The following is a list of all 49 Java keywords we will learn the meaning
    of many, but not all,of them in this course.
  It would be an excellent idea to print this table, and then check off the
    meaning of each keyword when we learn it; some keywords have multiple
    meanings, determined by the context in which they are used.
<p>
<table cellspacing="0" cellpadding="5" border="1" rules="all">
<tbody >
<tr><td>abstract</td><td>continue</td><td>goto</td><td>package</td><td>switch</td>
<tr><td>assert</td><td>default</td><td>if</td><td>private</td><td>this</td>
<tr><td>boolean</td><td>do</td><td>implements</td><td>protected</td><td>throw</td>
<tr><td>break</td><td>double</td><td>import</td><td>public</td><td>throws</td>
<tr><td>byte</td><td>else</td><td>instanceof</td><td>return</td><td>transient</td>
<tr><td>case</td><td>extends</td><td>int</td><td>short</td><td>try</td>
<tr><td>catch</td><td>final</td><td>interface</td><td>static</td><td>void</td>
<tr><td>char</td><td>finally</td><td>long</td><td>strictfp</td><td>volatile</td><tr><td>class</td><td>float</td><td>native</td><td>super</td><td>while</td>
<tr><td>const</td><td>for</td><td>new</td><td>synchronized</td><td>&nbsp</td>

<tr>
</table>
  <p>
  Notice that all Java keywords contain only lower-case letters and are at
    least 2 characters long; therefore, if we choose identifiers that are very
    short (one character) or that have at least one upper-case letter in them,
    we will never have to worry about them clashing with (accidentally being
    mistaken for) a keyword.
  Also note that in the Metrowerks IDE (if you use my color preferences),
    keywords always appear in yellow (while identifiers, and many other tokens,
    appear in white).
  <p>
  We could state this same tabular information as a very long (and thus harder
    to read) EBNF rule of choices (and we really would have to specify 
    each of these keywords, and not use "...") looking like
  <p>
  <i>keyword</i> <= abstract | boolean | ... | while 
  <p>
  Finally, <b>assert</b> was recently added (in Java 1.4) to the original 48
    keywords in Java.
</td>
</tbody>
</table>


<!-- Separators -->

<a name="Separators"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Separators</b></td>
<td width ="80%">
  The third category of token is a <b>Separator</b> (also known as a
    punctuator).
  There are exactly nine, single character separators in Java, shown in the
     following simple EBNF rule.
  <p>
  <i>separator</i> <= ; | , | . | ( | ) | { | } | [ | ]  
  <p>
  In the <i>separator</i> rule, the bracket/brace characters stand for
    themselves (not EBNF options or repetitions).
  <p>
  Note that the first three separators are tokens that separate/punctuate
    other tokens.
  The last six separators (3 pairs of 2 each) are also known as delimiters:
    wherever a left delimiter appears in a correct Java program, its matching
    right delimiter appears soon afterwards (they always come in matched
    pairs).
  Together, these each pair delimits some other entity.
  <p>
  For example the Java code <b>Math.max(count,limit);</b> contains nine
   tokens
  <ol>
    <li> an identifier (<b>Math</b>), followed by
    <li> a separator (a period), followed by 
    <li> another identifier (<b>max</b>), followed by
    <li> a separator (the left parenthesis delimiter), followed by
    <li> an identfier (<b>count</b>), followed by
    <li> a separator (a comma), followed by
    <li> another identifier(<b>limit</b>), followed by
    <li> a separator (the right parenthesis delimiter), followed by
     <li> a separator (a semicolon)
 </ol>
</td>
</tbody>
</table>


<!-- Operators -->

<a name="Operators"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Operators</b></td>
<td width ="80%">
  The fourth category of token is an <b>Operator</b>.
  Java includes 37 operators that are listed in the table below;
    each of these operators consist of 1, 2, or at most 3 <i>special</i> 
    characters.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
    <tbody>
    <tr align="center"><td>=</td><td>&gt</td><td>&lt</td><td>!</td><td>~</td><td>?</td><td>:</td><td>&nbsp</td>
        <td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
    <tr align="center"><td>==</td><td>&lt=</td><td>&gt=</td><td>!=</td><td>&&</td><td>||</td><td>++</td><td>--</td>
        <td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
    <tr align="center"><td>+</td><td>-</td><td>*</td><td>/</td><td>&</td><td>|</td><td>^</td><td>%</td>
        <td>&lt&lt</td><td>&gt&gt</td><td>&gt&gt&gt</td>
    <tr align="center"><td>+=</td><td>-=</td><td>*=</td><td>/=</td><td>&=</td><td>|=</td><td>^=</td><td>%=</td>
        <td>&lt&lt=</td><td>&gt&gt=</td><td>&gt&gt=</td>
    </table>
  <p>
  The keywords <b>instanceof</b> and <b>new</b> are also considered operators
    in Java.
  This double classification can be a bit confusing; but by the time we
    discuss these operators, you'll know enough about programmig to take them
    in stride.
  <p>
  It is important to understand that Java always tries to construct the
    <b>longest</b> token from the characters that it is reading.
  So, <b>&gt&gt=</b> is read as one token, not as the three tokens <b>&gt</b>
     and <b>&gt</b> and <b>=</b>, nor as the two tokens <b>&gt&gt</b> and
     <b>=</b>, nor even as the two tokens <b>&gt</b> and <b>&gt=</b>.
  <p>
  Of course, we can always use white space to force Java to recognize separate
    tokens of any combination of these characters:
    writing <b>&gt &nbsp &gt=</b> is the two tokens <b>&gt</b> and <b>&gt=</b>.
  <p>
  We could state this same tabular information as a very long (and thus harder
    to read) EBNF rule of choices (and we really would have to specify each of
    these operators, and not use "...") looking like
  <p>
  <i>operator</i> <= &nbsp = | &gt | ... | &gt&gt= | instanceof | new
  <p>
</td>
</tbody>
</table>


<!-- Types and Literals -->

<a name="TypesLiterals"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Types and Literals</b></td>
<td width ="80%">
  The fifth, and most complicated category of tokens is the <b>Literal</b>.
  All values that we write in a program are literals: each belongs to one of
     Java's four primitive types (<b>int</b>, <b>double</b>, <b>boolean</b>,
     <b>char</b>) or belongs to the special reference type <b>String</b>.
  All primitive type names are keywords in Java; the <b>String</b> reference
    type names a class in the standard Java library, which we will learn much
    more about soon.
  A value (of any type) written in a Java program is called a <b>literal</b>;
    and, each written literal belongs in (or is said to have) exactly one type.
  <p>
  <i>literal</i> <= <i>integer-literal</i> | <i>floating-point-literal</i> | <i>boolean-literal</i><br>
    &nbsp  &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 
    | <i>character-literal</i>
    | <i>string-literal</i>
    | <i>null-literal</i>
  <p>
  Here are some examples of literals of each of these types.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead>
  <tr><th>Literal</th><th>type</th>
  </thead>
  <tbody >
  <tr><td><b>1</b></td><td><b>int</b></td>
  <tr><td><b>3.14</b></td><td><b>double</b> (<b>1.</b> is a <b>double</b> too)</td>
  <tr><td><b>true</b></td><td><b>boolean</b></td>
  <tr><td><b>'3'</b></td><td><b>char</b> (<b>'P'</b> and <b>'+'</b> are <b>char</b> too)</td>
  <tr><td><b>"UCI ID"</b></td><td><b>String</b></td>
  <tr><td><b>null</b></td><td>any reference type</td>
  </table>
  <p>
  The next six sections discuss each of these types of literals, in more detail.
</td>
</tbody>
</table>


<!-- int Literals -->

<a name="IntLiterals"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>int Literals</b></td>
<td width ="80%">
  Literals of the primitive type <b>int</b> represent countable, discrete
    quantities (values with no fractions nor decimal places
    possible/necessary).
  We can specify the EBNF for an <b>int</b> literal in Java as
  <p>
  <i>non-zero-digit</i> &nbsp &nbsp <= 1|2|3|4|5|6|7|8|9<br> 
  <i>digit</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= 0 | <i>non-zero-digit</i><br> 
  <i>digits</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= <i>digit</i>{<i>digit</i>}<br> 
  <i>decimal-numeral</i> <= 0 | <i>non-zero-digit</i>[<i>digits</i>]<br>
  <i>integer-literal</i> &nbsp &nbsp &nbsp<= <i>decimal-numeral</i><br> 
   &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp | <i>octal-numeral</i><br>
   &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp | <i>hexidecimal-numeral</i>
  <p>
  This EBNF specifies only decimal (base 10) literals. 
  In Java literals can also be written in ocal (base 8) and hexidecimal
    (base 16).
  I have omitted the EBNF rules for forming these kinds of numbers, because we
    will use base 10 exclusively.
  Thus, the rules shown above are correct, but not complete.
  <p>
  By the EBNF rules above, note that the symbol <b>015</b> does not look like a
     legal <i>integer-literal</i>; it is certainly not a
     <i>decimal-numeral</i>, because it starts with a zero.
  But, in fact, it is an <i>octal-numeral</i> (whose EBNF is not shown).
  Never start an <i>integer-literal</i> with a <b>0</b> (unless its value is
    zero), because starting with a <b>0</b> in Java signifies the literal is
    being written as an octal (base 8) number: e.g., writing <b>015</b> refers
    to an octal value, whose decimal (base 10) value is 13!
  So writing a leading zero in an integer can get you very confused about what
    you said to the computer.
  <p>
  Finally, note that there are no negative literals: we will see soon how to
    compute such values from the negate arithmetic operator and a positive
    literal (writing <b>-1</b> is exactly such a construct).
  This is a detail: a distinction without much difference.
</td>
</tbody>
</table>


<!-- double Literals -->

<a name="DoubleLiterals"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>double Literals</b></td>
<td width ="80%">
  Literals of the primtive type <b>double</b> represent measureable quantities.
  Like real numbers in mathematics, they can represent fractions and numbers
     with decimal places.
  We can specify the EBNF for a <b>double</b> literal in Java as
  <p>
  <i>exponent-indicator</i> &nbsp <= e | E <br> 
  <i>exponent-part</i> &nbsp &nbsp &nbsp &nbsp &nbsp  <= <i>exponent-indicator</i> [+|-]<i>digits</i><br> 
  <i>floating-point-literal</i> <= <i>digits</i> <i>exponent-part</i><br>
    &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
    &nbsp &nbsp &nbsp &nbsp &nbsp
     | <i>digits</i>.[<i>digits</i>][<i>exponent-part</i>]<br>
    &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
    &nbsp &nbsp &nbsp &nbsp &nbsp
     | .<i>digits</i>[<i>exponent-part</i>]
  <p>
  This EBNF specifies a <i>floating-point-literal</i> to contain various
    combinations of a decimal point and exponent (so long as one -or both- are
    present); if neither is present then the literal must be classified as an
    <i>int-literal</i>.
  The <i>exponent-indicator</i> (<b>E</b> or <b>e</b>) should be read to mean
    "times 10 raised to the power of".
  <p>
  Like literals of the type <b>int</b>, all <b>double</b> literals are
    non-negative (although they may contain negative exponents).
  Using <b>E</b> or <b>e</b> means that we can specify very large or small
    values easily
   (<b>3.518E+15</b> is equivalent to <b>3.518</b> times 10 raised to the
    power of <b>15</b>, or <b>3518000000000000.</b>; and <b>3.518E-15</b> is
    equivalent to <b>3.518</b> times 10 raised to the power of <b>-15</b>, or
    <b>.000000000000003518</b>) 
  In fact, any literal with an <i>exponent-part</i> is a <b>double</b>: so even
    writing <b>1E3</b> is equivalent to writing <b>1.E3</b>, which are both
    equivalent to writing </b>1000.</b>
  Note this does not mean the <b>int</b> literal <b>1000</b>!
  <p>
  Finally, all <b>double</b> literals must be written in base 10 (unlike
    <b>int</b> literals, which can be written in octal or hexadecimal) 
</td>
</tbody>
</table>


<!-- Boolean Literals -->

<a name="BooleanLiterals"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>boolean Literals</b></td>
<td width ="80%">
  The type name <b>boolean</b> honors George Boole, a 19th century English
    mathematician who revolutionized the study of logic by making it more
    like arithmetic.
  He invented a method for calculating with truth values and an algebra for
    reasoning about these calculations.
  Boole's methods are used extensively today in the engineering of hardware
     and software systems.
  <p>
  Literals of the primitive type <b>boolean</b> represent on/off, yes/no,
     present/absent, ... data.
  There are only two values of this primtive type, so its ENBF rule is
    trivially written as
  <p>
  <i>boolean-literal</i> <= true | false<br> 
  <p>
  In Java, although these values look like identifiers, they are classified as
    literal tokens (just as all the keywords also look like identifiers, but
    are classified differently).
  Therefore, <b>100</b> and <b>true</b> are both literal tokens in Java (of
    type <b>int</b> and <b>boolean</b> respectively).
  <p>
  Students who are familiar with numbers sometimes have a hard time accepting
    <b>true</b> as a value; but that is exactly what it is in Java. 
  We will soon learn logical operators that compute with these values of the
    type <b>boolean</b> just as arithmetic operators compute with values of
    the type <b>int</b>.
</td>
</tbody>
</table>


<!-- Character Literals -->

<a name="CharLiterals"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>char Literals</b></td>
<td width ="80%">
  The first type of text literal is a <b>char</b>.
  This word can be pronounced in many ways: <i>care</i>, <i>car</i>, or as in
    <i>char</i>coal 
  (I'll use this last pronunciation).
  Literals of this primitive type represent exactly one character inside
   single quotes.
  Its EBNF rule is written
  <p>
  <i>character-literal</i> <= '<i>graphic</i>' | '<i>space</i>' | '<i>escape-sequence</i>' 
  <p>
  where the middle option is a space between single quotes.
  Examples are <b>'X'</b>, or <b>'x'</b>, or <b>'?'</b>, or <b>'&nbsp'</b>, or
   <b>'\n'</b>, etc. (see below for a list of some useful escape sequences).
  <p>
  Note that <b>'X'</b> is classified just as a literal token (of the primitive
    type <b>char</b>); it is NOT classified as an identifier token inside two
    separator tokens!
</td>
</tbody>
</table>


<!-- String Literals -->

<a name="StringLiterals"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>String Literals</b></td>
<td width ="80%">
  The second type of text literal is a <b>String</b>.
  Literals of this reference type (the only one in this bunch; it is not a
    primitive type) represent zero, one, or more characters:
  Its EBNF is written
  <p>
  <i>string-literal</i> <= "{<i>graphic</i> | <i>space</i> | <i>escape-sequence</i>}" 
  <p>
  Examples are: <b>"\n\nEnter your SSN:"</b>, or
   <b>""</b> (the empty String), or
   <b>"X"</b> (a one character <b>String</b>, which is different from a
   <b>char</b>).
  <p>
  Note that <b>"UCI"</b> is classified just as a literal token (of the
    reference type <b>String</b>); it is NOT classified as an identifier token
    inside two separator tokens!
</td>
</tbody>
</table>


<!-- Escape Sequences -->

<a name="EscapeSequences"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Escape Sequences</b></td>
<td width ="80%">
  Sometimes you will see an <i>escape-sequence</i> inside the single-quotes
    for a <i>character-literal</i> or one or more inside double-quotes for a
    <i>string-literal</i> (see above);
    each escape sequence is translated into a character that prints in some
    "special" way.
  Some commonly used escape sequences are
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead>
  <tr><th>Escape Sequence</th><th>Meaning</th>
  </thead>
  <tbody >
  <tr><td><b>\n</b></td><td><b>new line</b></td>
  <tr><td><b>\t</b></td><td><b>horizontal tab</b></td>
  <tr><td><b>\v</b></td><td><b>vertical tab</b></td>
  <tr><td><b>\b</b></td><td><b>backspace</b></td>
  <tr><td><b>\r</b></td><td><b>carriage return</b></td>
  <tr><td><b>\f</b></td><td><b>form feed</b></td>
  <tr><td><b>\a</b></td><td><b>bell</b></td>
  <tr><td><b>\\</b></td><td><b>\</b> (needed to denote \ in a text literal)</td>
  <tr><td><b>\'</b></td><td><b>'</b> (does not act as the right <b>'</b> of a char literal)</td>
  <tr><td><b>\"</b></td><td><b>"</b> (does not act as the right <b>"</b> of a String literal)</td>
  </table>
  <p>
  So, in the <b>String</b> literal <b>"He said, \"Hi.\""</b> neither escape
    sequence <b>\"</b> acts to end the <b>String</b> literal: each represents
    a double-quote that is part of the <b>String</b> literal, which displays
    as <b>He said, "Hi."</b>
  <p>
  If we output <b>"Pack\nage"</b>, Java would print on the console<pre>Pack
age</pre>
  with the escape sequence <b>\n</b> causing Java to immediately terminate the
   current line and start at the beginning of a new line.
  <p>
  There are other ways in Java to write escape sequences (dealing with unicode
    represented by octal numbers) that we will not cover here, nor need in the
    course.
  The only escape sequence that we wil use with any frequency is <b>\n</b>.
</td>
</tbody>
</table>


<!-- Null Literals -->

<a name="NullLiteral"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The null Reference Literal</b></td>
<td width ="80%">
  There is a very simple, special kind of literal that is used to represent a
    special value with every reference type in Java (so far we know only one,
    the type <b>String</b>).
  For completeness we will list it here, and learn about its use a bit later.
  Its trivial EBNF rule is written
  <p>
  <i>null-literal</i> <= null 
  <p>
  So, as we learned with <b>boolean</b> literals, <b>null</b> is a literal in
    Java, not an identifier.
</td>
</tbody>
</table>


<!-- Bounded Numerics -->

<a name="BoundedNumeric"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Bounded Numeric Types</b></td>
<td width ="80%">
  Although there are an infinite number of integers in mathematics, values in
    the <b>int</b> type are limited to the range from -2,147,483,648 to
    2,147,483,647.
  We will explore this limitation later in the course, but for now we will not
    worry about it.
  <p>
  Likewise, although there are an infinite number of reals in mathematics,
    values in the <b>double</b> type are limited to the range from<br> 
    -1.79769313486231570x10<sup>308</sup>
    to
    1.79769313486231570x10<sup>308</sup>; the smallest non-zero, positive value
    is
    4.94065645841246544x10<sup>-324</sup>.
  Values in this type can have up to about 15 significant digits.
  For most engineering and science calculations, this range and precision are
    adequate.
  <p>
  In fact, there are other primitive numeric types (which are also keywords):
    <b>short</b>, <b>long</b>, and <b>float</b>.
  These types are variants of <b>int</b> and <b>double</b> and are not as 
   widely useful as these more standard types, so we will not cover them in
   this course.
  <p>
  Finally, there is a reference type named <b>BigInteger</b>, which can
    represent any number of digits in an integer (up to the memory capacity of
     the machine).
  Such a type is very powerful (because it can represent any integer), but
   costly to use (in execution time and computer space) compared to <b>int</b>.
  Most programs can live with the "small" integer values specified above; but,
    we will also study this reference type soon, and write programs using it.
</td>
</tbody>
</table>


<!-- Comments -->

<a name="Comments"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Comments</b></td>
<td width ="80%">
  The sixth and final category of tokens is the <b>Comment</b>.
  Comments allow us to place any form of documentation inside our Java code.
  They can contain anything that we can type on the keyboard: English,
    mathematics, even low-resolution pictures.
  In general, Java recognizes comments as tokens, but then excludes these
    tokens from further processing; technically, it treats them as white space
    when it is forming tokens.
  <p>
  Comments help us capture aspects of our programs that cannot be expressed as
     Java code.
  Things like goals, specification, design structures, time/space tradeoffs,
    historical information, advice for using/modifying this code, etc.
  Programmers intensely study their own code (or the code of others) when
     maintaining it  (testing, debugging or modifying it).
  Good comments in code make all these tasks much easier.
  <p>
  Java includes two style for comments.
  <ul>
     <li>Line-Oriented: begins with <b>//</b> and continues until the end of
           the line.
     <li>Block-Oriented: begins with <b>/*</b> and continues (possibly over
           many lines) until <b>*/</b> is reached. 
     <ul>
       <li>So, we can use block-oriented comments to create multiple comments
           within a line<br>
           <b>&nbsp &nbsp display(/*Value*/ x, /*on device*/ d);</b><br>
           In contrast, once a line-oriented comment starts, everything 
             afterward on its line is included in the comment.
       <li>We can also use block-oriented comments to span multiple lines<br>
           <b>/*<br>
              &nbsp &nbsp This is a multi-line comment.<br>
              &nbsp &nbsp No matter home many lines<br>
              &nbsp &nbsp it includes, only one pair<br>
              &nbsp &nbsp of delimiters are needed.<br>
              */</b><br>
           In contrast, a line-oriented comment stops at the end of the line
             it starts on.
     </ul>
   </ul>     
   Technically, both kinds of comments are treated as white space, so writing
     <b>X/*comment*/Y</b> has the same meaning in Java as writing the tokens
     <b>X</b> and <b>Y</b>, not the single token <b>XY</b>.
   <p>
   Typically Java comments are line-oriented; we will save block-oriented
      comments for a special debugging purpose (discussed later).
   <p>
   The EBNF rule for comments is more complicated than insightful, so we will
     not study here.
   This happens once in a while.
</td>
</tbody>
</table>


<!-- Programs -->

<a name="Programs"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Program are a Sequence of Tokens built from Characters</b></td>
<td width ="80%">
  The first phase, a Java compiler tokenizes a program by scanning its
    characters left to right, top to bottom (there is a hidden end-of-line
    character at the end of each line; recall that it is equivalent to white
    space), and combining selected characters into tokens.
  It works by repeating the following algorithm (an algorithm is a precise set
    of instructions):
  <ul>
    <li>Skip any white space...
    <li>...if the next character is an underscore, dollar, or alphabetic
          character, it builds an identifier token.
    <ul>
      <li>Except for recognizing keywords and certain literals (<b>true</b>,
            <b>false</b>, <b>null</b>) which all share the form of identifiers,
            but are not themselves identifiers
    </ul>
    <li>...if the next character is a numeric character, ' or ", it builds a
          literal token.
    <li>...if the next character is a period, that is a seperator unless the
          character after it is a numeric character (in which case it builds a
           <b>double</b> literal).
    <li>...if the next two characters are a // or /* starting a comment, it
           builds a comment token.
    <li>...if the next character is anything else, it builds a separator or
          operator token (trying to build the longest token, given that white
          space separates tokens, except in a <b>char</b> or <b>String</b>
          literal).
  </ul>
  Recall that white space (except when inside a textual literal or comment)
    separates tokens.
  <p>
  Also, the Java compiler uses the "longest token rule": it includes characters
    in a token until it reaches a character that cannot be included.
  <p>
  Finally, after building and recognizing each token, the Java compiler passes
    all tokens (except for comments, which are ignored after being tokenized)
    on to the next phase of the compiler.
</td>
</tbody>
</table>


<!-- Common Mistakes -->

<a name="CommonMistakes"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Common Mistakes</b></td>
<td width ="80%">
  I have seen the following mistakes made repeatedly by beginning students
    trying to tokenize programs.
  Try to understand each of these subtle points.
  <ul>
    <li>Tokenizing <b>x</b> as a <b>char</b> literal: it is an identifier.
    <li>Tokenizing <b>10.5</b> as two <b>int</b> literals separated by a
          period: it is a <b>double</b> literal.
    <li>Tokenizing <b>int</b> as a literal: it is a keyword, that happens to
          name a type in Java.
        Tokens like <b>1</b> are literals whose type is <b>int</b>; the token
          <b>int</b> is a keyword.
    <li>Tokenizing <b>"Hi"</b> as two <b>separator</b>s with the identifier
          <b>Hi</b> in between: it is a single <b>String</b> literal.
    <li>Tokenizing something like <b>};</b> as one separator token: it is
          really two separate separators.
    <li>Tokenizing something like <b>+=</b> as two separate operator tokens
          (because <b>+</b> and <b>=</b> are operators): it is really one
          large token (because <b>+=</b> is an operator).
    <li>Forgetting to tokenize parentheses, semicolons, and other separators:
          everything except white space belongs in some token.
    <li>Creaing tokens inside comments: each comment is one big token that
          includes all the characters in the comment.
  </ul>
</td>
</tbody>
</table>


<!-- A Simple Program -->

<a name="SimpleProgram"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>A Simple Program</b></td>
<td width ="80%">
  The following program will serve as a model of Input/Calculate/Output
     programs in Java.
  Here are some highlights
  <ul>
    <li>A large, multi-line (oriented) comment appears at the top of the
          program.
        Line-oriented comments appear at various other locations in the
           program.
    <li>The <b>Prompt</b> class is imported from the
           <b>edu.uci.ics.pattis.introlib</b> package.
    <li>The <b>Application</b> class is declared.
    <li>Its <b>main</b> method is declared; its body (the statements it
          executes) is  placed between the <b>{</b> and <b>}</b> delimiters.
    <li>Each simple statement in the body is ended by a semicolon (<b>;</b>)
           separator.
    <li>Three variables storing <b>double</b> values are declared.
    <li>The user is prompted for the value to store in the first two variables.
    <li>The third variable's value is computed and stored.
    <li>The third variable's value is printed (after printing a blank line).
  </ul>
  Besides just reading this program, practice tokenzing it.
</td>
</tbody>
</table>
<p>
<pre>
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Description:
//
//   This program computes the time it take to drop an object (in a vacuum)
// form an arbitrary height in an arbitrary gravitational field (so it can
// be used to calculate drop times on other planets). It models a straight
// input/calculate/output program: the user enters the gravitation field
// and then the height; it calculates thd drop time and then prints in on
// the console.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


import edu.uci.ics.pattis.introlib.Prompt;


public class Application {


  public static void main(String[] args) {
    double gravity;        //meter/sec/sec
    double height;         //meters
    double time;           //sec
		  
		  
    //Input
		  
    gravity = Prompt.forDouble("Enter gravitational acceleration (in meters/sec/sec)");
    height  = Prompt.forDouble("Enter height of drop (in meters)");
		  
		  
    //Calculate
  
    time = Math.sqrt(2.*height/gravity);
		  
		  
    //Output

    System.out.println("\nDrop time = " + time + " secs");
  }
}
</pre>


<!-- How Experts See Programs -->

<a name="SeePrograms"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>How Experts See Programs</b></td>
<td width ="80%">
  In the 1940s, a Dutch psychologist named DeGroot was doing research on chess
     experts.
  He performed the following experiment: He sat chess experts down in front of
    an empty chessboard, all the chess pieces, and a curtain.
  Behind the curtain was a chessboard with its pieces arranged about 35 moves
     into a game.
  The curtain was raised for one minute and then lowered.
  The chess experts were asked to reconstruct what they remembered from seeing
    the chessboard behind the curtain.
  <p>
  In most cases, the chess experts were able to completely reconstruct the
    board that they saw.
  The same experiment was conducted with chess novices, but most were able to
    remember only a few locations of the pieces. 
  These results could be interpreted as, "Chess experts have much better
     memories than novices."
  <p>
  So, DeGroot performed a second (similar) experiment.
  In the second experiment, the board behind the curtain had the same number
    of chess pieces, but they were randomly placed on the board; they did not
    represent an ongoing game.
  In this modified experiment, the chess experts did only marginally better
    than the novices.
  DeGroot's conclusion was that chess experts saw the board differently than
    novices: they saw not only pieces, but attacking and defending structures,
    board control, etc.
  <p>
  In this class, I am trying to teach you how to see programs as a programmer
    sees them: not as a sequence of characters, but at a higher structural
    level.
  Tokens is where we start this process.
  For another example on what the mind sees when it reads, look at the
    following <a href="understanding.docx">document</a>.
</td>
</tbody>
</table>


<!-- Problem Set -->

<a name="ProblemSet"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem Set</b></td>
<td width ="80%">
  To ensure that you understand all the material in this lecture, please solve
    the the announced problems after you read the lecture.
  <p>
  If you get stumped on any problem, go back and read the relevant part of the
     lecture.
  If you still have questions, please get help from the Instructor, a CA, a Tutor,
    or any other student.
  <ol>
    <li>Classify each of the following as a legal or illegal identifier.
        If it is illegal, propose a legal identifier that can take its place
        (a homophone or homoglyph)
    <table cellspacing="0" cellpadding="5" border="0" rules="all" width ="100%">
    <tbody > 
    <tr> <td><b>packAge</b></td>  <td><b>x12</b></td>  <td><b>2Lips</b></td>
    <tr> <td><b>xOrY</b></td>      <td><b>sum of squares</b></td>  <td><b>%Raise</b></td>
    <tr> <td><b>termInAte</b></td>  <td><b>u235</b></td>  <td><b>$Bill</b></td>
    <tr> <td><b>x_1</b></td>  <td><b>x&Y</b></td>  <td><b>1derBoys</b></td>
    </table>
    <p>

    <li> What tokens does Java build from the characters <b>ab=c+++d==e</b>.
         Be sure that you know your <a href="#Operators">Operators</a>.
    <p>

    <li>Classify each of the following numeric literals as <b>int</b>, or <b>double</b>, or
       illegal (neither); write the equivalent value of each <b>double</b> without using 
       E notation; for each illegal literal, write a legal one with the "same" value.
    <table cellspacing="0" cellpadding="5" border="0" rules="all" width ="100%">
    <tbody > 
    <tr> <td><b>5.</b></td>  <td><b>3.1415</b></td>  <td><b>17</b></td>
    <tr> <td><b>17.0</b></td>      <td><b>1E3</b></td>  <td><b>1.E3</b></td>
    <tr> <td><b>.5E-3</b></td>  <td><b>5.4x10<sup>3</sup></b></td>  <td><b>50E-1</b></td>
    <tr> <td><b>1,024</b></td>  <td><b>0.087</b></td>  <td><b>.087</b></td>
    </table>
    <p>

    <li>What is the difference between <b>5</b>, <b>5.</b>, <b>five</b>, 
         <b>'5'</b>, and <b>"5"</b>?
        What is the difference between <b>true</b> and <b>"true"</b>?
    <p>

    <li>Write a <b>String</b> literal that includes the characters
        <b>I've said a million times, "Do not exaggerate!"</b>
    <p>

    <li> How does Java classify each of the following lines<br>
    &nbsp &nbsp <b>"//To be or not to be"</b><br>
    &nbsp &nbsp <b>//"To be or not to be"</b>
    <p>

    <li>Does the following line contain one comment or two?<br> 
    &nbsp &nbsp<b>//A comment //Another comment?</b>
    <p>

    <li>Explain whether <b>X/**/Y</b> is equivalent to <b>XY</b> or <b>X &nbsp Y</b>.
    <p>

    <li>Tokenize the following Java Code (be careful): <b>-15</b>
    <p>

    <li>Tokenize the following line of Java code: identify every Java token as either an 
        Identifier, Keyword, Separator, Operator, Literal (for any literal, also specify its type), or Comment.
        Which (if any) identifiers are keywords?<br>
        <tt><nobr>int X = Prompt.forInt("SSN",0,999999999);  //Filter && use</nobr></tt>
    <p>

    <li>Choose an appropriate type to represent each of the following pieces of information
      <ul>
        <li>the number of characters in a file
        <li>a time of day (accurate to 1 second)
        <li>the middle initial in a name
        <li>whether the left mouse button is currently pushed
        <li>the position of a rotary switch (with 5 positions)
        <li>the temperature of a blast furnace
        <li>an indication of whether one quantity is less than, equal to or greater than another
        <li>the name of a company
      </ul>
    <p>

    <li>This problem (it is tricky, so do it carefully) shows a difficulty with using
         Block-Oriented comments.
        Tokenize the following two lines of Java code: identify every token as either an
          Identifier, Keyword, Separator, Operator, Literal, or Comment. What problem arises?<br>
<pre>  x = 0;  /* Initialize x and y to
  y = 1;     their starting values */</pre>
        Rewrite the code shown above with Line-Oriented comments instead, to avoid this problem.
        How can our use of my Java preferences help us avoid this error?
    <p>

    <li>This problem (it is tricky, so do it carefully) shows another difficulty with using
         Block-Oriented comments.
        Tokenize the following Java code: identify every token as either an
          Identifier, Keyword, Separator, Operator, Literal, or Comment. What problem arises?<br>
        <pre>  /*
    here is an outer
    comment with an
    /* inner comment inside */
    and the finish of the outer
    comment at the end
  */</pre>
        Rewrite the code shown above with Line-Oriented comments instead, to avoid this problem.
        How can our use of my Java preferences help us avoid this error?

    <p>

    <li>Explain why language designers are very reluctant to add new keywords
          to a programming language.
        Hint: what problem might this cause in already-written programs?
  </ol>
</tbody>
</table>


</body>
</html>
