<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
  <title>Program 1</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Program 1</h1>
<h1>
Programming using the ICS-46 Template Library (ITL):<br>
Stack, Queue, Priority Queue, Set, and Map
</h1>
<p>
<h2>ICS-46: Data Structure Implementation and Analysis<br>
</h2>
<p>
</center>


<!-- Introduction -->

<a name="Introduction">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Introduction</b></td>
<td width ="80%">
This programming assignment is designed to ensure that you know how to use
  combinations of ITL's templated classes to model and compactly write code
  that solves a variety of different programming problems.
The kind of abstract thinking that goes into modeling solutions to these
  programming problems with these data types (and iteration over them) is
  important to your development as programmers.
This assignment will also start you on understanding the compiler error-messages
  produced when using templated classes incorrectly.
<p>
There are five parts to this assignment.
In each you will be asked to write a program (<b>.cpp</b> file) that defines a
  few functions and has a <b>main</b> function, which ties these functions
  together to solve the problem.
<p>
You should download the 
  <a href="program1.zip">program1</a> project folder and use it to create an
  CLion project (needing only <b>courselib</b> not <b>googletest</b>).
You will create each program in this project, and submit each program
  separately in Checkmate.
The project folder contains boiler-plated files (including some <b>typedefs</b>
  that I found useful in my code: you may change their names) and contains all
  the data files that you need to test/debug you programs.
<b>Important: In the standard download, only one of the <b>.cpp</b> files can
   be active/tested at any time</b> (each contains a <b>main</b> method).
In the download, all are active; so I suggest that you inactivate the
  <b>runoffvoting.cpp</b>, <b>fa.cpp</b>, <b>ndfa.cpp</b>, and
  <b>wordgenerator.cpp</b> files and then work on  <b>reachable.cpp</b> first.
Then, as you finish each program, submit it, deactivate it, and activate the
  next program you will work on.
<p>
To make a progam inactive, select it (in the editor tab), use the <b>Ctrl+a</b>
  command to select all its lines, and then <b>Ctrl+/</b> (or click
  <b>Source</b> at the top left of the menu and choose <b>Toggle Comment</b>):
  every line will now appear in a comment; by reusing these same instructions,
  you can toggle back those lines to remove the comments.
<p>
Alternatively, you can also use a existing/working project folder: remove (but
  save) all the files in its <b>src</b> folder and then put all the <b>.cpp</b>
  files from the downloaded project's <b>src</b> folder into the
  existing/working project's <b>src</b> folder.
Also put all the data files into the existing project folder, not in the
 <b>src</b> folder, but at the same level as trhe <b>src</b> folder.
<p>
<b>IMPORTANT: Turn in .cpp files that are runnable: their code should not be
     commented-out.</b>
<p>
I recommend that you work on this assignment in pairs.
Try to find someone who lives near you, with similar programming skills,
  and work habits/schedule: e.g., talk about whether you prefer to work
  mornings, nights, or weekends; what kind of commitment you will make to submit
  program early.
<p>
Only <b>ONE STUDENT</b> should submit the assignment (all parts of it).
If students work in pairs, <b>BOTH NAMES</b> and their UCInetID names must
  appear in a comment at the top of each submitted program.
For example if Romeo Montague (whose UCInetID is romeo1) submitted a program
  that he worked on with his partner Juliet Capulet (whose UCInetID is jcapulet)
  the comment at the top of each submitted file would appear as:
<pre><b>  // Submitter: romeo1(Montague, Romeo)
  // Partner  : jcapulet(Capulet, Juliet)
  // We certify that we worked cooperatively on this programming
  //   assignment, according to the rules for pair programming</b></pre>
If you do not know what the terms <b>cooperatively</b> and/or
  <b>rules for pair programming</b> mean, please read about
  <a href="../../../common/handouts/pairprogramming.html">Pair Programming</a> 
  before starting this assignment.
If the names do not appear at the top of all your submissions in exactly this
  form, points will be deducted.
If you are submitting by yourself, you may omit all lines but the first
  (<b>Submitter</b>).
Please <b>do</b> turn in each program <b>as you finish it</b>, so that I can
  accurately assess the progress of the class as a whole during this assignment;
  <b>do not</b> turn in all the programs at the same time.
<p>
Print this document and carefully read it, marking any parts that contain
  important detailed information that you find (for review before you turn in
  the files).
You should familiarize yourselves with the <b>ics46goody.hpp</b> file in the
  <b>courselib/src</b> folder.
It contains functions useful in all these programs: <b>split</b> and <b>join</b>
  (like their counterparts in Python, they use <b>std::string</b> and 
  <b>vector&lt;std::string></b>), <b>prompt_string</b>, and <b>safe_open</b>.
<p>
This assignment has five parts: pairs should work on each part together, not
  split them up and do them separately.
Parts 1-3 are 14 points each (42 points total); Part 4 is worth 10 points;
   Part 5 is worth 8 points.
This skewing of points towards the simpler parts means students finishing the
  first three parts correctly will have a 70% average; those finishing the
  first four parts correctly will have about an 87% average; but to get an A on
  this assignment requires solving all parts correctly.
Remember that I'm going to be running MOSS on the parts of this assignment to
  check for program similarity (both for submission this quarter, and for
  previous quarters).
<p>
<b>Important</b>:
The <a href="../../programs/cross_reference.zip">cross_reference</a>
  program shows an exmple of the form of code that you need to write for these
  programs: study and understand its code before attempting to start
  solving these problems.
Questions about <b>cross_reference</b>? Post them on a Message Board in the
  Forum (and feel free to read and answer the questions of other students).
<p>
Use the array implementations supplied in the ITL for all the data types.
The programs in the folder you will download have <b>#include</b> statements at
  the top for all the files that you need to use.
<p>
Along with the details of the functions, I've included the number of lines
  that I wrote in my solution.
I am supplying these number of lines <b>not</b> as a requirement, but as a
  ballpark estimate of the amount of code you should write.
</td>
</tbody>
</table>


<!-- Problem 1 -->

<a name="problem1">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>#1: Reachability<br>(14 pts)</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
<ul>
<li>Write a program that prompts the user to enter the name of
       a file representing a graph.
<li>Read the information in the file, storing the graph in a map.
<li>Print the graph.
<li>Repeatedly prompt the user for a starting node in the graph, and compute and
      print all the nodes that are reachable from it by following zero or more
      edges in the graph (e.g., a node is reachable from itself): convert the
      algorithm for reachability, described in detail below, into C++/ITL code.
</ul>
<h3>Input and Output</h3>
Read a file of pairs of node names (representing edges) in a directed
  graph, building a <b>Map</b> whose key is a <b>std::string</b> source node
  and whose value is a <b>Set</b> of <b>std::string</b> destination nodes that
  are each reachable from the source node key.
Although most of the supplied input files use 1-letter names, your code should
  work for any strings: use the <b>split</b> function in <b>ics46goody.hpp</b>.
<p>
Two nodes appear on each line: first the source node, then the destination
  node, with these node names separated by one semicolon character.
For example, the input file <b>graph1.txt</b> contains the following
  lines (which could appear in this order, or any other):
<b><pre>  c;f
  b;d
  a;c
  c;e
  d;g
  a;b
  e;d
  f;g
  f;d</pre></b>
which represent the graph
<p>
<image src="images/graph.gif">
<p>
Print the graph, one source node per line (the source nodes are printed
  alphabetically) followed by the set of all the destination nodes that the
  source can immediately reach.
The graph above would print as
<b><pre>  Graph: source node -> set[destination nodes]
    a -> set[c,b]
    b -> set[d]
    c -> set[f,e]
    d -> set[g]
    e -> set[d]
    f -> set[g,d]</pre></b>
<p>
Note that the source nodes are <b>sorted</b> alphabetically, but the <b>Set</b>
   of desintation nodes does <b>not have to be sorted</b>:
  in fact it makes no sense to talk about sorted <b>Sets</b>; we could talk
  about a sorted <b>Priority Queue</b> whose contents came from a <b>Set</b>.
Note that because node <b>g</b> is not a source node (it is only a
  destination node), it does not appear first on any line (and appears only
  in the <b>Sets</b> for source nodes <b>d</b> and <b>f</b>).
<p>
There there are multiple data files for this program: <b>graph1.txt</b>,
  <b>graph2.txt</b>, <b>graph3.txt</b>, and <b>graph4.txt</b>; test/debug your
  program on  the first file; when you are done, test it on the rest.
Draw the graph represented by each file to ensure that your code correctly
  prints it and computes the nodes reachable from any source node (which you
  can do by eyeballing the graphs: they are small).
<p>
Repeatedly prompt the user for a starting node in the graph (until <b>quit</b>
  is entered) and compute and print all the nodes that are reachable from it by
  following edges in the graph.
Reject any node not present as a key in the graph.
An example interaction (processing the graph above) might be
<b><pre>  Enter some starting node name (else quit): <i>e</i>
  From e the reachable nodes are set[e,d,g]

  Enter some starting node name (else quit): <i>x</i>
    x is not a source node name in the graph

  Enter some starting node name (else quit): <i>a</i>
  From a the reachable nodes are set[a,c,b,f,e,d,g]

  Enter some starting node name (else quit): <i>quit</i></pre></b>
<h3>Functions and Program</h3>
Write the following functions and <b>main</b> program.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written C++ code.
<ul>
<li><b>read_graph</b> has a (open) file parameter; it returns the <b>Map</b>
     representing the graph
    (mine is 12 lines of well-formatted code).
<p>
<li><b>print_graph</b> has a <b>Map</b> parameter (representing the graph); it
    returns nothing, but it prints the graph in the appropriate form
     (mine is 6 lines of well-formatted code).
<p>
<li><b>reachable</b> has a <b>Map</b> parameter (representing the graph) and
    a <b>std::string</b> start node in the graph (technically a key in the
    <b>Map</b>); it returns a <b>Set</b> of all the nodes reachable from the
    start node by  following edges in the graph
   (mine is 15 lines of well-formatted code).
<p>
<li>Write a <b>main</b> function at the bottom of this file that calls these
     functions to solve the problem
     (mine is 22 lines of well-formatted code).
    To simplify the interaction, you may prompt for the file name and specify
      a default value (<b>graph1.txt</b>): see my <b>safe_open</b> function
     in <b>ics46goody.hpp</b> in the <b>courselib/src</b> folder.
<p>
Here is the basic algorithm for computing reachability; it is simple to explain
  and not (very) complicated to implement.
But, you have to understand these instructions and carefully translate them into
  C++/ITL code.
You should hand-simulate this algorithm using the graph above, and verify that
  it produces the results you expect before coding it.
You might be tempted to use recursion, but please don't: unless recursion is
  done very carefully, it will run forever on graphs with cycles: one of the
  input files is a graph with cycles.
<ol>
<li>To compute all the reachable nodes in a graph, create a <b>Set</b>
   (initially empty) of reached nodes and a <b>Queue</b> (initially containing
   the  parameter start node) of nodes that we are going to explore (to find
   nodes they can reach).
<p>
<li>While the <b>exploring queue</b> still has nodes, remove the first one
    and put it into the <b>reached set</b>; if it is a key in the graph (not all
    nodes are) then for all its destination nodes that are not already in the
   <b>reached set</b>, put them in the <b>exploring queue</b>.
<p>
<li>When the <b>exploring queue</b> becomes empty (can you argue that this
      always will happen -there is no infinite looping?), return the
      <b>reached set</b>.
</ol>
<p>
Print the set containing all these node labels.
When debugging this algorithm, print the the entire <b>Set</b> and <b>Queue</b>
  contents (using <b>&lt;&lt;</b>, the standard insertion operator for these
  data types) after every interesting change, or use the debugger to observe
  these changes.
</ul>
<h3>Sample Interaction</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should "match" this one (sets will match if they have the same
  contents, independent of their order).
You should also check that it works for other starting nodes, and
  a variety of starting nodes in the other graphs.

<b><pre>  Enter some graph file name[graph1.txt]: 

  Graph: source node -> set[destination nodes]
    a -> set[c,b]
    b -> set[d]
    c -> set[f,e]
    d -> set[g]
    e -> set[d]
    f -> set[g,d]

  Enter some starting node name (else quit): <i>e</i>
  From e the reachable nodes are set[e,d,g]

  Enter some starting node name (else quit): <i>x</i>
    x is not a source node name in the graph

  Enter some starting node name (else quit): <i>a</i>
  From a the reachable nodes are set[a,c,b,f,e,d,g]

  Enter some starting node name (else quit): <i>quit</i></pre></b>
</td>
</tbody>
</table>


<!-- Problem #2 -->

<a name="problem6">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>#2: Instant Runoff Voting<br>(14 pts)</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
<ul>
<li> Write a program that prompts the user to enter the name of
       a file representing the candidate preferences of a sequence of voters.
<li>Read the information in the file, storing it in a <b>Map</b>.
<li>Print the voter preferences.
<li>Repeatedly display the vote count for ballots (sorted both by candidate
      and numerically), eliminating from the election the candidate(s)
      receiving the fewest votes, until one candidate (the winner) or no
      candidates (a tie) remain.
</ul>
This form of election is known as <b>instant runoff voting</b>.
Every voter submits a ballot that ranks all the candidates in an election, from
  most favorite candidate to least favorite (we will use a <b>Queue</b>
  for this purpose</b>: earlier candidates in the <b>Queue</b> are more
  favored than later candidates).
<p>
During the first ballot, votes are counted for each of the candidates according
  to the rankings of the voters.
Then the candidate(s) with the fewest number of votes are removed from the
  election: if more than one candidate receives the least number of votes, all
  candidates receiving these least number of votes are removed from the
  election.
<p>
During the second ballot, votes are tallied for the <b>remaining candidates</b>
  (there are at least 1 fewer candidates); if a voter's first ranked candidate
  is not still in the  election, then his/her second ranked candidate should
  receive the vote; but if his/her second ranked candidate has been removed
  from the election, then his/her third ranked candidate should receive the
  vote ...).
<p>
This ballot process continues until either 1 candidate remains, or 0 candidates
  remain (meaning that all the remaining candidates from the previous ballot
  tallied the same number of votes).
Note that the preferences <b>Map</b> never changes, but how it is intepreted
  (which candidate gets the vote) does change, since the intepretation is based
  on which candidates remain in the election.
<h3>Input and Output</h3>
Read a file of voters and their ranking of the candidates, separated
  by semicolons, building a <b>Map</b> whose key is each voter and whose
  value is a <b>Queue</b> of candidates ranked by that voter (they appear in the
  file in order, from most favorite to least favorite).
<p>

For example, the input file <b>votepref1.txt</b> contains the following
  lines (which could appear in this order, or any other):
<b><pre>  A;X;Y;Z
  B;Y;Z;X
  C;Y;Z;X
  D;Z;Y;X
  E;Z;Y;X</pre></b>
The first line means, voter <b>A</b> ranks candidate <b>X</b> first,
  candidate <b>Y</b> second, and candidate <b>Z</b> third.
The second line means, voter <b>B</b> ranks candidate <b>Y</b> first,
  candidate <b>Z</b> second, and candidate <b>X</b> third.
Each line will have a unique voter and a permutation of all the 
  candidates running.
<p>
Print all the associations in this <b>Map</b>, one per line (the voters are
  printed alphabetically) using the following form.
Each line contains the voter and his/her complete ranking of the candidates.
For example, the file above would produce:
<b><pre>  Voter name -> queue[Preferences]
    A -> queue[X,Y,Z]:rear
    B -> queue[Y,Z,X]:rear
    C -> queue[Y,Z,X]:rear
    D -> queue[Z,Y,X]:rear
    E -> queue[Z,Y,X]:rear</pre></b>
<p>
Note that the voter names are <b>sorted</b> alphabetically, but the <b>Queue</b>
  of preferences appears in the same order they appeared in the file.
There are multiple data files for this program: <b>votepref1.txt</b>, 
  <b>votepref2.txt</b>, <b>votepref3.txt</b>, and <b>votepref4.txt</b>;
  test/debug your program on the first file; when you are done, test it on the
  rest.
<p>
Start with all the candidates.
Evaluate the ballot to determine how many votes each candidate received.
Print this vote count two ways: sorted alphabetically and sorted numerically
  (in decreasing order: if more than one candidate receives the same number of
   votes, they should appear sorted alphabetically).
Remove the candidate(s) receiving the fewest votes, and repeat this process
  until only one or no candidates remain.
Finally, print the outcome of the election: a single candidate winner or a tie.
An example interaction (processing the preferences above) might be
<b><pre>  Vote count on ballot #1: candidates (alphabetically ordered) with remaining candidates = set[X,Y,Z]
    X -> 1
    Y -> 2
    Z -> 2
  
  Vote count on ballot #1: candidates (numerically ordered) with remaining candidates = set[X,Y,Z]
    Y -> 2
    Z -> 2
    X -> 1

  Vote count on ballot #2: candidates (alphabetically ordered) with remaining candidates = set[Y,Z]
    Y -> 3
    Z -> 2

  Vote count on ballot #2: candidates (numerically ordered) with remaining candidates = set[Y,Z]
    Y -> 3
    Z -> 2

Winner is Y</pre></b>
The first ballot consisted of all three candidates, <b>X</b>, <b>Y</b>, 
  and <b>Z</b>.
For this ballot, the votes were counted and printed; candidate <b>X</b>
  received the fewest number of votes so is eliminated from the next ballot.
The second ballot consisted of two candidates, <b>Y</b> and <b>Z</b>.
For this ballot, the votes were counted and printed; candidate <b>Z</b>
  received the fewest number of votes so is eliminated from the next ballot.
There is only one candidate remaining so <b>Y</b> is declared the winner.
An alternative outcome prints
<b>Not any unique winner: election is a tie among all the candidates remaining on the last ballot</b>

<h3>Functions and Program</h3>
Write the following functions and <b>main</b> program.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written C++ code.
<ul>
<li><b>read_voter_preferences</b> has an (open) file parameter; it returns the
       <b>Map</b> representing each voter and his/her preferences
      (mine is 14 lines of well-formatted code).
<p>
<li><b>print_voter_preferences</b> has a <b>Map</b> of voter preferences as a
         parameter and returns nothing;
         it prints the title followed by the <b>Map</b> whose keys are in
         alphabetical order
       (mine is 7 lines of well-formatted code).
<p>
<li><b>print_tally</b> has a <b>std::string</b> title, a <b>Map</b> of
         candidates and their number of votes, and a
         function pointer as parameters and returns nothing; it
         prints the title followed by the <b>Map</b> in the appropriate order
         order (specified  by the function pointer)
       (mine is 7 lines of well-formatted code).
<p>
<li><b>evaluate_ballot</b> has a <b>Map</b> of voter preferences and a
         <b>Set</b> of the remaining candidates as parameters; it returns
         a tally: a <b>Map</b> whose keys are these candidates and whose values
         are the number of votes they received on this ballot, based on the
         description of <b>instant runnoff voting</b>
       Remember to count only one vote per voter, for his/her highest ranked
         candidate who is still in the election
      (mine is 12 lines of well-formatted code).
<p>
<li><b>remaining_candidates</b> has a <b>Map</b> as a parameter whose keys are
          candidates and whose values are the number of votes they received and
          returns a set containing all those candidates remaining in the
          election (the one(s) receiving the fewest number of votes are absent).
       Note that if all the candidates receive the same number of votes, then
         this function returns an empty <b>Set</b>
       (mine is 11 lines of well-formatted code).
<p>
<li>Write a <b>main</b> function at the bottom of this file that calls these
      functions to solve the problem
    (mine is 34 lines of well-formatted code).
   To simplify the interaction, you may prompt for the file name and specify
      a default value (<b>votepref1.txt</b>): see my <b>safe_open</b>
      function in <b>ics46goody.hpp</b> in the <b>courselib/src</b> folder.
</ul>
<h3>Sample Interaction</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<pre><b>  Enter some voter preferences file name[votepref1.txt]:

  Voter name -> queue[Preferences]
    A -> queue[X,Y,Z]:rear
    B -> queue[Y,Z,X]:rear
    C -> queue[Y,Z,X]:rear
    D -> queue[Z,Y,X]:rear
    E -> queue[Z,Y,X]:rear

  Vote count on ballot #1: candidates (alphabetically ordered) with remaining candidates = set[X,Y,Z]
    X -> 1
    Y -> 2
    Z -> 2
  
  Vote count on ballot #1: candidates (numerically ordered) with remaining candidates = set[X,Y,Z]
    Y -> 2
    Z -> 2
    X -> 1

  Vote count on ballot #2: candidates (alphabetically ordered) with remaining candidates = set[Y,Z]
    Y -> 3
    Z -> 2

  Vote count on ballot #2: candidates (numerically ordered) with remaining candidates = set[Y,Z]
    Y -> 3
    Z -> 2

  Winner is Y</pre></b>
<p>
You can also try processing the <b>votepref2.txt</b> file (which leads to
  printing
  <b>Not any unique winner: election is a tie among all the candidates remaining on the last ballot</b> result), <b>votepref3.text</b>, and <b>votepref4.txt</b>.
</td>
</tbody>
</table>



<!-- Problem 3 -->

<a name="problem3">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>#3: Finite Automata<br>(14 pts)</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
<ul>
<li>Write a program that prompts the user to enter the name of
       a file representing a finite automaton: indicating its <b>states</b> and
       <b>transitions</b> (each transition out of a state specifies the
       <b>input</b> and the new <b>state</b>).
<li>Read the information in the file, storing it in a <b>Map</b>.
<li>Print the finite automaton.
<li>Prompt the user to enter the name of a file storing the start-state
      and inputs to process (each line in the file contains this combination).
<li>Repeatedly process these lines computing the results of the finite
      automaton on each input, and then display a trace of the results.
</ul>
A <b>finite  automaton</b> (FA) is an machine that is sometimes called
  Deterministic Finite Automaton (DFA).
An FA is described by its <b>states</b> and its <b>transitions</b>:
  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what
  new <b>state</b> in the FA that input leads to.
We can illustrate a FA as a graph with labelled edges (see below).
<p>

<h3>Input and Output</h3>
Read a file that describes a FA: each line contains a state and an
  arbitrary number of input-&gt;new state <b>transitions</b>.
Build a <b>Map</b> such that each key is a <b>std::string</b> state and whose
   associated value is another <b>Map</b> specifying of the transitions from
   that state: this second <b>Map</b> has keys that are <b>std::string</b>
   inputs and associated values that are <b>std::string</b> states.
The first token on each line is the <b>std::string</b> state and the remaining
  tokens (always coming in pairs) are <b>std::string</b> inputs and states.
All tokens are separated by one semicolon character.
<p>

For example, the input file <b>faparity.txt</b> contains the following lines
  (which could appear in this order, or any other):
<b><pre>  even;0;even;1;odd
  odd;0;odd;1;even</pre></b>
Here is a picture of the <b>parity</b> FA.
It graphically illustrates the two <b>states</b> (<b>even</b> and <b>odd</b>)
  and their <b>transitions</b>, using <b>inputs</b> (<b>0</b> and <b>1</b>)
  that always lead back to one of these two states.
<p>

<img src="images/parity.jpg"></img>
<p>

Here, the state <b>even</b> (meaning it has seen an even number of <b>1</b>
  inputs so far) is a key in the main <b>Map</b>.
It's value is a <b>Map</b> with two key/value pairs <b>0</b>/<b>even</b>
  and <b>1</b>/<b>odd</b>.
It means that in the <b>even</b> state, if the input is a <b>0</b> the
  FA stays in the <b>even</b> state; if the input is a <b>1</b> the
  FA goes to the <b>odd</b> state.
And similarly (the next line) means that for the <b>odd</b> state, if the input
  is a <b>0</b> the FA stays in the <b>odd</b> state; if the input is a
  <b>1</b> the FA goes back to the <b>even</b> state.
So, seeing an input of <b>0</b> keeps the FA in the same state;
  seeing an input of <b>1</b> flips the FA into the other state.
<p>

Print the finite automaton, one state (and its transitions) per line;
  the states are printed alphabetically.
<p>
For example, the file above would produce:
<b><pre>  The Finite Automaton Description
    even transitions: map[0->even,1->odd]
    odd transitions: map[0->odd,1->even]</pre></b>
<p>
Note that there are multiple data files for this program: <b>faparity.txt</b>
  and <b>fadivisibleby3.txt</b>; test/debug your program on 
  the first file; when you are done, test it on the last file.
Draw the FA represented by each for to ensure that your code correctly
  prints and computes with it.
<p>
Repeatedly process lines from a second input file, computing the results of the
  finite automaton for a start-state and its inputs; then print out all the
  results in a special form.
Each line in the file contains a start-state followed by a sequence of inputs.
The start-state will be a state in the FA (is a key in the outer <b>Map</b>)
  the inputs may specify legal or illegal transitions (may or may not be keys
  in some inner <b>Map</b>).
<p>
For example, the input file <b>fainputparity.txt</b> contains the following
  three lines:
<b><pre>  even;1;0;1;1;0;1
  odd;1;0;1;1;0;1
  even;1;0;1;1;0;x</pre></b>
The first line means, the start-state is <b>even</b> and the
  inputs are <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.
<p>
The result of processing each line is to print the start-state, and then each
  input and the new state it transitions to, and finally print the stop-state.
For the <b>parity</b> FA and the first line in this file, it should print
<b><pre>Start state = even
  input = 1; new state = odd
  input = 0; new state = odd
  input = 1; new state = even
  input = 1; new state = odd
  input = 0; new state = odd
  input = 1; new state = even
Stop state = even</pre></b>
<p>

<h3>Functions and Program</h3>
Write the following functions and <b>main</b> program.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written C++ code.
<ul>
<li><b>read_fa</b> has an (open) file parameter; it returns the <b>Map</b>
     representing the finite automaton
     (mine is 17 lines  of well-formatted code).
<p>
<li><b>print_fa</b> has a <b>Map</b> parameter (representing the fa); it
    returns nothing,  but it prints the fa in the appropriate form
     (mine is 6 lines  of well-formatted code).
<p>
<li><b>process</b> has a <b>Map</b> parameter (representing the fa),
    a <b>std::string</b> parameter (representing the start-state), and a
    <b>Queue</b> parameter (representing a <b>Queue</b> of <b>std::string</b>
    inputs); it returns a <b>Queue</b> that contains <b>pair</b>s of
    <b>std::string</b> that show the input and resulting state after each
    transition (the first value on the <b>Queue</b> has an input that is an
    empty string and the start state).
    For the example shown above, <b>process</b> returns the following
    <b>Queue</b>.
<b><pre>queue[pair[,even],pair[1,odd],pair[0,odd],pair[1,even],pair[1,odd],pair[0,odd],pair[1,even]]:rear</pre></b>
    Finally, if an input is illegal (is not the key in some transition for the
    current state), say
    <b>"x"</b>, then <b>process</b> should terminate with the last
    <b>pair</b> in the <b>Queue</b> indicating a problem: <b>(x, None)</b>
   (mine is 13 lines  of well-formatted code).
<p>
<li><b>interpret</b> has a <b>Queue</b> parameter (the result produced by the
    <b>process</b> function described above); it returns nothing, but it prints
    the results of processing a fa on an input.
    See how it prints the <b>Queue</b> shown above in the output further above.
    Also see the <b>Sample Interaction</b> below to see how it prints
    <i>input errors</i> (in the last example)
   (mine is 13 lines  of well-formatted code).
<p>
<li>Write a <b>main</b> function at the bottom of this file that calls these
      functions to solve the problem.
      Note that the program loops over the lines in the second file
       (mine is 23 lines  of well-formatted code).
    To simplify the interaction, you may prompt for the file name and specify
      a default value (<b>faparity.txt</b> and <b>fainputparity.txt</b>): see
      my <b>safe_open</b> function in <b>ics46goody.hpp</b> in the
      <b>courselib/src</b> folder.
</ul>
<p>

<h3>Sample Interaction</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<b><pre>  Enter some finite automaton file name[faparity.txt]:
  The Finite Automaton Description
    even transitions: map[0->even,1->odd]
    odd transitions: map[0->odd,1->even]

  Enter some file name with start-state and inputs[fainputparity.txt]:
  
  Starting up a new simulation with description: even;1;0;1;1;0;1
  Start state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
  Stop state = even
  
  Starting up a new simulation with description: odd;1;0;1;1;0;1
  Start state = odd
    Input = 1; new state = even
    Input = 0; new state = even
    Input = 1; new state = odd
    Input = 1; new state = even
    Input = 0; new state = even
    Input = 1; new state = odd
  Stop state = odd
  
  Starting up a new simulation with description: even;1;0;1;1;0;x
  Start state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = x; illegal input: simulation terminated
  Stop state = None</b></pre>
<p>
You can also try the <b>fadivisibleby3.txt</b> finite automaton file, which
  determines whether an integer (sequence of digits) is divisible by 3: it is
  if the finite automaton stops in state <b>rem0</b> (which stand for <b>has
  remainder 0</b>).
Its input file is <b>fainputdivisibleby3.txt</b>, which represents the 
  number <b>12,435,711</b>, which is divisible by <b>3</b>, followed by the
  number <b>823</b>, which is not divisible by <b>3</b> (it has a remainder of
  <b>1</b> when divided by <b>3</b>).
</td>
</tbody>
</table>


<!-- Problem 4 -->

<a name="problem4">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>#4: Non-Deterministic FA<br>(10 pts)</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
<li> Write a program that solves for a Non-Deterministic Finite
       Automaton the same problem that was solved for a Deterministic Finite
       Automaton in Problem #3 (above).
<p>
A non-deterministic finite automaton (NDFA) is machine described by its
  <b>states</b> and its <b>transitions</b>:
  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what
  <b>state</b> (or <b>states</b>: that what makes it non-deterministic) that
  input leads to.
We can illustrate an NDFA as a graph with labelled edges (see below).
The critical difference is that an NDFA can have multiple edges with the same
  label going to different states (we'll see how to handle such transitions
  below).
<p>

<h3>Input and Output</h3>
Read a file that describes an NDFA: each line contains a state and an
  arbitrary number of input-&gt;state <b>transitions</b>.
Build a <b>Map</b> such that each key is a <b>std::string</b> state and whose
   value is another <b>Map</b> specifying of the transitions from that state:
   this second <b>Map</b> has keys that are <b>std::string</b> inputs and 
   values are <b>Sets</b> of <b>std::string</b> states: all the states a
   particular input can lead to.
The first token on each line is the <b>std::string</b> state and the remaining
  tokens (always coming in pairs) are <b>std::string</b> inputs and states:
here the same input can appear multiple times with different states following.
All tokens are separated by one semicolon character.
<p>

For example, the input file <b>ndfaendin01.txt</b> contains the following lines
  (which could appear in this order, or any other):
<b><pre>  start;0;start;1;start;0;near
  near;1;end
  end</pre></b>
Here is a picture of the <b>endin01</b> NDFA.
It graphically illustrates the three <b>states</b> (<b>start</b>, <b>near</b>,
  and <b>end</b>) and their <b>transitions</b>, using <b>inputs</b> (<b>0</b>
  and <b>1</b>).
<p>

<img src="images/endin01.jpg"></img>
<p>

Here, the state <b>start</b> is a key in the main <b>Map</b>.
It's value is a <b>Map</b> with two key/value pairs <b>0</b> mapping to the
  <b>Set</b> containing <b>start</b> and <b>near</b> and <b>1</b> mapping to
  the <b>Set</b> containing just <b>start</b>.
It means that in the <b>start</b> state, if the input is a <b>0</b> the
  NDFA can stay in the <b>start</b> state or it can go to the <b>near</b>
  state; if the input is a <b>1</b> the NDFA must stay in the <b>start</b>
  state.
And similarly the next line means that in the <b>near</b> state, if the
  input is a <b>1</b> the NDFA must go into the <b>end</b> state.
The last line means that the <b>end</b> state has no transitions out of it.
<p>

Print the NDFA, one state (and its transitions) per line;
  the states are printed alphabetically and the transition <b>Map</b>
  for each state is printed in the form of a standard <b>Map</b>: a series in
  the form <b>input -> set of states</b>.
Note that the state <b>end</b> is a key in the main <b>Map</b>, whose
  associated transitions are an empty <b>Map</b>.
<p>

For example, the file above would produce:
<b><pre>  The Non-Deterministic Finite Automaton Description
    end transitions: map[]
    near transitions: map[1->set[end]]
    start transitions: map[0->set[start,near],1->set[start]]</pre></b>
<p>
Note that there are multiple data files for this program:
  <b>ndfaendin01.txt</b>, <b>ndfatrain.txt.txt</b>, and <b>ndfare.txt</b>;
  test/debug your program on the first file; when you are done, test it on the
  rest.
Draw the NDFA represented by each for to ensure that your code correctly
  prints and computes with it.
<p>
Repeatedly process lines from a second matching input file
 (<b>ndfainputendin01.txt</b> for the example above), computing the results of
  the non-determinisitc finite automaton for a start-state and its inputs; then
  print out all the results in a special form.
Each line in the file contains a start-state followed by a sequence of inputs.
The start-state will be a state in the DNFA (is a key in the outer <b>Map</b)
  the inputs specify transitions (which may or may not be keys in some inner
  <b>Map</b>).
<p>
For example, the input file <b>ndfainputendin01.txt</b> contains the following
  two lines:
<b><pre>  start;1;0;1;1;0;1
  start;1;0;1;1;0;0</pre></b>
For example, the first line means, the start-state is <b>start</b> and the
  inputs <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.
<p>

The result of processing each line is to print the start-state, and then each
  input and the new states (plural) it could transition to (the <b>could</b>
  is what makes it non-deterministic), and finally print the stop-states.
For the <b>ndfaendin01</b> NDFA and the first line in this file, it should print
<b><pre>  Start state = set[start]
    Input = 1; new possible states = set[start]
    Input = 0; new possible states = set[start,near]
    Input = 1; new possible states = set[start,end]
    Input = 1; new possible states = set[start]
    Input = 0; new possible states = set[start,near]
    Input = 1; new possible states = set[start,end]
  Stop state(s) = set[start,end]</pre></b>
<p>

Note especially that in the <b>start</b> state, if the input is a <b>0</b>,
  then the NDFA can either remain in the <b>start</b> state or go into the
  <b>near</b> state.
For this program, we keep track of all states that the NDFA can be in,
  using a <b>set</b> of <b>new possible states</b>.
For the next input, <b>1</b>, we can be either in the <b>start</b> state
  (from the <b>start</b> state, an input of <b>1</b> allows us to stay in the
  <b>start</b> state) or the <b>end</b> state (from the <b>near</b> state, an
  input of <b>1</b> allows us to transition to the <b>end</b> state).
Thus, we keep track of the <b>set</b> of states the NDFA can be in, and the
  new <b>set</b> of states the NDFA can be in after processing the next input
  for each of these states.
In this example, because <b>end</b> is included in the stop-states, this
  input does end in <b>01</b>.
<p>
<h3>Functions and Program</h3>
Write the following functions and <b>main</b> program.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written C++ code.
<ul>
<li><b>read_ndfa</b> has an open (file) parameter; it returns the <b>Map</b>
     representing the non-deterministic finite automaton; <b>hint</b>: I used
     a <b>while</b> loop to read lines and a nested <b>for</b> loop to construct
     the <b>Map</b> storing each input and the <b>Set</b> of states it can lead
     to (mine is 17 lines of well-formatted code).
<p>
<li><b>print_ndfa</b> has a <b>Map</b> parameter (representing the NDFA); it
    returns nothing,  but it prints the NDFA in the appropriate form
     (mine is 6 lines of well-formatted code).
<p>
<li><b>process</b> has a <b>Map</b> parameter (representing the NDFA),
    a <b>std::string</b> parameter (representing the start-state), and a
    <b>Queue</b> parameter (representing the sequence of <b>std::string</b>
    inputs); it returns a <b>Queue</b> that contains <b>pair</b>s of 
    inputs and the resulting states after each transition.
    For the example shown above, <b>process</b> returns the following
    <b>Queue</b>.
<b><pre>  queue[pair[,set[start]],pair[1,set[start]],pair[0,set[start,near]],pair[1,set[start,end]],
        pair[1,set[start]],pair[0,set[start,near]],pair[1,set[start,end]]]:rear</pre></b>
    Finally, if an input is illegal (is not the key in some transition for the
    current state), just ignore it
   (mine is 13 lines of well-formatted code).
<p>
<li><b>interpret</b> has a <b>Queue</b> parameter (the result produced by
    <b>process</b>; it returns nothing, but it prints the results of processing
    an NDFA on an input.
    See how it prints the <b>Queue</b> shown above in the output further above
   (mine is 10 lines of well-formatted code).
<p>    
<li>Write a <b>main</b> function at the bottom of this file that calls these
      functions to solve the problem.
    Note that this function loops over the lines in the second file
   (mine is 23 lines of well-formatted code).
</ul>
<p>

<h3>Sample Interaction</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should "match" this one (recall the order of values in sets is
  not important).
<b><pre>  Enter some non-deterministic finite automaton file name[ndfaendin01.txt]:
  The Non-Deterministic Finite Automaton Description
    end transitions: map[]
    near transitions: map[1->set[end]]
    start transitions: map[0->set[start,near],1->set[start]]

  Enter some file name with start-state and inputs[ndfainputendin01.txt]: 

  Starting up new simulation with description: start;1;0;1;1;0;1
  Start state = set[start]
    Input = 1; new possible states = set[start]
    Input = 0; new possible states = set[start,near]
    Input = 1; new possible states = set[start,end]
    Input = 1; new possible states = set[start]
    Input = 0; new possible states = set[start,near]
    Input = 1; new possible states = set[start,end]
  Stop state(s) = set[start,end]

  Starting up a new simulation with description: start;1;0;1;1;0;0
  Start state = set[start]
    Input = 1; new possible states = set[start]
    Input = 0; new possible states = set[start,near]
    Input = 1; new possible states = set[start,end]
    Input = 1; new possible states = set[start]
    Input = 0; new possible states = set[start,near]
    Input = 0; new possible states = set[start,near]
  Stop state(s) = set[start,near]</pre></b>
<p>
The <b>ndfatrain.txt</b> file is a non-deterministic finite automaton
  that determines whether an train (sequence of characters representing
  different kinds of cars) is a legal train according to Chapter Exercise #7
  in the ENBF lecture from ICS-33..
Its input file is <b>ndfainputtrain.txt</b>, whose first input represents a
  legal train: ends when <b>done</b> is one possible stopping state; and second
  input represents an illegal train.
<p>
The <b>ndfare.txt</b> file is a non-deterministic finite automaton translation
  of the regular expression <b>((a*|b)cd)+</b>. 
Its input file is <b>ndfainputre.txt</b>, whose first input represents a
  matching string: ends when <b>last</b> as one possible stopping state; and
  input second does not
  match.
</td>
</tbody>
</table>
  

<!-- Problem #5 New for Winter 2016

<a name="problem5">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>#5: Google Queries<br>(8 pts)</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
<ul>
<li> Write a program that prompts the user to enter the name of a file of text
       representing a sequence of multiple-word (full) Google queries.
<li>Read the file of text, storing its information special <b>prefix</b> and
      <b>query</b> <b>Map</b>s.
<li>Print the <b>prefix Map</b> and <b>query Map</b>.
<li>Repeatedly prompt the user to enter any prefix query and the <b>top n</b> 
      full queries to print, then print the <b>n</b> most frequehnt full
      queries with that prefix.
</ul>
<p>
<h3>Background:</h3>
When we type a word (or a few words) into Google's query box, it shows some of
  the most frequently entered queries starting with those word(s).
For example, when I recently typed the word <b>uci</b> into Google, it showed
  the following as the 3 most frequent queries starting with <b>uci</b>:
<ul>
<li><b>uci law</b>
<li><b>uci medical center</b>
<li><b>uci women's soccer</b>
</ul>
I could have clicked on one of these queries to select it, or continued typing
  more words to specify my own (different) query.
<p>
Here we say <b>uci</b> is a <b>prefix</b>, which is the beginning of some
  <b>full query</b>, like <b>uci medical center</b>.
<p>
Google represents a <b>full query</b> as a <b>queue</b> of <b>std::string</b>
  (words).
For example, <b>queue[uci,medical,center]:rear</b> is a <b>full query</b>.
Google also represents a <b>prefix</b> as a <b>queue</b> of <b>std::string</b>
  (words).
For example, <b>queue[uci]:rear</b> is a one-word <b>prefix</b> and
  <b>queue[uci,medical]:rear</b> is a two-word <b>prefix</b> of this
  <b>full query</b>.
<p>
From any <b>full query</b> we can compute a <b>set</b> of all its
  <b>prefix</b>es.
For example, the <b>full query</b> <b>queue[uci,medical,center]:rear</b>
  would compute the <b>prefix set</b>
  <b>set[queue[uci]:rear,queue[uci,medical]:rear,queue[uci,medical,center]:rear]</b>.
The <b>prefix set</b> includes a <b>queue</b> of the first word, 
  a <b>queue</b> of the first two words, ...
  and finally a <b>queue</b> of all the words in the <b>full query</b>.
<p>
Google stores information (in maps) that allows it to predict the most
  likely <b>full query</b> from any <b>prefix</b> the user enters in the
  Google search box (as discussed in the example above).
The prediction is based on (1) knowing all the <b>full queries</b> for a
  <b>prefix</b> and (2) knowing how many times each <b>full query</b> was
  used.
Using this information, Google can show the user the most frequently
  entered <b>full queries</b> for the <b>prefix</b> he/she typed.
<p>
Google stores two maps to accomplish this task.
<ol>
<li>Google stores a <b>prefix</b> map whose <b>key</b> is a
  <b>prefix</b> (a <b>queue</b> of <b>std::string</b>) and whose <b>associated
  value</b> is a <b>set</b> of <b>queue</b>: all the <b>full queries</b> that
  have been entered for that <b>prefix</b>.
<p>
<li>Google stores a <b>query</b> map whose <b>key</b> is a
  <b>full query</b> (again a <b>queue</b> of <b>std::string</b>) and whose
  <b>associated value</b> is an <b>int</b>: the number of times (the frequency)
  that that <b>full query</b> was used.
</ol>
<p>
In this program you will build these maps and then use them it to
  predict a <b>full query</b> from a <b>prefix</b> entered by the user, and
  update the maps for any new query.
<p>
<h3>Input and Output:</h3>
After prompting the user for the file of full queries, read the file, building
  the <b>prefix</b> and <b>query</b> mapss (we are dropping the word
  <b>full</b> now).
<p>
For a simple example, the file <b>googleq0.txt</b> contains the following
  lines (in it, for simplicity and conciseness, we abbreviated
  b = basketball, c = center, l = law, m = medical, s = soccer,  u = uci, and
  w = women's).
<b><pre>  u m c
  u l
  u w s
  u l
  u  s
  u w b
  u w b
  u w b</pre></b>
<p>
The program will first read this file and build the appropriate <b>prefix</b>
  and <b>query</b> map; then it will print each map.
The <b>prefix</b> map should be sorted by keys, from the shortest to
  longest prefix, with equal-length prefixes sorted in standard lexical order;
  of course the associated sets may print their values in any order.
The <b>query</b> map should be sorted by associated values (integers),
  from largest to smallest integer, with equal integers sorted by their keys in
  standard lexical order.
<p>
For example, the file above would produce the following output:
<b><pre>  Prefix map:
    queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]
    queue[u,l]:rear -> set[queue[u,l]:rear]
    queue[u,m]:rear -> set[queue[u,m,c]:rear]
    queue[u,m,c]:rear -> set[queue[u,m,c]:rear]
    queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]
    queue[u,w,b]:rear -> set[queue[u,w,b]:rear]
    queue[u,w,s]:rear -> set[queue[u,w,s]:rear]

  Query map:
    queue[u,w,b]:rear -> 3
    queue[u,l]:rear -> 2
    queue[u,w,s]:rear -> 2
    queue[u,m,c]:rear -> 1</pre></b>
<p>
In the <b>prefix</b> map <b>queue[u]:rear</b> appears before
  <b>queue[u,l]:rearl</b> because it has fewer words; and
  <b>queue[u,l]:rear</b> appears before <b>queue[u,w]:rear</b>
  because in standard lexical order, when 2-queues have equal
  first values, they are ordered by their second values, and <b>l</b> comes
  before <b>w</b>.
<p>
In the <b>query</b> map <b>queue[u,w,b]</b> appears before
  <b>queue[u,l]:rear</b> because the first queues associated value
  (<b>3</b>) is bigger than the second queue's (<b>2</b>); and
  <b>queue[u,l]:rear</b> appears before <b>queue[u,w,s]:rear</b>
  because when queues are associated with equal values (<b>2</b>), they are
  ordered lexically, and <b>queue[u,l,...]:rear</b>
  comes before  <b>queue[u,w,...)</b> (see the reasoning above).
<p>
Now, repeatedly prompt the user for any query prefix (and <b>n</b>, for the
  <b>top n</b> to print) and print the <b>top n</b> full queries for the
  entered prefix: print them in in a priority queue ordered from most to least
  frequent full query (with ties printed using the standard lexical ordering;
  the same ordering used when printing the Query map above).
Using the maps above the iteraction would be.
<p>
<pre><b>  Enter a prefix (or quit): u
  Enter n (as in "top n" to print)[3]: 2
    Top 2 (at most) full queries = priority_queue[pair[queue[u,l]:rear,2],pair[queue[u,w,b]:rear,3]]:highest]</b></pre>
Finally, prompt the user to enter the full query, and update the maps and 
  reprint them.
<pre><b>  Enter a full query (or quit): u w s

  Prefix map:
    queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]
    queue[u,l]:rear -> set[queue[u,l]:rear]
    queue[u,m]:rear -> set[queue[u,m,c]:rear]
    queue[u,m,c]:rear -> set[queue[u,m,c]:rear]
    queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]
    queue[u,w,b]:rear -> set[queue[u,w,b]:rear]
    queue[u,w,s]:rear -> set[queue[u,w,s]:rear]

  Query map:
    queue[u,w,b]:rear -> 3
    queue[u,w,s]:rear -> 3
    queue[u,l]:rear -> 2
    queue[u,m,c]:rear -> 1</b></pre>
Here, the prefix map stays the same (the full query already was entered
  once; we could have entered a new full query, which would augment the prefix
  dictionary), and the full query <b>query[u,w,s)</b> has its query-count
  increased from <b>2</b> to <b>3</b>.
<p>

<h3>Functions and Program:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>all_prefixes</b> has a <b>Queue</b> of <b>std::string</b>
         (words) parameter; it returns a <b>Set</b> of <b>Queue</b> of
         <b>std::string</b>: all the <b>prefixes</b> of the <b>full query</b>
         argument.
       For example, <b>all_prefixes(ArrayQueue({"a","b","c"))</b> returns
         <b>set[queue[a],queue[a,b],queue[a,b,c]]</b>.
       <b>Hints:</b> comprehension and slicing
       (mine is 9 lines of well-formatted code).
<p>
<li><b>add_query</b> has a prefix map, query map, and full query
         as parameters; it returns nothing, but it updates these two map based
         on the full query.
       It adds the new query's prefixes to the prefix map (each associated
          with the full query) and increments the integer value associated with
          that full query in the query map (or, if the full query is
           new, associates that query with 1)
       (mine is 5 lines of well-formatted code).
<p>
<li><b>read_queries</b> has an (open) file, prefix map, and a query map as
         parameters; it returns nothing, but it updates these two map based on
         reading and processing each full query in this file
       (mine is 8 lines of well-formatted code).
<p>
<li><b>print_prefix</b> has a <b>Map</b> parameter;  it
    returns nothing, but it prints the prefix map in the appropriate form
   (mine is 7 lines of well-formatted code + the <b>prefix_gt</b> function).
   Note: my <b>prefix_gt</b> function calls <b>word_queue_gt</b>.
<p>
<li><b>print_query</b> has a <b>Map</b> parameter; it
    returns nothing, but it prints the query map in the appropriate form
   (mine is 7 lines of well-formatted code + the <b>query_gt</b> function).
   Note: my <b>query_gt</b> function also calls <b>word_queue_gt</b>.
<p>
<li><b>top_n</b> has a prefix (<b>queue</b> of <b>std::string</b>), <b>int</b>,
        prefix map, and query map as parameters; it returns a
        <b>PriorityQueue</b> of query pairs (<b>queue</b> of <b>std::str</b>
        associated with <b>int</b>) whose length is the integer parameter,
        containing the most frequent full queries with that
        prefix; if the number of full queries with that prefix is less than
         that integer parameter, return all the full queries.
    If no full queries have this prefix, return the empty list.
    Notes: The maps should not be changed.
           If multiple full queries occur the same number of times, prefer
      the full queries that come earlier in the standard lexical ordering: e.g.,
      the same order they are printed in the query map
   (mine is 11 lines of well-formatted code).
<p>     
<li>Write a <b>main</b> function at the bottom of this file that calls these
      functions to solve the problem
   (mine is 25 lines of well-formatted code).
</ul>
<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match the form of this one (the order of values in the sets
  may vary).
<pre><b>
Enter query file name[googleq0.txt]: 

Prefix map:
  queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]
  queue[u,l]:rear -> set[queue[u,l]:rear]
  queue[u,m]:rear -> set[queue[u,m,c]:rear]
  queue[u,m,c]:rear -> set[queue[u,m,c]:rear]
  queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]
  queue[u,w,b]:rear -> set[queue[u,w,b]:rear]
  queue[u,w,s]:rear -> set[queue[u,w,s]:rear]

Query map:
  queue[u,w,b]:rear -> 3
  queue[u,l]:rear -> 2
  queue[u,w,s]:rear -> 2
  queue[u,m,c]:rear -> 1

Enter a prefix (or quit): <i>u</i>
Enter n (as in "top n" to print)[3]: <i>2</i>
Top 3 (at most) full queries = priority_queue[pair[queue[u,l]:rear,2],pair[queue[u,w,b]:rear,3]]:highest

Enter a full query (or quit): <i>u w s</i>

Prefix map:
  queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]
  queue[u,l]:rear -> set[queue[u,l]:rear]
  queue[u,m]:rear -> set[queue[u,m,c]:rear]
  queue[u,m,c]:rear -> set[queue[u,m,c]:rear]
  queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]
  queue[u,w,b]:rear -> set[queue[u,w,b]:rear]
  queue[u,w,s]:rear -> set[queue[u,w,s]:rear]

Query map:
  queue[u,w,b]:rear -> 3
  queue[u,w,s]:rear -> 3
  queue[u,l]:rear -> 2
  queue[u,m,c]:rear -> 1

Enter a prefix (or quit): <i>u w</i>
Enter n (as in "top n" to print)[3]: <i>2</i>
  Top 2 (at most) full queries = priority_queue[pair[queue[u,w,s]:rear,3],pair[queue[u,w,b]:rear,3]]:highest

Enter a full query (or quit): <i>a b c</i>

Prefix map:
  queue[a]:rear -> set[queue[a,b,c]:rear]
  queue[a,b]:rear -> set[queue[a,b,c]:rear]
  queue[a,b,c]:rear -> set[queue[a,b,c]:rear]
  queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]
  queue[u,l]:rear -> set[queue[u,l]:rear]
  queue[u,m]:rear -> set[queue[u,m,c]:rear]
  queue[u,m,c]:rear -> set[queue[u,m,c]:rear]
  queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]
  queue[u,w,b]:rear -> set[queue[u,w,b]:rear]
  queue[u,w,s]:rear -> set[queue[u,w,s]:rear]

Query map:
  queue[u,w,b]:rear -> 3
  queue[u,w,s]:rear -> 3
  queue[u,l]:rear -> 2
  queue[a,b,c]:rear -> 1
  queue[u,m,c]:rear -> 1

Enter a prefix (or quit): <i>quit</i></b></pre>
<p>
You can also try processing the <b>googleq1.txt</b> and <b>googleq2.txt</b>
  files
</td>
</tbody>
</table>
---->

<!-- Problem #5 -->

<a name="problem5">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>#5: Word Generator<br>(8 pts)</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
<ul>
<li> Write a program that prompts the user to enter the <b>order statistic</b>
  (a positive number) and the name of a file of text.
<li>Read the file of text, storing a special <b>corpus</b> in a <b>Map</b>.
<li>Print the <b>corpus Map</b>.
<li>Prompt the user to enter the order statistic number of words,
      and the number of random words to generate, then print the original words
      followed by the words randomly generated from the <b>corpus</b>.
</ul>
Your program will "learn" the word pattern of an author (based on some
  "order statistic" and reading a large sample of the author's writing) and
  then generate random text following the author's word patterns.
<p>
<h3>Input and Output</h3>
After prompting for the order statistic, read a file of words, building a
  <b>Map</b>.
Here the <b>Map</b>'s keys are <b>Queues</b>s of <b>n</b> words (<b>n</b>
  is the order statistic</b>) and each key's value is a <b>Set</b> of all the
  words in the text that ever follow these <b>n</b> words:
  e.g., if <b>n</b> were <b>2</b>, the <b>Map</b> would contain a keys that are
  <b>Queue</b>s of 2 words (for every pair of words appearing next to each
  other in the text) and whose values are a <b>Set</b> of all the words
  following the key (no matter where the pair occurs in the text; the <b>Set</b>
  stores no duplicate words).
<p>
The easiest way to process the words one at a time is to use an outer loop
  reading lines of text and an inner loop scanning all the words when the line
  is split using a space character.
To process a new word, if the <b>Queue</b> doesn't have <b>n</b> words, just
  enqueue the word; if the <b>Queue</b> has <b>n</b> words, use it as a key and
  put the new word in its associated <b>Set</b>, then dequeue the first word
  and enqueue the new word (so the <b>Queue</b> will still contain <b>n</b>
  words).
<p>
For a simple example, the file <b>wginput1.txt</b> contains the following
  lines (it could have all this information on one line or more lines):
<b><pre>  a b c b a d c b a d
  c a a b a a d</pre></b>
  
<p>
Print all the associations in the <b>Map</b>, one per line in standard lexical
  order.
<p>
After printing all associations, print the size of the smallest and largest
  <b>Set</b> that is a value in the <b>Map</b>.
Each line contains an <b>n</b> word <b>Queue</b>, followed by the <b>Set</b>
   of unique words that follow them in the text.
In standard lexical order, the keys appear in order relative to the first word 
  in the <b>Queue</b> (alphabetically); for all first words that are the same,
  they appear in order relative to the second word in the <b>Queue</b>
  (alphabetically); for all first and second words that are the same, they 
 appear in order relative to the third word in the <b>Queue</b>; etc.
  (see the example below, for an order statistic of 2).
<p>
For example, the file above would produce:
<b><pre>  Corpus had 8 Entries
    queue[a,a]:rear -> set[b,d]
    queue[a,b]:rear -> set[c,a]
    queue[a,d]:rear -> set[c]
    queue[b,a]:rear -> set[d,a]
    queue[b,c]:rear -> set[b]
    queue[c,a]:rear -> set[a]
    queue[c,b]:rear -> set[a]
    queue[d,c]:rear -> set[b,a]
  Corpus had 8 Entries
  max/min = 2/1</pre></b>
<p>
For example, <b>queue[a,d]:end</b> appears three times in the text above, twice
  followed by <b>c</b> and once followed by nothing (at the end of the file);
  <b>queue[a,b]:end</b> appears twice in the file above, first followed by
  <b>c</b> and second followed by <b>a</b>.
<p>

Prompt the user for the words to start with (there are order statistic number
  of them; they must be in some <b>Queue</b> that is a key in the
  <b>corpus</b>) and the number of random words after that to generate.
Produce the list of all words and print it. 
<p>
A random 10 word list, after the words <b>a</b> and <b>d</b> might
  print as
<pre><b>    Random text = queue[a,d,c,a,a,b,a,d,c,b,a,d]:rear</b></pre>
In the result we start with <b>a d</b> (specified by the user), we
  know only <b>c</b> can come next; then using <b>d c</b> we know that
  either <b>b</b> or <b>a</b> must come next; it randomly chooses <b>a</b>...
<p>

<h3>Functions and Program</h3>
Write the following functions and <b>main</b> program.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written C++ code.
<ul>
<li><b>read_corpus</b> has an order statistic parameter and and open (file)
     parameter; it returns the <b>Map</b> representing the corpus of
     words in a file
    (mine is 17 lines of well-formatted code).
<p>
<li><b>print_corpus</b> has a <b>Map</b> parameter (representing the corpus);
     it returns nothing, but it prints the corpus in the appropriate form
     followed the min and max value <b>Set</b> sizes
     (mine is 13 lines of well-formatted code + the <b>queue_gt</b> function).
<p>
<li><b>produce_text</b> has a <b>Map</b> parameter (representing the corpus),
    a <b>Queue</b> parameter (representing the starting words), and an
    <b>int</b> parameter (representing the number of random words to generate);
    it returns a <b>Queue</b> that contains the the starting words followed by
    the generated words
     (mine is 15 lines of well-formatted code).

    <p>
    <b>Hint</b>: use two <b>Queue</b>s of words, both starting out with the
       starting words.
    The first will always contain the current <b>n</b> words to be used as a
      key in the <b>Map</b>); the second will contain all the generated words.
    Generate a random next word from the <b>Map</b> using the
      <b>random_in_set</b> function that I wrote in this file; then 
      drop the first word from the <b>Queue</b> and add the generated word, so
      it remains a <b>Queue</b> of size <b>n</b>; repeat until you have
      generated the required number of words.
    <p>
    <b>Warning</b>: you might have to stop prematurely if you generate the last
      <b>n</b> words in the text, and if these words occur nowhere else.
    That is because in this case, there is no random word to generate following
      them; in this case add a <b>"None"</b> to the end of the <b>Queue</b>
      of words and immediately return that <b>Queue</b>
    (mine is 14 lines of well-formatted code).
<p>
<li>Write a <b>main</b> function at the bottom of this file that calls these
      functions to solve the problem
   (mine is 21 lines of well-formatted code).
</ul>
<h3>Sample Interaction</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<pre><b>  Enter some order statistic[2]: 
  Enter some file name to process[wginput1.txt]: 

  Corpus had 8 Entries
    queue[a,a]:rear -> set[b,d]
    queue[a,b]:rear -> set[c,a]
    queue[a,d]:rear -> set[c]
    queue[b,a]:rear -> set[d,a]
    queue[b,c]:rear -> set[b]
    queue[c,a]:rear -> set[a]
    queue[c,b]:rear -> set[a]
    queue[d,c]:rear -> set[b,a]
  Corpus had 8 Entries
  max/min = 2/1

  Enter 2 words for starting
  Enter word 1: <i>a</i>
  Enter word 2: <i>d</i>
  Enter # of words to generate: <i>10</i>
  Random text = queue[a,d,c,a,a,b,a,d,c,b,a,d]:rear</b></pre>
<p>
The <b>wginput2.txt</b> file cannot be used to generate a large number of
  random words for the reason explained in the <b>Warning</b> above.
<p>
With the appropriate modification, we can use this same program to
  read/generate music or DNA sequences or any other data made of repeated
  symbols.
</td>
</tbody>
</table>


</tbody>
</table>
</html>
