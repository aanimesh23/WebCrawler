<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0049)http://www.ics.uci.edu/~lchen/ics156/tcpdump.html -->
<HTML><HEAD><TITLE>Manpage of TCPDUMP</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<META content="MSHTML 5.00.2920.0" name=GENERATOR></HEAD>
<BODY>Content-type: text/html 
<H1>TCPDUMP</H1>Section: Maintenance Commands (8)<BR>Updated: 30 June 1997<BR><A 
href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#index">Index</A> <A 
href="http://localhost/cgi-bin/man/man2html">Return to Main Contents</A>
<HR>
 <A name=lbAB>&nbsp;</A> 
<H2>NAME</H2>tcpdump - dump traffic on a network <A name=lbAC>&nbsp;</A> 
<H2>SYNOPSIS</H2><B>tcpdump</B> [ <B>-adeflnNOpqStvx</B> ] [ <B>-c</B> 
<I>count</I> ] [ <B>-F</B> <I>file</I> ] 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ <B>-i</B> 
<I>interface</I> ] [ <B>-r</B> <I>file</I> ] [ <B>-s</B> <I>snaplen</I> ] 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ <B>-T</B> <I>type</I> 
] [ <B>-w</B> <I>file</I> ] [ <I>expression</I> ] <BR><A name=lbAD>&nbsp;</A> 
<H2>DESCRIPTION</H2>
<P><I>Tcpdump</I> prints out the headers of packets on a network interface that 
match the boolean <I>expression</I>. 
<P><B>Under SunOS with nit or bpf:</B> To run <I>tcpdump</I> you must have read 
access to <I>/dev/nit</I> or <I>/dev/bpf*</I>. <B>Under Solaris with dlpi:</B> 
You must have read access to the network pseudo device, e.g. <I>/dev/le</I>. 
<B>Under HP-UX with dlpi:</B> You must be root or it must be installed setuid to 
root. <B>Under IRIX with snoop:</B> You must be root or it must be installed 
setuid to root. <B>Under Linux:</B> You must be root or it must be installed 
setuid to root. <B>Under Ultrix and Digital UNIX:</B> Once the super-user has 
enabled promiscuous-mode operation using <I><A 
href="http://localhost/cgi-bin/man/man2html?8+pfconfig">pfconfig</A></I>(8), any 
user may run <B>tcpdump</B>. <B>Under BSD:</B> You must have read access to 
<I>/dev/bpf*</I>. <A name=lbAE>&nbsp;</A> 
<H2>OPTIONS</H2>
<DL compact>
  <DT><B>-a</B> 
  <DD>Attempt to convert network and broadcast addresses to names. 
  <DT><B>-c</B> 
  <DD>Exit after receiving <I>count</I> packets. 
  <DT><B>-d</B> 
  <DD>Dump the compiled packet-matching code in a human readable form to 
  standard output and stop. 
  <DT><B>-dd</B> 
  <DD>Dump packet-matching code as a <B>C</B> program fragment. 
  <DT><B>-ddd</B> 
  <DD>Dump packet-matching code as decimal numbers (preceded with a count). 
  <DT><B>-e</B> 
  <DD>Print the link-level header on each dump line. 
  <DT><B>-f</B> 
  <DD>Print `foreign' internet addresses numerically rather than symbolically 
  (this option is intended to get around serious brain damage in Sun's yp server 
  --- usually it hangs forever translating non-local internet numbers). 
  <DT><B>-F</B> 
  <DD>Use <I>file</I> as input for the filter expression. An additional 
  expression given on the command line is ignored. 
  <DT><B>-i</B> 
  <DD>Listen on <I>interface</I>. If unspecified, <I>tcpdump</I> searches the 
  system interface list for the lowest numbered, configured up interface 
  (excluding loopback). Ties are broken by choosing the earliest match. 
  <DT><B>-l</B> 
  <DD>Make stdout line buffered. Useful if you want to see the data while 
  capturing it. E.g., <BR>``tcpdump&nbsp;&nbsp;-l&nbsp;&nbsp;|&nbsp;&nbsp;tee 
  dat'' or ``tcpdump&nbsp;&nbsp;-l &nbsp;&nbsp;&gt; 
  dat&nbsp;&nbsp;&amp;&nbsp;&nbsp;tail&nbsp;&nbsp;-f&nbsp;&nbsp;dat''. 
  <DT><B>-n</B> 
  <DD>Don't convert addresses (i.e., host addresses, port numbers, etc.) to 
  names. 
  <DT><B>-N</B> 
  <DD>Don't print domain name qualification of host names. E.g., if you give 
  this flag then <I>tcpdump</I> will print ``nic'' instead of ``nic.ddn.mil''. 
  <DT><B>-O</B> 
  <DD>Do not run the packet-matching code optimizer. This is useful only if you 
  suspect a bug in the optimizer. 
  <DT><B>-p</B> 
  <DD><I>Don't</I> put the interface into promiscuous mode. Note that the 
  interface might be in promiscuous mode for some other reason; hence, `-p' 
  cannot be used as an abbreviation for `ether host {local-hw-addr} or ether 
  broadcast'. 
  <DT><B>-q</B> 
  <DD>Quick (quiet?) output. Print less protocol information so output lines are 
  shorter. 
  <DT><B>-r</B> 
  <DD>Read packets from <I>file</I> (which was created with the -w option). 
  Standard input is used if <I>file</I> is ``-''. 
  <DT><B>-s</B> 
  <DD>Snarf <I>snaplen</I> bytes of data from each packet rather than the 
  default of 68 (with SunOS's NIT, the minimum is actually 96). 68 bytes is 
  adequate for IP, ICMP, TCP and UDP but may truncate protocol information from 
  name server and NFS packets (see below). Packets truncated because of a 
  limited snapshot are indicated in the output with ``[|<I>proto</I>]'', where 
  <I>proto</I> is the name of the protocol level at which the truncation has 
  occurred. Note that taking larger snapshots both increases the amount of time 
  it takes to process packets and, effectively, decreases the amount of packet 
  buffering. This may cause packets to be lost. You should limit <I>snaplen</I> 
  to the smallest number that will capture the protocol information you're 
  interested in. 
  <DT><B>-T</B> 
  <DD>Force packets selected by "<I>expression</I>" to be interpreted the 
  specified <I>type</I>. Currently known types are <B>rpc</B> (Remote Procedure 
  Call), <B>rtp</B> (Real-Time Applications protocol), <B>rtcp</B> (Real-Time 
  Applications control protocol), <B>vat</B> (Visual Audio Tool), <B>wb</B> 
  (distributed White Board), and <B>snmp</B> (Simple Network Management 
  Protocol). 
  <DT><B>-S</B> 
  <DD>Print absolute, rather than relative, TCP sequence numbers. 
  <DT><B>-t</B> 
  <DD><I>Don't</I> print a timestamp on each dump line. 
  <DT><B>-tt</B> 
  <DD>Print an unformatted timestamp on each dump line. 
  <DT><B>-v</B> 
  <DD>(Slightly more) verbose output. For example, the time to live and type of 
  service information in an IP packet is printed. 
  <DT><B>-vv</B> 
  <DD>Even more verbose output. For example, additional fields are printed from 
  NFS reply packets. 
  <DT><B>-w</B> 
  <DD>Write the raw packets to <I>file</I> rather than parsing and printing them 
  out. They can later be printed with the -r option. Standard output is used if 
  <I>file</I> is ``-''. 
  <DT><B>-x</B> 
  <DD>Print each packet (minus its link level header) in hex. The smaller of the 
  entire packet or <I>snaplen</I> bytes will be printed. 
  <DT><I>expression</I>
  <DD>
  <DL compact>
    <DT>
    <DD>selects which packets will be dumped. If no <I>expression</I> is given, 
    all packets on the net will be dumped. Otherwise, only packets for which 
    <I>expression</I> is `true' will be dumped. 
    <P>The <I>expression</I> consists of one or more <I>primitives.</I> 
    Primitives usually consist of an <I>id</I> (name or number) preceded by one 
    or more qualifiers. There are three different kinds of qualifier: 
    <DL compact>
      <DT><I>type</I>
      <DD>qualifiers say what kind of thing the id name or number refers to. 
      Possible types are <B>host</B>, <B>net</B> and <B>port</B>. E.g., `host 
      foo', `net 128.3', `port 20'. If there is no type qualifier, <B>host</B> 
      is assumed. 
      <DT><I>dir</I>
      <DD>qualifiers specify a particular transfer direction to and/or from 
      <I>id.</I> Possible directions are <B>src</B>, <B>dst</B>, <B>src or 
      dst</B> and <B>src and</B> <B>dst</B>. E.g., `src foo', `dst net 128.3', 
      `src or dst port ftp-data'. If there is no dir qualifier, <B>src or 
      dst</B> is assumed. For `null' link layers (i.e. point to point protocols 
      such as slip) the <B>inbound</B> and <B>outbound</B> qualifiers can be 
      used to specify a desired direction. 
      <DT><I>proto</I>
      <DD>qualifiers restrict the match to a particular protocol. Possible 
      protos are: <B>ether</B>, <B>fddi</B>, <B>ip</B>, <B>arp</B>, <B>rarp</B>, 
      <B>decnet</B>, <B>lat</B>, <B>sca</B>, <B>moprc</B>, <B>mopdl</B>, 
      <B>tcp</B> and <B>udp</B>. E.g., `ether src foo', `arp net 128.3', `tcp 
      port 21'. If there is no proto qualifier, all protocols consistent with 
      the type are assumed. E.g., `src foo' means `(ip or arp or rarp) src foo' 
      (except the latter is not legal syntax), `net bar' means `(ip or arp or 
      rarp) net bar' and `port 53' means `(tcp or udp) port 53'. </DD></DL>
    <P>[`fddi' is actually an alias for `ether'; the parser treats them 
    identically as meaning ``the data link level used on the specified network 
    interface.'' FDDI headers contain Ethernet-like source and destination 
    addresses, and often contain Ethernet-like packet types, so you can filter 
    on these FDDI fields just as with the analogous Ethernet fields. FDDI 
    headers also contain other fields, but you cannot name them explicitly in a 
    filter expression.] 
    <P>In addition to the above, there are some special `primitive' keywords 
    that don't follow the pattern: <B>gateway</B>, <B>broadcast</B>, 
    <B>less</B>, <B>greater</B> and arithmetic expressions. All of these are 
    described below. 
    <P>More complex filter expressions are built up by using the words 
    <B>and</B>, <B>or</B> and <B>not</B> to combine primitives. E.g., `host foo 
    and not port ftp and not port ftp-data'. To save typing, identical qualifier 
    lists can be omitted. E.g., `tcp dst port ftp or ftp-data or domain' is 
    exactly the same as `tcp dst port ftp or tcp dst port ftp-data or tcp dst 
    port domain'. 
    <P>Allowable primitives are: 
    <DL compact>
      <DT><B>dst host </B><I>host</I>
      <DD>True if the IP destination field of the packet is <I>host</I>, which 
      may be either an address or a name. 
      <DT><B>src host </B><I>host</I>
      <DD>True if the IP source field of the packet is <I>host</I>. 
      <DT><B>host </B><I>host</I>
      <DD>True if either the IP source or destination of the packet is 
      <I>host</I>. Any of the above host expressions can be prepended with the 
      keywords, <B>ip</B>, <B>arp</B>, or <B>rarp</B> as in: <PRE><B>ip host </B><I>host</I>
</PRE>which is equivalent to: <PRE><B>ether proto </B><I>\ip</I><B> and host </B><I>host</I>
</PRE>If <I>host</I> is a name with multiple IP addresses, each address 
      will be checked for a match. 
      <DT><B>ether dst </B><I>ehost</I>
      <DD>True if the ethernet destination address is <I>ehost</I>. <I>Ehost</I> 
      may be either a name from /etc/ethers or a number (see <I><A 
      href="http://localhost/cgi-bin/man/man2html?3N+ethers">ethers</A></I>(3N) 
      for numeric format). 
      <DT><B>ether src </B><I>ehost</I>
      <DD>True if the ethernet source address is <I>ehost</I>. 
      <DT><B>ether host </B><I>ehost</I>
      <DD>True if either the ethernet source or destination address is 
      <I>ehost</I>. 
      <DT><B>gateway</B> <I>host</I>
      <DD>True if the packet used <I>host</I> as a gateway. I.e., the ethernet 
      source or destination address was <I>host</I> but neither the IP source 
      nor the IP destination was <I>host</I>. <I>Host</I> must be a name and 
      must be found in both /etc/hosts and /etc/ethers. (An equivalent 
      expression is <PRE><B>ether host </B><I>ehost </I><B>and not host </B><I>host</I>
</PRE>which can be used with either names or numbers for <I>host / 
      ehost</I>.) 
      <DT><B>dst net </B><I>net</I>
      <DD>True if the IP destination address of the packet has a network number 
      of <I>net</I>. <I>Net</I> may be either a name from /etc/networks or a 
      network number (see <I><A 
      href="http://localhost/cgi-bin/man/man2html?4+networks">networks</A>(4)</I> 
      for details). 
      <DT><B>src net </B><I>net</I>
      <DD>True if the IP source address of the packet has a network number of 
      <I>net</I>. 
      <DT><B>net </B><I>net</I>
      <DD>True if either the IP source or destination address of the packet has 
      a network number of <I>net</I>. 
      <DT><B>net </B><I>net</I> <B>mask </B><I>mask</I>
      <DD>True if the IP address matches <I>net</I> with the specific netmask. 
      May be qualified with <B>src</B> or <B>dst</B>. 
      <DT><B>net </B><I>net</I>/<I>len</I>
      <DD>True if the IP address matches <I>net</I> a netmask <I>len</I> bits 
      wide. May be qualified with <B>src</B> or <B>dst</B>. 
      <DT><B>dst port </B><I>port</I>
      <DD>True if the packet is ip/tcp or ip/udp and has a destination port 
      value of <I>port</I>. The <I>port</I> can be a number or a name used in 
      /etc/services (see <I><A 
      href="http://localhost/cgi-bin/man/man2html?4P+tcp">tcp</A></I>(4P) and 
      <I><A 
      href="http://localhost/cgi-bin/man/man2html?4P+udp">udp</A></I>(4P)). If a 
      name is used, both the port number and protocol are checked. If a number 
      or ambiguous name is used, only the port number is checked (e.g., <B>dst 
      port 513</B> will print both tcp/login traffic and udp/who traffic, and 
      <B>port domain</B> will print both tcp/domain and udp/domain traffic). 
      <DT><B>src port </B><I>port</I>
      <DD>True if the packet has a source port value of <I>port</I>. 
      <DT><B>port </B><I>port</I>
      <DD>True if either the source or destination port of the packet is 
      <I>port</I>. Any of the above port expressions can be prepended with the 
      keywords, <B>tcp</B> or <B>udp</B>, as in: <PRE><B>tcp src port </B><I>port</I>
</PRE>which matches only tcp packets whose source port is <I>port</I>. 
      <DT><B>less </B><I>length</I>
      <DD>True if the packet has a length less than or equal to <I>length</I>. 
      This is equivalent to: <PRE><B>len &lt;= </B><I>length</I>.
</PRE>
      <DT><B>greater </B><I>length</I>
      <DD>True if the packet has a length greater than or equal to 
      <I>length</I>. This is equivalent to: <PRE><B>len &gt;= </B><I>length</I>.
</PRE>
      <DT><B>ip proto </B><I>protocol</I>
      <DD>True if the packet is an ip packet (see <I><A 
      href="http://localhost/cgi-bin/man/man2html?4P+ip">ip</A></I>(4P)) of 
      protocol type <I>protocol</I>. <I>Protocol</I> can be a number or one of 
      the names <I>icmp</I>, <I>igrp</I>, <I>udp</I>, <I>nd</I>, or <I>tcp</I>. 
      Note that the identifiers <I>tcp</I>, <I>udp</I>, and <I>icmp</I> are also 
      keywords and must be escaped via backslash (\), which is \\ in the 
      C-shell. 
      <DT><B>ether broadcast</B>
      <DD>True if the packet is an ethernet broadcast packet. The <I>ether</I> 
      keyword is optional. 
      <DT><B>ip broadcast</B>
      <DD>True if the packet is an IP broadcast packet. It checks for both the 
      all-zeroes and all-ones broadcast conventions, and looks up the local 
      subnet mask. 
      <DT><B>ether multicast</B>
      <DD>True if the packet is an ethernet multicast packet. The <I>ether</I> 
      keyword is optional. This is shorthand for `<B>ether[0] &amp; 1 != 0</B>'. 

      <DT><B>ip multicast</B>
      <DD>True if the packet is an IP multicast packet. 
      <DT><B>ether proto </B><I>protocol</I>
      <DD>True if the packet is of ether type <I>protocol</I>. <I>Protocol</I> 
      can be a number or a name like <I>ip</I>, <I>arp</I>, or <I>rarp</I>. Note 
      these identifiers are also keywords and must be escaped via backslash (\). 
      [In the case of FDDI (e.g., `<B>fddi protocol arp</B>'), the protocol 
      identification comes from the 802.2 Logical Link Control (LLC) header, 
      which is usually layered on top of the FDDI header. <I>Tcpdump</I> 
      assumes, when filtering on the protocol identifier, that all FDDI packets 
      include an LLC header, and that the LLC header is in so-called SNAP 
      format.] 
      <DT><B>decnet src </B><I>host</I>
      <DD>True if the DECNET source address is <I>host</I>, which may be an 
      address of the form ``10.123'', or a DECNET host name. [DECNET host name 
      support is only available on Ultrix systems that are configured to run 
      DECNET.] 
      <DT><B>decnet dst </B><I>host</I>
      <DD>True if the DECNET destination address is <I>host</I>. 
      <DT><B>decnet host </B><I>host</I>
      <DD>True if either the DECNET source or destination address is 
      <I>host</I>. 
      <DT><B>ip</B>, <B>arp</B>, <B>rarp</B>, <B>decnet</B>
      <DD>Abbreviations for: <PRE><B>ether proto </B><I>p</I>
</PRE>where <I>p</I> is one of the above protocols. 
      <DT><B>lat</B>, <B>moprc</B>, <B>mopdl</B>
      <DD>Abbreviations for: <PRE><B>ether proto </B><I>p</I>
</PRE>where <I>p</I> is one of the above protocols. Note that 
      <I>tcpdump</I> does not currently know how to parse these protocols. 
      <DT><B>tcp</B>, <B>udp</B>, <B>icmp</B>
      <DD>Abbreviations for: <PRE><B>ip proto </B><I>p</I>
</PRE>where <I>p</I> is one of the above protocols. 
      <DT><I>expr relop expr</I>
      <DD>True if the relation holds, where <I>relop</I> is one of &gt;, &lt;, 
      &gt;=, &lt;=, =, !=, and <I>expr</I> is an arithmetic expression composed 
      of integer constants (expressed in standard C syntax), the normal binary 
      operators [+, -, *, /, &amp;, |], a length operator, and special packet 
      data accessors. To access data inside the packet, use the following 
      syntax: <PRE><I>proto</I><B> [ </B><I>expr</I><B> : </B><I>size</I><B> ]</B>
</PRE><I>Proto</I> is one of <B>ether, fddi, ip, arp, rarp, tcp, udp, 
      </B>or <B>icmp</B>, and indicates the protocol layer for the index 
      operation. The byte offset, relative to the indicated protocol layer, is 
      given by <I>expr</I>. <I>Size</I> is optional and indicates the number of 
      bytes in the field of interest; it can be either one, two, or four, and 
      defaults to one. The length operator, indicated by the keyword <B>len</B>, 
      gives the length of the packet. 
      <P>For example, `<B>ether[0] &amp; 1 != 0</B>' catches all multicast 
      traffic. The expression `<B>ip[0] &amp; 0xf != 5</B>' catches all IP 
      packets with options. The expression `<B>ip[6:2] &amp; 0x1fff = 0</B>' 
      catches only unfragmented datagrams and frag zero of fragmented datagrams. 
      This check is implicitly applied to the <B>tcp</B> and <B>udp</B> index 
      operations. For instance, <B>tcp[0]</B> always means the first byte of the 
      TCP <I>header</I>, and never means the first byte of an intervening 
      fragment. </P></DD></DL>
    <P>Primitives may be combined using: 
    <DL compact>
      <DT>
      <DD>A parenthesized group of primitives and operators (parentheses are 
      special to the Shell and must be escaped). 
      <DT>
      <DD>Negation (`<B>!</B>' or `<B>not</B>'). 
      <DT>
      <DD>Concatenation (`<B>&amp;&amp;</B>' or `<B>and</B>'). 
      <DT>
      <DD>Alternation (`<B>||</B>' or `<B>or</B>'). </DD></DL>
    <P>Negation has highest precedence. Alternation and concatenation have equal 
    precedence and associate left to right. Note that explicit <B>and</B> 
    tokens, not juxtaposition, are now required for concatenation. 
    <P>If an identifier is given without a keyword, the most recent keyword is 
    assumed. For example, <PRE><B>not host vs and ace</B>
</PRE>is short for <PRE><B>not host vs and host ace</B>
</PRE>which should not be confused with <PRE><B>not ( host vs or ace )</B>
</PRE>
    <P>Expression arguments can be passed to tcpdump as either a single argument 
    or as multiple arguments, whichever is more convenient. Generally, if the 
    expression contains Shell metacharacters, it is easier to pass it as a 
    single, quoted argument. Multiple arguments are concatenated with spaces 
    before being parsed. </P></DD></DL></DD></DL><A name=lbAF>&nbsp;</A> 
<H2>EXAMPLES</H2>
<P>To print all packets arriving at or departing from <I>sundown</I>: 
<DL compact>
  <DT>
  <DD><PRE><B>tcpdump host sundown</B>
</PRE></DD></DL>
<P>To print traffic between <I>helios</I> and either <I>hot</I> or <I>ace</I>: 
<DL compact>
  <DT>
  <DD><PRE><B>tcpdump host helios and \( hot or ace \)</B>
</PRE></DD></DL>
<P>To print all IP packets between <I>ace</I> and any host except <I>helios</I>: 

<DL compact>
  <DT>
  <DD><PRE><B>tcpdump ip host ace and not helios</B>
</PRE></DD></DL>
<P>To print all traffic between local hosts and hosts at Berkeley: 
<DL compact>
  <DT>
  <DD><PRE><B>tcpdump net ucb-ether</B>
</PRE></DD></DL>
<P>To print all ftp traffic through internet gateway <I>snup</I>: (note that the 
expression is quoted to prevent the shell from (mis-)interpreting the 
parentheses): 
<DL compact>
  <DT>
  <DD><PRE><B>tcpdump 'gateway snup and (port ftp or ftp-data)'</B>
</PRE></DD></DL>
<P>To print traffic neither sourced from nor destined for local hosts (if you 
gateway to one other net, this stuff should never make it onto your local net). 
<DL compact>
  <DT>
  <DD><PRE><B>tcpdump ip and not net </B><I>localnet</I>
</PRE></DD></DL>
<P>To print the start and end packets (the SYN and FIN packets) of each TCP 
conversation that involves a non-local host. 
<DL compact>
  <DT>
  <DD><PRE><B>tcpdump 'tcp[13] &amp; 3 != 0 and not src and dst net </B><I>localnet</I>'
</PRE></DD></DL>
<P>To print IP packets longer than 576 bytes sent through gateway <I>snup</I>: 
<DL compact>
  <DT>
  <DD><PRE><B>tcpdump 'gateway snup and ip[2:2] &gt; 576'</B>
</PRE></DD></DL>
<P>To print IP broadcast or multicast packets that were <I>not</I> sent via 
ethernet broadcast or multicast: 
<DL compact>
  <DT>
  <DD><PRE><B>tcpdump 'ether[0] &amp; 1 = 0 and ip[16] &gt;= 224'</B>
</PRE></DD></DL>
<P>To print all ICMP packets that are not echo requests/replies (i.e., not ping 
packets): 
<DL compact>
  <DT>
  <DD><PRE><B>tcpdump 'icmp[0] != 8 and icmp[0] != 0"</B>
</PRE></DD></DL><A name=lbAG>&nbsp;</A> 
<H2>OUTPUT FORMAT</H2>
<P>The output of <I>tcpdump</I> is protocol dependent. The following gives a 
brief description and examples of most of the formats. 
<P><B></B>Link Level Headers 
<P>If the '-e' option is given, the link level header is printed out. On 
ethernets, the source and destination addresses, protocol, and packet length are 
printed. 
<P>On FDDI networks, the '-e' option causes <I>tcpdump</I> to print the `frame 
control' field, the source and destination addresses, and the packet length. 
(The `frame control' field governs the interpretation of the rest of the packet. 
Normal packets (such as those containing IP datagrams) are `async' packets, with 
a priority value between 0 and 7; for example, `<B>async4</B>'. Such packets are 
assumed to contain an 802.2 Logical Link Control (LLC) packet; the LLC header is 
printed if it is <I>not</I> an ISO datagram or a so-called SNAP packet. 
<P><I>(N.B.: The following description assumes familiarity with the SLIP 
compression algorithm described in RFC-1144.)</I> 
<P>On SLIP links, a direction indicator (``I'' for inbound, ``O'' for outbound), 
packet type, and compression information are printed out. The packet type is 
printed first. The three types are <I>ip</I>, <I>utcp</I>, and <I>ctcp</I>. No 
further link information is printed for <I>ip</I> packets. For TCP packets, the 
connection identifier is printed following the type. If the packet is 
compressed, its encoded header is printed out. The special cases are printed out 
as <B>*S+</B><I>n</I> and <B>*SA+</B><I>n</I>, where <I>n</I> is the amount by 
which the sequence number (or sequence number and ack) has changed. If it is not 
a special case, zero or more changes are printed. A change is indicated by U 
(urgent pointer), W (window), A (ack), S (sequence number), and I (packet ID), 
followed by a delta (+n or -n), or a new value (=n). Finally, the amount of data 
in the packet and compressed header length are printed. 
<P>For example, the following line shows an outbound compressed TCP packet, with 
an implicit connection identifier; the ack has changed by 6, the sequence number 
by 49, and the packet ID by 6; there are 3 bytes of data and 6 bytes of 
compressed header: 
<DL compact>
  <DT>
  <DD><PRE><B>O ctcp * A+6 S+49 I+6 3 (6)</B>
</PRE></DD></DL>
<P><B></B>ARP/RARP Packets 
<P>Arp/rarp output shows the type of request and its arguments. The format is 
intended to be self explanatory. Here is a short sample taken from the start of 
an `rlogin' from host <I>rtsg</I> to host <I>csam</I>: 
<DL compact>
  <DT>
  <DD><PRE>
<TT>arp who-has csam tell rtsg
arp reply csam is-at CSAM</TT>

</PRE></DD></DL>The first line says that rtsg sent an arp packet asking for the 
ethernet address of internet host csam. Csam replies with its ethernet address 
(in this example, ethernet addresses are in caps and internet addresses in lower 
case). 
<P>This would look less redundant if we had done <B>tcpdump -n</B>: 
<DL compact>
  <DT>
  <DD><PRE>
<TT>arp who-has 128.3.254.6 tell 128.3.254.68
arp reply 128.3.254.6 is-at 02:07:01:00:01:c4</TT>
</PRE></DD></DL>
<P>If we had done <B>tcpdump -e</B>, the fact that the first packet is broadcast 
and the second is point-to-point would be visible: 
<DL compact>
  <DT>
  <DD><PRE>
<TT>RTSG Broadcast 0806  64: arp who-has csam tell rtsg
CSAM RTSG 0806  64: arp reply csam is-at CSAM</TT>

</PRE></DD></DL>For the first packet this says the ethernet source address is 
RTSG, the destination is the ethernet broadcast address, the type field 
contained hex 0806 (type ETHER_ARP) and the total length was 64 bytes. 
<P><B></B>TCP Packets 
<P><I>(N.B.:The following description assumes familiarity with the TCP protocol 
described in RFC-793. If you are not familiar with the protocol, neither this 
description nor tcpdump will be of much use to you.)</I> 
<P>The general format of a tcp protocol line is: 
<DL compact>
  <DT>
  <DD><PRE>
<I>src &gt; dst: flags data-seqno ack window urgent options</I>

</PRE></DD></DL><I>Src</I> and <I>dst</I> are the source and destination IP 
addresses and ports. <I>Flags</I> are some combination of S (SYN), F (FIN), P 
(PUSH) or R (RST) or a single `.' (no flags). <I>Data-seqno</I> describes the 
portion of sequence space covered by the data in this packet (see example 
below). <I>Ack</I> is sequence number of the next data expected the other 
direction on this connection. <I>Window</I> is the number of bytes of receive 
buffer space available the other direction on this connection. <I>Urg</I> 
indicates there is `urgent' data in the packet. <I>Options</I> are tcp options 
enclosed in angle brackets (e.g., &lt;mss 1024&gt;). 
<P><I>Src, dst</I> and <I>flags</I> are always present. The other fields depend 
on the contents of the packet's tcp protocol header and are output only if 
appropriate. 
<P>Here is the opening portion of an rlogin from host <I>rtsg</I> to host 
<I>csam</I>. 
<DL compact>
  <DT>
  <DD><PRE>
<FONT size=-2><TT>rtsg.1023 &gt; csam.login: S 768512:768512(0) win 4096 &lt;mss 1024&gt;
csam.login &gt; rtsg.1023: S 947648:947648(0) ack 768513 win 4096 &lt;mss 1024&gt;
rtsg.1023 &gt; csam.login: . ack 1 win 4096
rtsg.1023 &gt; csam.login: P 1:<A href="http://localhost/cgi-bin/man/man2html?1+2">2</A>(1) ack 1 win 4096
csam.login &gt; rtsg.1023: . ack 2 win 4096
rtsg.1023 &gt; csam.login: P 2:21(19) ack 1 win 4096
csam.login &gt; rtsg.1023: P 1:<A href="http://localhost/cgi-bin/man/man2html?1+2">2</A>(1) ack 21 win 4077
csam.login &gt; rtsg.1023: P 2:<A href="http://localhost/cgi-bin/man/man2html?1+3">3</A>(1) ack 21 win 4077 urg 1
csam.login &gt; rtsg.1023: P 3:<A href="http://localhost/cgi-bin/man/man2html?1+4">4</A>(1) ack 21 win 4077 urg 1</TT></FONT>

</PRE></DD></DL>The first line says that tcp port 1023 on rtsg sent a packet to 
port <I>login</I> on csam. The <B>S</B> indicates that the <I>SYN</I> flag was 
set. The packet sequence number was 768512 and it contained no data. (The 
notation is `first:last(nbytes)' which means `sequence numbers <I>first</I> up 
to but not including <I>last</I> which is <I>nbytes</I> bytes of user data'.) 
There was no piggy-backed ack, the available receive window was 4096 bytes and 
there was a max-segment-size option requesting an mss of 1024 bytes. 
<P>Csam replies with a similar packet except it includes a piggy-backed ack for 
rtsg's SYN. Rtsg then acks csam's SYN. The `.' means no flags were set. The 
packet contained no data so there is no data sequence number. Note that the ack 
sequence number is a small integer (1). The first time <B>tcpdump</B> sees a tcp 
`conversation', it prints the sequence number from the packet. On subsequent 
packets of the conversation, the difference between the current packet's 
sequence number and this initial sequence number is printed. This means that 
sequence numbers after the first can be interpreted as relative byte positions 
in the conversation's data stream (with the first data byte each direction being 
`1'). `-S' will override this feature, causing the original sequence numbers to 
be output. 
<P>On the 6th line, rtsg sends csam 19 bytes of data (bytes 2 through 20 in the 
rtsg -&gt; csam side of the conversation). The PUSH flag is set in the packet. 
On the 7th line, csam says it's received data sent by rtsg up to but not 
including byte 21. Most of this data is apparently sitting in the socket buffer 
since csam's receive window has gotten 19 bytes smaller. Csam also sends one 
byte of data to rtsg in this packet. On the 8th and 9th lines, csam sends two 
bytes of urgent, pushed data to rtsg. 
<P>If the snapshot was small enough that <B>tcpdump</B> didn't capture the full 
TCP header, it interprets as much of the header as it can and then reports 
``[|<I>tcp</I>]'' to indicate the remainder could not be interpreted. If the 
header contains a bogus option (one with a length that's either too small or 
beyond the end of the header), tcpdump reports it as ``[<I>bad opt</I>]'' and 
does not interpret any further options (since it's impossible to tell where they 
start). If the header length indicates options are present but the IP datagram 
length is not long enough for the options to actually be there, tcpdump reports 
it as ``[<I>bad hdr length</I>]''. 
<P><B></B><B>UDP Packets</B> 
<P>UDP format is illustrated by this rwho packet: 
<DL compact>
  <DT>
  <DD><PRE>
<TT>actinide.who &gt; broadcast.who: udp 84</TT>

</PRE></DD></DL>This says that port <I>who</I> on host <I>actinide</I> sent a 
udp datagram to port <I>who</I> on host <I>broadcast</I>, the Internet broadcast 
address. The packet contained 84 bytes of user data. 
<P>Some UDP services are recognized (from the source or destination port number) 
and the higher level protocol information printed. In particular, Domain Name 
service requests (RFC-1034/1035) and Sun RPC calls (RFC-1050) to NFS. 
<P><B></B>UDP Name Server Requests 
<P><I>(N.B.:The following description assumes familiarity with the Domain 
Service protocol described in RFC-1035. If you are not familiar with the 
protocol, the following description will appear to be written in greek.)</I> 
<P>Name server requests are formatted as 
<DL compact>
  <DT>
  <DD><PRE>
<I>src &gt; dst: id op? flags qtype qclass name (len)</I>

<TT>h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)</TT>

</PRE></DD></DL>Host <I>h2opolo</I> asked the domain server on <I>helios</I> for 
an address record (qtype=A) associated with the name <I>ucbvax.berkeley.edu.</I> 
The query id was `3'. The `+' indicates the <I>recursion desired</I> flag was 
set. The query length was 37 bytes, not including the UDP and IP protocol 
headers. The query operation was the normal one, <I>Query</I>, so the op field 
was omitted. If the op had been anything else, it would have been printed 
between the `3' and the `+'. Similarly, the qclass was the normal one, 
<I>C_IN</I>, and omitted. Any other qclass would have been printed immediately 
after the `A'. 
<P>A few anomalies are checked and may result in extra fields enclosed in square 
brackets: If a query contains an answer, name server or authority section, 
<I>ancount</I>, <I>nscount</I>, or <I>arcount</I> are printed as `[<I>n</I>a]', 
`[<I>n</I>n]' or `[<I>n</I>au]' where <I>n</I> is the appropriate count. If any 
of the response bits are set (AA, RA or rcode) or any of the `must be zero' bits 
are set in bytes two and three, `[b2&amp;3=<I>x</I>]' is printed, where <I>x</I> 
is the hex value of header bytes two and three. 
<P><B></B>UDP Name Server Responses 
<P>Name server responses are formatted as 
<DL compact>
  <DT>
  <DD><PRE>
<I>src &gt; dst:  id op rcode flags a/n/au type class data (len)</I>

<TT>helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)
helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)</TT>

</PRE></DD></DL>In the first example, <I>helios</I> responds to query id 3 from 
<I>h2opolo</I> with 3 answer records, 3 name server records and 7 authority 
records. The first answer record is type A (address) and its data is internet 
address 128.32.137.3. The total size of the response was 273 bytes, excluding 
UDP and IP headers. The op (Query) and response code (NoError) were omitted, as 
was the class (C_IN) of the A record. 
<P>In the second example, <I>helios</I> responds to query 2 with a response code 
of non-existent domain (NXDomain) with no answers, one name server and no 
authority records. The `*' indicates that the <I>authoritative answer</I> bit 
was set. Since there were no answers, no type, class or data were printed. 
<P>Other flag characters that might appear are `-' (recursion available, RA, 
<I>not</I> set) and `|' (truncated message, TC, set). If the `question' section 
doesn't contain exactly one entry, `[<I>n</I>q]' is printed. 
<P>Note that name server requests and responses tend to be large and the default 
<I>snaplen</I> of 68 bytes may not capture enough of the packet to print. Use 
the <B>-s</B> flag to increase the snaplen if you need to seriously investigate 
name server traffic. `<B>-s 128</B>' has worked well for me. 
<P>
<P><B></B>NFS Requests and Replies 
<P>Sun NFS (Network File System) requests and replies are printed as: 
<DL compact>
  <DT>
  <DD><PRE>
<I>src.xid &gt; dst.nfs: len op args</I>
<I>src.nfs &gt; dst.xid: reply stat len op results</I>

<TT>
sushi.6709 &gt; wrl.nfs: 112 readlink fh 21,24/10.73165
wrl.nfs &gt; sushi.6709: reply ok 40 readlink "../var"
sushi.201b &gt; wrl.nfs:
        144 lookup fh 9,74/4096.6878 "xcolors"
wrl.nfs &gt; sushi.201b:
        reply ok 128 lookup fh 9,74/4134.3150
</TT>

</PRE></DD></DL>In the first line, host <I>sushi</I> sends a transaction with id 
<I>6709</I> to <I>wrl</I> (note that the number following the src host is a 
transaction id, <I>not</I> the source port). The request was 112 bytes, 
excluding the UDP and IP headers. The operation was a <I>readlink</I> (read 
symbolic link) on file handle (<I>fh</I>) 21,24/10.731657119. (If one is lucky, 
as in this case, the file handle can be interpreted as a major,minor device 
number pair, followed by the inode number and generation number.) <I>Wrl</I> 
replies `ok' with the contents of the link. 
<P>In the third line, <I>sushi</I> asks <I>wrl</I> to lookup the name 
`<I>xcolors</I>' in directory file 9,74/4096.6878. Note that the data printed 
depends on the operation type. The format is intended to be self explanatory if 
read in conjunction with an NFS protocol spec. 
<P>If the -v (verbose) flag is given, additional information is printed. For 
example: 
<DL compact>
  <DT>
  <DD><PRE>
<TT>
sushi.1372a &gt; wrl.nfs:
        148 read fh 21,11/12.195 8192 bytes @ 24576
wrl.nfs &gt; sushi.1372a:
        reply ok 1472 read REG 100664 ids 417/0 sz 29388
</TT>

</PRE></DD></DL>(-v also prints the IP header TTL, ID, and fragmentation fields, 
which have been omitted from this example.) In the first line, <I>sushi</I> asks 
<I>wrl</I> to read 8192 bytes from file 21,11/12.195, at byte offset 24576. 
<I>Wrl</I> replies `ok'; the packet shown on the second line is the first 
fragment of the reply, and hence is only 1472 bytes long (the other bytes will 
follow in subsequent fragments, but these fragments do not have NFS or even UDP 
headers and so might not be printed, depending on the filter expression used). 
Because the -v flag is given, some of the file attributes (which are returned in 
addition to the file data) are printed: the file type (``REG'', for regular 
file), the file mode (in octal), the uid and gid, and the file size. 
<P>If the -v flag is given more than once, even more details are printed. 
<P>Note that NFS requests are very large and much of the detail won't be printed 
unless <I>snaplen</I> is increased. Try using `<B>-s 192</B>' to watch NFS 
traffic. 
<P>NFS reply packets do not explicitly identify the RPC operation. Instead, 
<I>tcpdump</I> keeps track of ``recent'' requests, and matches them to the 
replies using the transaction ID. If a reply does not closely follow the 
corresponding request, it might not be parsable. 
<P><B></B>KIP Appletalk (DDP in UDP) 
<P>Appletalk DDP packets encapsulated in UDP datagrams are de-encapsulated and 
dumped as DDP packets (i.e., all the UDP header information is discarded). The 
file <I>/etc/atalk.names</I> is used to translate appletalk net and node numbers 
to names. Lines in this file have the form 
<DL compact>
  <DT>
  <DD><PRE>
<I>number  name</I>

<TT>1.254           ether
16.1            icsd-net
1.254.110       ace</TT>

</PRE></DD></DL>The first two lines give the names of appletalk networks. The 
third line gives the name of a particular host (a host is distinguished from a 
net by the 3rd octet in the number - a net number <I>must</I> have two octets 
and a host number <I>must</I> have three octets.) The number and name should be 
separated by whitespace (blanks or tabs). The <I>/etc/atalk.names</I> file may 
contain blank lines or comment lines (lines starting with a `#'). 
<P>Appletalk addresses are printed in the form 
<DL compact>
  <DT>
  <DD><PRE>
<I>net.host.port</I>

<TT>144.1.209.2 &gt; icsd-net.112.220
office.2 &gt; icsd-net.112.220
jssmag.149.235 &gt; icsd-net.2</TT>

</PRE></DD></DL>(If the <I>/etc/atalk.names</I> doesn't exist or doesn't contain 
an entry for some appletalk host/net number, addresses are printed in numeric 
form.) In the first example, NBP (DDP port 2) on net 144.1 node 209 is sending 
to whatever is listening on port 220 of net icsd node 112. The second line is 
the same except the full name of the source node is known (`office'). The third 
line is a send from port 235 on net jssmag node 149 to broadcast on the icsd-net 
NBP port (note that the broadcast address (255) is indicated by a net name with 
no host number - for this reason it's a good idea to keep node names and net 
names distinct in /etc/atalk.names). 
<P>NBP (name binding protocol) and ATP (Appletalk transaction protocol) packets 
have their contents interpreted. Other protocols just dump the protocol name (or 
number if no name is registered for the protocol) and packet size. 
<P><B>NBP packets</B> are formatted like the following examples: 
<DL compact>
  <DT>
  <DD><PRE>
<FONT size=-2><TT>icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: "=:LaserWriter@*"
jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: "RM1140:LaserWriter@*" 250
techpit.2 &gt; icsd-net.112.220: nbp-reply 190: "techpit:LaserWriter@*" 186</TT></FONT>

</PRE></DD></DL>The first line is a name lookup request for laserwriters sent by 
net icsd host 112 and broadcast on net jssmag. The nbp id for the lookup is 190. 
The second line shows a reply for this request (note that it has the same id) 
from host jssmag.209 saying that it has a laserwriter resource named "RM1140" 
registered on port 250. The third line is another reply to the same request 
saying host techpit has laserwriter "techpit" registered on port 186. 
<P><B>ATP packet</B> formatting is demonstrated by the following example: 
<DL compact>
  <DT>
  <DD><PRE>
<FONT size=-2><TT>jssmag.209.165 &gt; helios.132: atp-req  12266&lt;0-7&gt; 0xae030001
helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000
jssmag.209.165 &gt; helios.132: atp-req  12266&lt;3,5&gt; 0xae030001
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
jssmag.209.165 &gt; helios.132: atp-rel  12266&lt;0-7&gt; 0xae030001
jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002</TT></FONT>

</PRE></DD></DL>Jssmag.209 initiates transaction id 12266 with host helios by 
requesting up to 8 packets (the `&lt;0-7&gt;'). The hex number at the end of the 
line is the value of the `userdata' field in the request. 
<P>Helios responds with 8 512-byte packets. The `:digit' following the 
transaction id gives the packet sequence number in the transaction and the 
number in parens is the amount of data in the packet, excluding the atp header. 
The `*' on packet 7 indicates that the EOM bit was set. 
<P>Jssmag.209 then requests that packets 3 &amp; 5 be retransmitted. Helios 
resends them then jssmag.209 releases the transaction. Finally, jssmag.209 
initiates the next request. The `*' on the request indicates that XO (`exactly 
once') was <I>not</I> set. 
<P>
<P><B></B>IP Fragmentation 
<P>Fragmented Internet datagrams are printed as 
<DL compact>
  <DT>
  <DD><PRE>
<B>(frag </B><I>id</I><B>:</B><I>size</I><B>@</B><I>offset</I><B>+)</B>
<B>(frag </B><I>id</I><B>:</B><I>size</I><B>@</B><I>offset</I><B>)</B>

</PRE></DD></DL>(The first form indicates there are more fragments. The second 
indicates this is the last fragment.) 
<P><I>Id</I> is the fragment id. <I>Size</I> is the fragment size (in bytes) 
excluding the IP header. <I>Offset</I> is this fragment's offset (in bytes) in 
the original datagram. 
<P>The fragment information is output for each fragment. The first fragment 
contains the higher level protocol header and the frag info is printed after the 
protocol info. Fragments after the first contain no higher level protocol header 
and the frag info is printed after the source and destination addresses. For 
example, here is part of an ftp from arizona.edu to lbl-rtsg.arpa over a CSNET 
connection that doesn't appear to handle 576 byte datagrams: 
<DL compact>
  <DT>
  <DD><PRE>
<FONT size=-2><TT>arizona.ftp-data &gt; rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)
arizona &gt; rtsg: (frag 595a:204@328)
rtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560</TT></FONT>

</PRE></DD></DL>There are a couple of things to note here: First, addresses in 
the 2nd line don't include port numbers. This is because the TCP protocol 
information is all in the first fragment and we have no idea what the port or 
sequence numbers are when we print the later fragments. Second, the tcp sequence 
information in the first line is printed as if there were 308 bytes of user data 
when, in fact, there are 512 bytes (308 in the first frag and 204 in the 
second). If you are looking for holes in the sequence space or trying to match 
up acks with packets, this can fool you. 
<P>A packet with the IP <I>don't fragment</I> flag is marked with a trailing 
<B>(DF)</B>. 
<P><B></B>Timestamps 
<P>By default, all output lines are preceded by a timestamp. The timestamp is 
the current clock time in the form 
<DL compact>
  <DT>
  <DD><PRE><I>hh:mm:ss.frac</I>
</PRE></DD></DL>and is as accurate as the kernel's clock. The timestamp reflects 
the time the kernel first saw the packet. No attempt is made to account for the 
time lag between when the ethernet interface removed the packet from the wire 
and when the kernel serviced the `new packet' interrupt. <A name=lbAH>&nbsp;</A> 

<H2>SEE ALSO</H2><A 
href="http://localhost/cgi-bin/man/man2html?1C+traffic">traffic</A>(1C), <A 
href="http://localhost/cgi-bin/man/man2html?4P+nit">nit</A>(4P), <A 
href="http://localhost/cgi-bin/man/man2html?4+bpf">bpf</A>(4), <A 
href="http://localhost/cgi-bin/man/man2html?3+pcap">pcap</A>(3) <A 
name=lbAI>&nbsp;</A> 
<H2>AUTHORS</H2>Van Jacobson, Craig Leres and Steven McCanne, all of the 
Lawrence Berkeley National Laboratory, University of California, Berkeley, CA. 
<P>The current version is available via anonymous ftp: 
<P>
<DL compact>
  <DT>
  <DD><I><A 
  href="ftp://ftp.ee.lbl.gov/tcpdump.tar.Z">ftp://ftp.ee.lbl.gov/tcpdump.tar.Z</A></I> 
  </DD></DL><A name=lbAJ>&nbsp;</A> 
<H2>BUGS</H2>Please send bug reports to <A 
href="mailto:tcpdump@ee.lbl.gov">tcpdump@ee.lbl.gov</A>. 
<P>NIT doesn't let you watch your own outbound traffic, BPF will. We recommend 
that you use the latter. 
<P>Some attempt should be made to reassemble IP fragments or, at least to 
compute the right length for the higher level protocol. 
<P>Name server inverse queries are not dumped correctly: The (empty) question 
section is printed rather than real query in the answer section. Some believe 
that inverse queries are themselves a bug and prefer to fix the program 
generating them rather than tcpdump. 
<P>Apple Ethertalk DDP packets could be dumped as easily as KIP DDP packets but 
aren't. Even if we were inclined to do anything to promote the use of Ethertalk 
(we aren't), LBL doesn't allow Ethertalk on any of its networks so we'd would 
have no way of testing this code. 
<P>A packet trace that crosses a daylight savings time change will give skewed 
time stamps (the time change is ignored). 
<P>Filters expressions that manipulate FDDI headers assume that all FDDI packets 
are encapsulated Ethernet packets. This is true for IP, ARP, and DECNET Phase 
IV, but is not true for protocols such as ISO CLNS. Therefore, the filter may 
inadvertently accept certain packets that do not properly match the filter 
expression. 
<P>
<HR>
<A name=index>&nbsp;</A>
<H2>Index</H2>
<DL>
  <DT><A href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAB">NAME</A>
  <DD>
  <DT><A 
  href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAC">SYNOPSIS</A>
  <DD>
  <DT><A 
  href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAD">DESCRIPTION</A>
  <DD>
  <DT><A 
  href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAE">OPTIONS</A>
  <DD>
  <DT><A 
  href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAF">EXAMPLES</A>
  <DD>
  <DT><A href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAG">OUTPUT 
  FORMAT</A>
  <DD>
  <DT><A href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAH">SEE 
  ALSO</A>
  <DD>
  <DT><A 
  href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAI">AUTHORS</A>
  <DD>
  <DT><A href="http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAJ">BUGS</A>
  <DD></DD></DL>
<HR>
This document was created by <A 
href="http://localhost/cgi-bin/man/man2html">man2html</A>, using the manual 
pages.<BR>Time: 19:17:16 GMT, August 09, 2000 </BODY></HTML>
