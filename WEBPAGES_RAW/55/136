<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
  <title>Writing Methods</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Writing Classes and Javadoc</h1>
<p>
<h2>Introduction to Computer Science I-III<br>
ICS-21/-22/-23<br>
</h2>
<p>
</center>


<!-- Introduction -->

<a name="Introduction"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Introduction</b></td>
<td width ="80%">
  We have already learned a lot about using classes from prewritten libraries
    and about reading their Javadoc to understand them.
  In this lecture, we will discuss the form and meaning of writing Java
     classes and Javadoc.
  So, we will examine the same language features that that we have already
    used, but now from the perspective of writing classes.
  <p>
  The discussion starts by investigating methods in general.
  We will discuss how to write <b>static</b> methods first (and
    learn about the special <b>main</b> method in an application program)
     and then in simple library classes (such as <b>Math</b> and <b>Prompt</b>
     which programs can import) .
  We will learn about call frames: pictures that illustrate the universal
    parameter passing mechanism in Java: copy by value.
  We will also learn how to write methods that throw exceptions, if they are
    called with objects/arguments that do not meet their preconditions.
  <p>
  Finally, we will learn how to write more interesting classes, focusing on
    declaring fields (mostly instance variables) and using them when writing
    constructors and methods.
  During this process, we will see how to use various features in the the
    Eclipse IDE (edit view and debug perspective) that facilitate the
    analyzing, writing, and debugging of classes.
</td>
</tbody>
</table>



<!-- Method Definitions -->

<a name="MethodDefinitions"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Method Definitions and Parameter Initialization</b></td>
<td width ="80%">
  Let's start our discussing by examining a simple method that defines the
    <b>min</b> method inside the <b>Math</b> class.
  It illustrates most interesting aspects of <b>static</b> method definitions.
  Before reading this code, quickly scan the EBNF for
    <a href="../usingclasses/lecture.html#MemberEBNF">
    <i>method-definition</i></a>.
  <b><pre>  public static int min (int a, int b) {
    if (a <= b)
      return a;
    else
      return b;
  }</pre></b>
  We divide method definitions into two parts: the <b>header</b> and the
    <b>body</b>.
  <ul>
    <li>The method header comprises the access modifiers
          (<b>public static</b>), return type (<b>int</b>), method name
          (<b>min</b>), and parameters (<b>int a, int b</b>); if this method
          threw any exceptions, they would be listed next.
        We should be very familiar with reading method headers in Javadoc from
          previous lectures.
    <p>
    <li>The method body is a <b>block-statement</b> that immediately follows
          the method header.
        In this lecture we will focus our attention on writing this block.
        Its statements use the parameter names just like variable names;
        in fact, we often call them parameter variables to make this
          similarity explicit.
  </ul>
  We have already discussed that when a method is called, its parameter
     variables are always initialized by their matching arguments first.
  Then, the method body executes, using these values to compute and return
    its result; it can also use local variables, declared and intialized in
    the block, to help in its computation.
  <p>
  If we wrote the statement
    <b><pre>  System.out.println( Math.min(3,5) );</pre></b>
  it would display <b>3</b>.
  If we had declared <b>int x = 3, y = 8;</b> and wrote the statement
    <b><pre>  System.out.println(Math.min (3*x+5,y) );</pre></b>
    it would display <b>8</b>
  <p>
  Generally, We call a method by writing its name, followed in parentheses 
    by its arguments (one for each parameter in the method's header)
  As in the header (where parameters are separated by commas), arguments are
    are separated by commas as well.
  When we call a method, Java first evaluates each argument (each can be a
    simple or complicated expression) and <b>transmits</b> or <b>passes</b>
    it to its matching parameter; this just means that Java uses each
    argument's value to initialize it matching parameter in the method.
  It is equivalent to writing
    <b><i>first-parameter</i> = <i>first-argument</i></b>, then 
    <b><i>second-parameter</i> = <i>second-argument</i></b>, etc.
  <p>
  Thus, when calling <b>Math.max(3*x+5,y)</b> above, the first parameter
    (<b>a</b>) is initialized by the value <b>14</b> (<b>3*x+5</b>: the
    equivalent of <b>a = 3*x+5</b>).
  Likewise,  the second parameter (<b>b</b>) is initialized by the value
    <b>8</b> (<b>y</b>: the equivalent of <b>b = y</b>).
  Then, Java executes the body of the method, which typically performs some
    computation using these initialized parameters.
  It finally returns a result, by a mechanism that we discuss in the next
    section.
</tbody>
</table>




<!-- Return Statement -->

<a name="ReturnStatement"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The return Statement</b></td>
<td width ="80%">
  We will now discuss another Java statement, the <i>return-statement</i>,
    whose EBNF is simply stated (<b>return</b> is a keyword) as
 <p>
  &nbsp &nbsp <i>return-statement</i> <= <b>return</b> [<i>expression</i>];
 <p>
  As a syntax constraint, Java requires that <i>expression</i> must be
    compatible with the <i>return-type</i> specified in the method's header
   (either be the same, or be implicitily convertible).
 In a <b>void</b> method (or a constructor), Java requires us to discard
     this option altogether.
  Typically, <i>expression</i> is a literal or a variable, but sometimes it is
    a more general expression using operators/method calls.
  For example, we will see methods that include the return statements
  <b><pre>  return true;        return a;        return i%divisor==0;</b></pre>
  <p>
  We use a <b>return</b> statement to terminate a method and specify what
    result (if any) it should return
  Whenever a method executes <b>return</b>, no matter what else it is is
    doing (i.e., inside loops or <b>try-catch</b> or ...), the method
    immediately terminates and returns to where the method was called (its
    <b>call site</b>).
  If the method returns a value, it is as if the method call is "replaced"
    by the value that it returns as a result.
  <p>
  Ideally, a method should contain just one <b>return</b> statement, at its
    end.
  In fact, we can prove mathematically that there is always a way to write a
    method with one <b>return</b> statement.
  But sometimes methods are easier to understand if they have multiple
    <b>return</b> statements.
  <p>
  Thus, we will adopt a more pragmatic approach, putting simplicity as the
    paramount aspect of the code that we write: if multiple <b>return</b>
    statements make a method simpler and easier to understand, use them.
  But be able to argue why; don't just use them because you are sloppy.
  I would argue, for example, that the <b>min</b> method defined above, which
     has two <b>return</b> statements, is simpler than the one below, which
     has only one <b>return</b> statement.
  <b><pre>  public static int min (int a, int b) {
    int answer;
    if (a <= b)
      answer = a;
    else
      answer = b;
    return answer;
  }</pre></b>
  Instead of one <b>if</b> statement, this method's body is a sequence of 
    three statements that declare a local variable, decide how to initialize
    it, and then return that value.
  The original method just chose which of its parameters to returns, without
    declaring any local variable.
  I think that the original method is simpler and easier to understand.
  <p>
  In fact, this method is actually defined in the Java library by using
    a single return of a conditional expression:
  <b><pre>  public static int min (int a, int b)
  {return (a <= b ? a : b);}</pre></b></td>
</tbody>
</table>



<!-- Sample Methods -->

<a name="SampleMethods"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Sample Methods</b></td>
<td width ="80%">
  The following method definitions compute useful and interesting values.
  In practice, many useful methods are short, like these; study their
    headers and especially their bodies.
  <b><pre>  public static boolean isLeapyear (int year)
  {return  (year%4 == 0 && year%100 != 0) || year%400 == 0;}</pre></b>
  This method hides a very messy calculation inside a well-named and easy to
    call method: it just has one parameter: the year to do the calculation on.
  <p>
  <b><pre>  public static boolean isBetween(int low,
                                  int middle,
                                  int high)
  {return low<=middle && middle<=high;}</pre></b>
  This method captures a common pattern that we have explored before
    (and why <b>low <= middle <= high</b> does NOT correctly compute the
    required value).
  The correct way to perform this test is a bit verbose, so calling this
     method can simplify our code.
  <p>
  <b><pre>  public static double distance (double x1, double y1,
                                 double x2, double y2)
  {return Math.sqrt( (x1-x2)*(x1-x2) +  (y1-y2)*(y1-y2) );}</pre></b>
  This method computes the simple Euclidean distance between two points,
    which must be specified as four parameters: the X- and Y-coordinate of
    each point (although a better method would use two parameters, each
    an instance of a <b>Point</b> class, to represent these four values).
  Some methods have quite a few parameters (see below for even more).
  <p>
  <b><pre>  public static boolean inCircle (double centerX, double centerY,
                                  double centerRadius,
                                  double pointX, double pointY)
  {return distance(centerX,centerY,pointX,pointY) <= centerRadius;}</pre></b>
  This method calls <b>distance</b> to compute whether a point
   (whose coordinates are <b>pointX</b> and <b>pointY</b>) falls within a
    circle (whose center's coordinates  are <b>centerX</b> and <b>centerY</b>,
    and whose radius is <b>centerRadius</b>).
  Note that four of the coordinate <b>parameters</b> to <b>inCircle</b> become
    <b>arguments</b> to the call of <b>distance</b>; this role switch is common
    in methods calling other methods.
  By layering methods on top of methods, each is kept small, but each new 
    method accomplishes much more than the methods it calls, by building on it;
    this layer mechanism enables power programming.
  <p>
  <b><pre>  public static int factorial (int n) {
    int answer = 1;
    for (int i=2; i<=n; i++)
      answer *= i;
    return answer;
  }</pre></b>
  This method is interesting because it declares two local variables
   (<b>answer</b> and <b>i</b>; methods can declare and use local variables
   along with their parameters), one of which is finally returned.
  When writing methods, beginners sometimes have difficulty determining when to
    declare parameter variables and when to declare local variables.
  Here is where thinking about prototypes helps: any information that must be
    communicated to the method by arguments must be stored in a parameter
    variable; local variables help in the computation, but do not need to be
    initialized by arguments: we need <b>n</b> to specify the factorial we are
    computing, but <b>answer</b> is always initialized to <b>1</b>
      and <b>i</b> is always initialized to <b>2</b> in the <b>for</b> loop.
  Methods should have the fewest number of parameters possible; if a variable
    can be declared locally, it should be.
  <p>
  <b><pre>  public static int forInt (String message) {
    for (;;)
      try {
       return Integer.parseInt(Prompt.forString(message));
     }
     catch (NumberFormatException nfe)
       {System.out.println("Enter an int please");}
  }

  public static int forInt (String message, int low, int high) {
    for (;;) {
      int answer = Prompt.forInt(message + "[" + low + ".." + high + "]");
      if ( Utility.isBetween(low, answer, high) )
        return answer;
      System.out.println("Entered value not in range [" + 
                         + low + ".." + hight + "]");
    }
  }</pre></b>
  These overloaded <b>forInt</b> methods (two different signatures) are two of
      my favorites; they are general purpose methods that we can use in many
      different programs.
  In fact, they are so useful that I have put these methods in the
     <b>Prompt</b> class, so I can easily use them in any programs I write;
     also, one calls the other so it further illustrates the power of composing
     methods (even the first calls two other methods: <b>Integer.parseInt</b>
       and <b>Prompt.forString</b>).
  <ul>
    <li>The first <b>forInt</b> uses a <b>try-catch</b> to ensure that the
          value entered by the user (read as a <b>String</b>) is in fact a
          legal <b>int</b> (in which case it immediately returns that value);
          if the user doesn't enter a legal value, the <b>Integer.parseInt</b>
          method instead throws <b>NumberFormatException</b> before the
          <b>return</b> can finish; it is caught and processed by printing an
          error message and executing loop again, prompting the user to enter
          a value.
    <p>
    <li>The second <b>forInt</b> is passed three parameters, which are used to
          coordinate prompting the user with a message to enter a value between
          a lower and higher bound; the method rejects any entered values that
          are outside this range, prompting the user until he/she enters a
          value in this range.
        By calling the previously defined <b>forInt</b> method, this method
          doesn't have to worry about exceptions caused by incorrect data
          entry: the other method handles those kinds of errors.
        Again, layering of methods very useful here.
  </ul>
  Notice the sophisticated use of the <b>return</b> statements to terminate 
    these method and return an answer.
  There is no need for a <b>break</b> statement because by terminating the
    method, the loop is terminated too.
  <p>
  <b><pre>  public static int multiRoll (DiceEnsemble d, int times) {
    int sum = 0;
    for (int i=1; i<=times; i++)
      sum += d.roll().pipSum();     //cascaded method call
    return sum;
  }</pre></b>
  Finally, this method rolls a <b>DiceEnsemble</b> object the required
    number of times, returning the sum of all the pips seen during all the
    rolls.
  So, we can pass reference types as parameters to methods as easily as
    primitive types.
  Here we use the generic identifier <b>i</b> as an index that counts the
    appropriate number of throws (and is used nowhere else in the code); we
    could have also written this as the countdown loop<br>
    &nbsp &nbsp<b>for (/*parameter intialized*/; times>0; times--) {...</b><br>
    noting that the parameter <b>times</b> is initialized when the method is
    called (by its matching argument), so the <b>for</b> loop doesn't need to
    initialize it.
  <p>
  In summary, we can define a simply-named method (with the parameters needed
    to do the calculation) and a body that hides the "messy" calculation. 
  Then we can debug it, place it in a class, and easily use it in any other
    software we write (forgetting about all the code inside it).
  We are always only one method name away from hiding whatever complexity a
    program requires.
  By layering methods, we can quickly amplify their powers.
</td>
</tbody>
</table>



<!-- Hand Simulation -->

<a name="HandSimulation"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Hand Simulation via Call Frames</b></td>
<td width ="80%">
  In this section we will begin to learn how to hand simulate method calls
    using the <i>call frame</i> mechanism, which is mostly concerned with
    passing the arguments at the method call site to the parameters in the
     method definition.
  We will expand upon this mechanism, to show its real predictive power,
    when we discuss passing references to objects into methods in the next
    section.
  <p>
  The general form of a call frame is always the same.
  <p>
</td>
</tbody>
</table>
  <image src="images/callframe.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  For a concrete example, let's see how to write a call frame for the
    <b>min</b> method definition, being called as <b>Math.min(x,y+1)</b>.
  First, the parameter mechanism in Java is called <b>copy by value</b>.
  With copy by value, Java copies the value of each argument (arguments are
    evaluated when a method is called, at its call site) into a parameter
    variable: pictured, as always, a box labeled  by its parameter's name
    and type.
  So, parameters are just special kinds of variables: each is always
    initialized by the value of it matching argument from the call site.
  <p> 
</td>
</tbody>
</table>
  <image src="images/mincf.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  There are no local variables here, so we leave blank that part of the call
     frame.
  After the call frame has been specified, and the parameters have been 
    initialized, Java executes the body of the method, which refers to the
     parameters to compute its value.
  The result is that this method returns <b>5</b>, which replaces the method
    call at the call site, in the <b>System.out.println</b> statement, so
    ultimately <b>5</b> is printed on the console.
  <p>
  For another example, here is a call frame for the <b>factorial</b> method
  Note that after it returns to the call site, the value that it returns as a
     result is stored into the variable <b>y</b>.
  <p>
</td>
</tbody>
</table>
  <image src="images/factcf.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  Besides its single parameter, this method declares two local variables
   (<b>answer</b> and <b>i</b>, the <b>for</b> loop index variable), which are
    initialized in their declarations to <b>1</b> and <b>2</b> respectively
    when Java executes the body of its method.
  Note how state changes to variable are illustrated: crossing out the old
   value and writing the new value after it.
</td>
</tbody>
</table>


<!-- Advanced Call Frames -->

<a name="AdvancedCallFrames"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Advanced Call Frames</b></td>
<td width ="80%">
  In this section, we will explore call frames in a bit more detail, looking 
    closely at the difference between changing the state of a variable and 
    changing the state of an object (referred to by a variable).
  Let's start by hand simulating a call to the following method
  <pre><b>  public static void swap (int a, int b) {
    int temp = a;
    a = b;
    b = temp;
  }</b></pre>
  Let's assume that this method is defined in a class named <b>Utility</b>
    and that we declare <b>int x=5, y=8;</b> and call <b>Utility.swap(x,y);</b>
    what values are ultimately stored in <b>x</b> and <b>y</b>?
  Are these variables swapped, or do they remain unchanged?
  The call frame shows us.
  <p>
  IMPORTANT: If we do not execute a <b>return;</b> statement in a <b>void</b>
    method (there is none in the code below), Java automatically does the
    equivalent of <b>return;</b> when it reaches the end of the block that
    is the body of the method.
  Java DOES NOT allow an implicit return in a non-<b>void</b> method, becuase
    we MUST specify an expression that tells Java what value the method
    returns as its result; but, because <b>void</b> methods return nothing,
    Java can reasonably include an implicit <b>return;</b> at the end of the
    body.
  <p>
</td>
</tbody>
</table>
  <image src="images/swapcf.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  It is important to note that although the values in the parameters
    (<b>a</b> and <b>b</b>) are exchanged by this code, the values stored in
    the arguments (<b>x</b> and <b>y</b>) ARE NOT EXCHANGED.
  The values stored in the arguments were copied to the parameters when the
    method was called, but this transmission mechanism is ONE-WAY ONLY: FROM
    ARGUMENTS TO PARAMETERS.
  Thus, parameter transmission is asymmetrical.
  If an argument is a variable, the value stored in that variable always
    remains unchanged by a method call, even if we change the value stored in
    its matching parameter.
  The value in the box of the argument cannot be changed in a method call.
  <p>
  The situation gets a bit more complicated and interesting with references,
    because everything is more complicated and interesting with references.
  Recall how to copy a reference into a variable: make the variable refer to
    the same object (this describes how references are passed from arguments to
    parameters as well).
  Although the value in the box of the argument cannot be changed in a method
    call (it will still refer to the same object), the state of the object
    that it refers to CAN BE CHANGED in the body of the method by calling
    mutators/commands.
  <p>
  Let's look at the call frame for the <b>multiRoll</b> method to illustrate
    his behavior.
  Assume again that this method is defined in a class named <b>Utility</b> and
    that we declare <b>DiceEnsemble dice = new DiceEnsemble(2,6);</b> and call 
    <b>System.out.println(Utility.multiRoll(dice,3));</b>
  <p>
</td>
</tbody>
</table>
  <image src="images/multithrowcf.gif"></image>
  <image src="images/multithrowcf2.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  Java passes the argument to the parameter by copying its reference, resulting
    in both the argument <b>dice</b> and the parameter <b>d</b> sharing the
    same object.
  Then, each time the <b>multiRoll</b> method calls <b>d.roll();</b> the state
    of the shared object changes (see the <b>rollCount</b> and <b>pips</b>
    instance variables).
  The different values returned by <b>getPipSum</b>
   (<b>7=2+5</b>, <b>4=3+1</b>, <b>5=1+4</b>) account for the state changes
     shown for the local variable <b>sum</b>.
  So, the first statement prints the returned value from <b>sum</b>
    (<b>16</b>), and the second prints the value of <b>rollCount</b> from the
    object (now <b>3</b>)
  <p>
   In summary, we cannot change arguments in a method call by changing the
     values stored in their matching parameters. 
   But, if an argument and parameter share an object, then we can change the
     state of that object by calling a mutator/command method in the method.
   Once the method returns its result, the argument must refer to the same
     object, but THAT OBJECT'S STATE CAN BE CHANGED.
</td>
</tbody>
</table>



<!-- final parameters -->

<a name="final"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>final parameters</b></td>
<td width ="80%">
  Finally, here is an update to the EBNF rule for <i>parameter</i>.
  It adds the option of specifying the keyword <b>final</b> before <i>type</i>.
  <p>&nbsp &nbsp <i>parameter</i> <= [<b>final</b>] <i>type</i> <i>identifier</i><p>
  If a parameter variable is declared <b>final</b>, we must treat it like
    any other <b>final</b> variable: we cannot change its state.
  So, throughout the method body it will always store the value to which it
    was initialized by its matching argument.
  It is frequently (but not always) the case that a method examines
    but does not store into its parameters.
  So, most of the time we can specify that a parameter is <b>final</b>.
  But, most Java style standards DO NOT require specifying parameters as
    <b>final</b>, even if  they remain unchanged in the body of a method.
  I'm still deciding what I think is right in this case; meanwhile, you can
    choose either to include <b>final</b> in the code you write, to emphasize
    that the parameter does not change, or omit it; whatever you choose, be
    consistent.
</td>
</tbody>
</table>


<!-- Design -->

<a name="Design"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Designing Methods</b></td>
<td width ="80%">
  When designing a method, first think of a descriptive name for it;
    then think about the other prototype information: what its return type is
    (if it is not <b>void</b>) and what parameter types it needs.
    (in headers, unlike prototypes, we also should supply descriptive names
     for the parameters).
  Parameter variables are used to convey special information to the method;
    information that controls what a method computes.
  Methods may also have declare local variables, which are needed temporarily
    during the execution of a method; but these values do not have to be
    initialized by arguments outside the method.
  Finally, and this is typically the easiest part, write the statements that
    implement the method.
  <p>
  Most methods perform no input/output (unless that is the primary purpose of
    the method).
  Notice above that except for the <b>promptInt</b> methods, no others
    perform input or output.
  In some sense, methods get their "inputs" through their parameters; they 
    supply their "output" either through a returned result or by changing the
    state of the objects that their parameters refer to.
  So, do not write methods that perform input/output unless that is their
    primary purpose.
</td>
</tbody>
</table>


<!-- EBNF Defining Classes-->

<a name="EBNFDefiningClasses"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>EBNF for Defining Classes including Package and Imports</b></td>
<td width ="80%">
  Everything in Java is defined in a class: simple programs (as you have 
    already written), as well as library classes.
  The EBNF for a class relies heavily on the definition of
    <a href="../usingclasses/lecture.html#MemberEBNF">
    <i>full-member-definition</i></a> (note <b>package</b> and <b>class</b> are
    keywords).
  <p>
&nbsp &nbsp <i>package-declaration</i> <= <b>package</b> <i>package-name</i>;<br>
&nbsp &nbsp <i>class-body</i>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
  <= {<i>full-member-definition</i>}<p>
&nbsp &nbsp <i>class-definition</i>
&nbsp &nbsp &nbsp &nbsp <=&nbsp [<i>package-statement</i>]<br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp{<i>import-declaration</i>}<br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
   <i>access-modifiers</i> <b>class</b> <i>identifier</i> {<br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp &nbsp
   <i>class-body</i><br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp &nbsp }<p>
  The braces in the last rule stand for themselves (in the previous rules they
    stand for standard EBNF repetition).
  Named classes in Java are defined in their own <b>.java</b> file.
  <p>
  Let's examine the three major parts of a <i>class definintion</i>.
  First, the <i>package-statement</i>.
  Every class is defined in one package, specified in the
     <i>package-statement</i>; if this option is omitted, the class is said to
     be defined in the <b>anonymous</b> also known as <b>default</b> package
    (the name of this package has no characters in it).
  Whatever package this class is in, all other classes in that package are
    automatically imported for use in it.
  Second, if this class must refer to any classes in other packages, they must
    be imported explicitly in an <i>import-declarations</i>.
  Finally, the class itself is defined: it specifies its own access modifiers
    (almost always jut <b>public</b>) and includes any number of
    <i>full-member-definition</i>s.
  <p>
  Here is a trivial but complete class named <b>Application</b>.
  It is defined in the anonymous package, imports a neccessary class from the
    course library, and has a <b>main</b> method that performs some
    trivial I/O on the console.
<pre><b>  import edu.uci.ics.pattis.introlib.Prompt;

  public class Application {

    public static void main(String[] args) {
      int input = Prompt.forInt("Enter positive n");
      System.out.println("You entered: " + n);
    }
}</b></pre>
  Typically, such a class is stored in a file with the same first name as
     the class:  <b>Application.java</b>.
  After discussing <b>main</b> methods, will see how to define complete
    classes for simple Java programs and libraries that define other methods.
</td>
</tbody>
</table>


<!-- main method -->

<a name="mainMethod"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The main Method</b></td>
<td width ="80%">
  Any Java class can define a special <b>main</b> method as one of its members;
     but, a method with this name is special only if it has exactly the
     following access modifiers and header
  (This method specifies an array of <b>String</b> as its parameter, although 
    we will not use this parameter until we study how to use Java from a
    command line; we will see below how to tell the Eclipse IDE which
    special <b>main</b> method to execute.)<p>
    &nbsp &nbsp <b>public static void main(String[] args)</b><p>
  <p>
  We can direct Java to start our program (a collection of one or more classes)
    automatically in any special <b>main</b> method.
  In fact, any project can include multiple classes, and each class can
    have its own special <b>main</b> method (this is actually quite useful,
    and we will discuss this feature when we discuss testing classes in more
    detail).
  In such a situation, we must tell Java WHICH special <b>main</b> method to
    start with.
  <p>
  In Eclipse, we specify the class whose <b>main</b> method is to be run
    by selecting the class either in the <b>Package Explorer</b> or in the
    Editor.
</td>
</tbody>
</table>


<!-- Application Methods -->

<a name="ApplicationMethods"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Methods in Applications</b></td>
<td width ="80%">
  We have seen how to declare one special <b>static</b> method in a class and
    have Java execute that method.
  Now we will learn how to define and call other <b>static</b> methods in a
    class.
  All we must do is place these other method definitions inside the 
    class, along with the <b>main</b> method.
  Then, we can call these method from <b>main</b> or from each other.
  <p>
  Any <b>static</b> method in a class can call any other static method in that
     same class, just by using its name and supplying arguments that match its
     signature (or, if overloaded, one of its signatures).
  We can also be a bit more consistent (and verbose) and call a <b>static</b>
    method by prepending the class name to the method's name.
  The following <b>Application</b> class shows a simple example of such code.
<pre><b>  import edu.uci.ics.pattis.introlib.Prompt;

  public class Application {

    public static int factorial (int n) {
      int answer = 1;
      for (int i=2; i<=n; i++)
        answer *= i;
      return answer;
    }

    public static void main(String[] args) {
      int input = Prompt.forInt("Enter positive n");
      System.out.println(input + "! = " + factorial(input));
    }
}</b></pre>
  Here, <b>main</b> prompts the user for a value (using the <b>static</b> 
    <b>forInt</b> method in the imported <b>Prompt</b> class) and
    then uses that value as an argument to call the <b>factorial</b> method
    defined in this class.
  We have always called <b>static</b> methods in the form
    <b><i>ClassName</i>.<i>methodName</i></b>; and, in fact, we could write<br>
    &nbsp &nbsp <b>System.out.println(n + "! = " + Application.factorial(input));</b><br>
  But, if one method defined in a class calls another method defined in that
   same class, then we can shorten the call to just the method's name.
  Most programmers use this shortened form for method names.
  <p>
  Another way to think about this issue is to imagine that a class is like a
    family: all members of the <b>Application</b> class belong to a family
    with that last name.
  Each defined member's name is like a first name.
  Members of the same family (class) can refer to each other by their first
    names only, without ambiguity.
  This is why <b>main</b> can refer just to <b>factorial</b>; we do not need
    to write <b>Application.factorial</b>.
  But, when refering to some <b>static</b> member OUTSIDE your family (class)
    you must use both its last and first name (separated, of course, by a
    period).
  This is why we write <b>Math.sqrt</b> and <b>Prompt.forInt</b> in 
     <b>main</b> methods in the <b>Application</b> class.
  <p>
  A more complicated and interesting example of <b>static</b> methods appears
    in the
    <a href="../../programs/datecalculator1.zip">
      Date Calculator #1</a> program.
  This program defines and used five <b>static</b> methods (and twelve
    <b>static</b> fields).
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Definition Order</b></td>
<td width ="80%">
  Java uses a <b>multi-pass</b> compiler, which means that the methods and
    fields in a program can be defined in any order: Java first reads all
    the method headers and fields in the file, then in reads all the bodies,
    checking that they all use the types of these methods and fields correctly.
  <p>
  One standard way to write methods is in the "natural" order: if the body of
    method <b>b</b> calls method <b>a</b>, then method <b>a</b> is defined
    before method <b>b</b>.
  For example, we might have the following program form
  <b><pre>  method a's header
  {...no method calls...}

  method b's header
  {...call to a...}

  method c's header
  {...no method calls...}

  method d's header
  {...calls to b and c...}

  main methods' header
  {...calls to d and a...}</b></pre>
  <p>
  In fact, there may be many natural orders: e.g., in this example we could
   also meet the natural criteria by defining method <b>c</b> before
    method <b>b</b> or even before method <b>a</b>.
  The <b>main</b> method calls lots of other methods, so it typically appears
    last in the file.
  <p>
  In the "reverse natural" order: if the body of method <b>a</b> calls method
    <b>a</b>, then method  <b>a</b> is defined after method <b>b</b>.
  In this case, the <b>main</b> method calls lots of other methods, so it
   typically appears first in the file.
  <b><pre>  main methods' header
  {...calls to d and a...}

  method d's header
  {...calls to b and c...}

  method c's header
  {...no method calls...}

  method b's header
  {...call to a...}

  method a's header
  {...no method calls...}</b></pre>
  In this way, the most powerful methods appear at the top; we can read the
    details of how they work aftward.
  Because Java uses a multi-pass compiler, these two orderings, or any others,
    are all legal.
  When we discuss mutually recursive methods, we will return to this topic
    again.
  <p>
  Now, some words on divide and conquer, and program complexity.
  Up until now, we have been putting all of our code in the <b>main</b> method,
    some of which have been a hundred or more lines of code.
  This practice is stopping here!
  From now on, we will be distributing complexity by writing methods, and
    placing them in the application program, or in class libraries.
  We can write, test, and debug each method (and each class) independently.
  <p>
  Each method, including <b>main</b>, should not comprise more than one or two
    dozen statements; when a method gets too complicated (it does "this" and
    "that") then write a "this" method and a "that" method, and have the
     original method call these two new methods to get its job done.
  Another rule for keeping the complexity of each method small it to prohibit
    more than one loop (the most complex Java statement to think about) per
    method -or allow multiple loops, but not nested loops.
  <p>
  Notice how the complexity has been distibuted in the date calculator program,
    in which each method, even <b>main</b> contains only a small number of 
    statements.
</td>
</tbody>
</table>


<!-- Throwing Exceptions -->

<a name="ThrowingExceptions"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Throwing Exceptions<br>(an introduction)</b></td>
<td width ="80%">
  We have already discussed how to handle thrown exceptions with
    <b>try-catch</b> statements.
  Now is an appropriate time to begin discussing the other end of exception
     processing: how to throw them them after detecting a problem.
  The EBNF rule for throwing an exception (using the keyword <b>throw</b>) is
    trivial:<p>
    &nbsp &nbsp <i>throw-statement</i> <= <b>throw</b> <i>expression</i>;<p>
  where there is a syntax constraint that <i>expression</i> must refer to an 
    object constructed from a class descended from the <b>Throwable</b> class.
  We will discuss class hierarchies later; for now we have seen the names of a
    variety of classes descended from <b>Throwable</b>: <b>EOFException</b>, 
    <b>NumberFormatException</b>, and most important for our current needs,
    <b>IllegalArgumentException</b>, and <b>IllegalStateException</b>.
  <p>
  Exceptions are represented by classes; so, throwing an exception requires us
    to construct a new instance of the class, typically initializing its state
    by a <b>String</b> that describes the problem; this <b>String</b> can be
    further examined and printed when the exception is caught.
  <p>
  Given that our <b>factorial</b> method only works for non-negative integers,
    we might modify it as follows, to detect a bad argument and throw
    <b>IllegalArgumentException</b> with an appropriate message (rather than
    just returning <b>1</b>).
  Notice how <b>throws IllegalArgumentException</b> now appears in 
   <b>factorial</b>'s signature.
<pre><b>  public static int factorial (int n)
      throws IllegalArgumentException {
    if (n < 0)
      throw new IllegalArgumentException
        ("factorial: n ("+n+") must be non-negative");

    int answer = 1;
    for (int i=2; i<=n; i++)
      answer *= i;
    return answer;
  }</b></pre>
  A simple <b>if</b> statement, the first in the method, determines whether or
    not the argument is bad, and if so throws an exception.
  It is common to check all the necessary preconditions on arguments at the
    start of a method's body, grouping such code together and separating 
    it from the code that actually performs the method's task (which executes
    only after all the preconditions on the parameters have been checked).
  In this example, if the argument matching parameter <b>n</b> is a negative
    value, Java constructs an instance of the <b>IllegalArgumentException</b>
    class (initialized with an appropriate error message), and throws that
    exception.
  <p>
  When a statement throws an exception, Java abandons sequential execution and
    tries to locate a <b>catch</b> clause to handle the exception, first
    inside the method in which it was thrown; if the method itself doesn't have
    one, Java goes back to the call site for the method (which is the body of
    some other method) and repeats this process there.
  If by repeating this process, Java eventually gets back to the special
    <b>main</b> method, and if there is no matching <b>catch</b> clause to
    handle the exception, Java prints the exception name, the exception's
    message (the <b>String</b> argument to the exceptions constructor), and
    a trace of all the methods that were called, leading up to the problem.
  <p>
  We will use <b>throw</b> statements as we continue to learn about writing
    constructors and methods in classes.
  We will come back to the topic of <b>throw</b> statements and
    <b>try-catch</b> statements, and exception classes at least once more
    (in the context of class hierarchies), to help us further understand this
     complex error detection and recovery mechanism.
  There we will learn how to write new exception classes and the difference
    between checked and unchecked exceptions.
</td>
</tbody>
</table>



<!-- Library Classes -->

<a name="LibraryClasses"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Methods in Library Classes</b></td>
<td width ="80%">
  Although some <b>static</b> methods might be useful in just one application,
    many are general enough to be used in other (similar) applications.
  In Java, we can easily collect these methods into a class of related methods
    (all the source code in the same file), which we can easily import and use
    in other programs.
  <p>
  The <b>Math</b> class in the standard Java library serves exactly this
    purpose, as doe the <b>Prompt</b> class in the course library: each
    collects together a group of math-related or console i/o related methods.
  For example, we ccould easily group together all of the <b>static</b> methods
    and fields from the date calculator program into a <b>DateUtility</b>
    class as is shown below.
  Then, we could use such a class library in any program that must deal with
    dates.
  Examine the <a href="../../programs/datecalculator2.zip">
    Date Calculator #2</a> program to see exactly how this mechanism works in
    a project.
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<pre><b>public class DateUtility {

  //Returns whether year is a leap year?

  public static boolean isLeapYear (int year)
  {return (year%4 == 0 && year%100 != 0) || year%400 == 0;}



  //Returns the number of days in month (in year)

  public static int daysIn (int month, int year)
      throws IllegalArgumentException {
    if (year < 1)
      throw new IllegalArgumentException
                 ("daysIn: year ("+year+") not positive");
    if (month < JANUARY || month > DECEMBER)
      throw new IllegalArgumentException
                  ("daysIn: month ("+month+") not in range [1,12]");
	  
    //Thirty days hath September, April, June and November...
    if (month == APRIL     ||
        month == JUNE      ||
        month == SEPTEMBER ||
        month == NOVEMBER)
      return 30;
	    
    //...all the rest have thirty one...
    else if (month == JANUARY || 
             month == MARCH   ||
             month == MAY     ||
             month == JULY    ||
             month == AUGUST  ||
             month == OCTOBER ||
             month == DECEMBER)
      return 31;
	   
    //...except February (must be FEBRUARY in else: see possible exception)
    else /* if (month == FEBRUARY) */
      return 28 + (isLeapYear(year) ? 1 : 0);
  }
	


  //Returns the ordinal (1st, 2nd, 3rd, etc) representing month, day, year

  public static int ordinalDate (int month, int day, int year) {
    int ordinal = 0;
	  
    //Scan every earlier month, summing the # of days in that month...
    for (int m=JANUARY;  m < month;  m++)
      ordinal += daysIn(m, year);
	  
    //...and add day in the current month
    return ordinal + day;
  }



  //Returns a date as an American or European String
  //e.g., for February 10, 1954 these return "2/10/1954" and "10/2/1954"

  public static String americanFormat (int month, int day, int year)
  {return month + "/" + day + "/" + year;}
  
  public static String europeanFormat (int month, int day, int year)
  {return day + "/" + month + "/" + year;}
  
  
   

  //Fields: all public static final (constants supplied by class)
  //These could be private, for use only in this class,
  //  but what the heck, let programmers use them from this class
  //  (with final, there is nothing a programmer can do to change them)

  public static final int JANUARY   =  1;  
  public static final int FEBRUARY  =  2;  
  public static final int MARCH     =  3;  
  public static final int APRIL     =  4;  
  public static final int MAY       =  5;  
  public static final int JUNE      =  6;  
  public static final int JULY      =  7;  
  public static final int AUGUST    =  8;  
  public static final int SEPTEMBER =  9;  
  public static final int OCTOBER   = 10;  
  public static final int NOVEMBER  = 11;  
  public static final int DECEMBER  = 12;  
}</b></pre>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  Recall that final variables (constants) in Java are written as
    upper-case identifiers.
  If their name consists of multiple words, separate them by underscores:
     e.g., <b>MAX_CLASS_SIZE</b>.
  <p>
  Given the use of a library class, the <b>main</b> method in the
    <b>Application</b> class must refer to its members by using both their
    class name and member name: e.g., 
    <b>int ordinal = DateUtility.ordinalDate(month, day, year);</b>
  <p>
  Again, observe that inside this class, we refer to each member by just its
     name.
  Outside the class (in the <b>Application</b> class) we must refer to each
    <b>static</b> member by its class name followed by its member name.
  <p>
  Finally, note that there are no constructors for this class (and likewise no
    instance variables).
  We do not construct objects from this class; we just use the class name
    directly to refer to the methods that we want to call from this class.
  <p>
</td>
</tbody>
</table>


<!-- Eclipse -->

<a name="Eclipse1"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Methods/Fields and the Eclipse IDE</b></td>
<td width ="80%">
  Methods are so common in programming, various parts of the Eclipse IDE
    have been built to deal with them easily.
  Here we will examine mechanisms in the Java and Debugger views that help us
    use methods in our programs.
  <p>
  The editor includes a mechanism to locate and display a method easily in a
     program or library class.
  When a class is active in the editor, the <b>Outline</b> window lists all
    the methods in the class.
  We can easily view a method in the editor by clicking its name in the
    <b>Outline</b> window.

  As the number of methods in a class grows, this mechanism becomes more
    and more useful for quickly navigating files.
  <p>
  To the left of each method header is small shaded circle, containing either
    a minus sign or a plus sign.
   The minus sign means the method is fully disclosed; the plus sign means
     the method body is non-disclosed/elided (we see only its header).
   Clicking the circle toggles between disclosed and elided method bodies.
  <p>
  We can also use the debugger to better understand methods and debug methods
    that we have written.
  The options displayed when we are stepping through a program appear as
  <p>
  <image src="images/step.gif"></image>
  <ul>
    <li>Middle: The <b>Step Over</b> button (the arrow pointing over a bar, as
          we have discussed) executes a  method as if it were a black box:
          it does not show what happens inside a stepped-over method, it just
          executes its entire body in one fell swoop.
    <li>Left: The <b>Step Into</b> button (the arrow pointing down between two
          bars) executes a method by first showing its parameters and local
          variables (in the <b>Variables</b> tab).
        Then, we can step through each statement in the method and watch how it
          executes.
        If we step through a <b>return</b> statement, we will be returned to
          the code that called the method.
        If the method we are stepping through calls another method, we can
          choose to step-into or step-over that other call.
    <li>Right: The <b>Step Out</b> button (the arrow pointing up out of two
          bars) executes all the remaining statements in the current method, up
          to and including its <b>return</b> statement.
  </ul>
  Note, the single bar for the middle button represents an entire statement.
  Stepping over it means ignoring the details of any methods that are called
    in that statement.
  The double bars in the left and right buttons represent a block of code
    implementing a method.
  We can step into a method (start executing the first line of code in the
     methods) and step out of a method (finish executing the last line of
     code in the method).
  <p>
  When we step into a method, its parameter and local variables appear in the
    <b>Variables</b> tab.
  All its parameters will be intialized to the values of their matching
     arguments.
  The name of the method will also appear underneath <b>Thread[main]</b> at
     in the <b>Debug</b> tab.
  If it calls another method, that method's name will appear above it (now
    directly underneath <b>Thread[main]</b>); whenever a method returns, its
    name is removed from the <b>Debug</b> tab and control returns to the
    method that called it (the one right below it in the <b>Debug</b> tab).
  <p>
  If you click any method name in the <b>Debug</b> tab, it will show you
    the code that is executing in that method (in the editor window) and that
    method's parameters and local variables (in the <b>Variables</b> tab).
  In this way, it is easy to shift focus among the methods that are currently
    executing.
  The <b>Application.main</b> method remains at the bottom of these method
    names in the <b>Debug</b> tab, throughout the execution of the program.
  <p>
  In the example below, we are looking at the bottom of the <b>daysIn</b>
    method; note its parameters have been initialized: <b>month</b> is
    <b>2</b> and <b>year</b> is <b>2006</b>.
  In fact, this method has already called the <b>isLeapYear</b> method (it is
    at the top of the methods, so it is the one currently executing), but we
    have refocused our attention back to the <b>daysIn</b> method that called
    it, by selecting this method in the <b>Debug</b> tab.
  <p>
</td>
</tbody>
</table>
  <image src="images/stack.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  After we select the <b>isLeapYear</b> method and continue single-stepping,
    we return to the <b>ordinalDate</b> method, which shows the position it
    is executing (in the body of the loop) and all its parameters and local
    variables listed in the order they were declared in:
    parameters <b>month</b>, <b>day</b>, and <b>year</b>; local variables
     <b>ordinal</b> and <b>m</b> -the loop index.
  <p>
</td>
</tbody>
</table>
  <image src="images/stack2.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  Practice using these three kinds of stepping using the two Date Calculator
    programs.
  The time you spend becoming familiar with debugging features will pay for
    itself many times over during the semester: debugging is hard, and these
    tools help tremendously.
</td>
</tbody>
</table>



<!-- Classes with Objects -->

<a name="DefiningClasses">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Defining Classes from which we Construct Objects</b></td>
<td width ="80%">
  We will now shift our focus from simple classes that have only <b>static</b>
    members towards more interesting and useful classes: those from which we
    can construct and manipulate objects/instances.
  We will first examine why/how these classes declare instance variables.
  Although instance variables are declared to be <b>private</b>, we wll learn
    that all other members in their class can manipulate them.
  Then we will learn how to write constructors that help initialize these
    instance variables.
  Finally, we will build on our knowledge of methods to learn how to write
    methods that manipulate instance variables.
  We will discuss multiple uses of the keyword <b>this</b> in the context
    of classes from which we construct objects
  <p>
  Classes in Java combine elements of both state and behavior.
  State is embodied in an object's <b>private</b> instance variables;
     behavior is embodied in the class's <b>public</b> constructors and
     methods, which manipulate these instance variables.
  Programmers think about classes from three important and different
    viewpoints: user, implementor, and designer.
  <ul>
    <li>When a programmer thinks about using a class, he/she is interested
          solely in its <b>public</b> members: what constructors can be used to
          to build objects and what methods can be called to perform useful
          operations on these objects.
        Such a programmer is interested in WHAT can be done, but not HOW it is
          done (so long as the implementation works and is efficient).
        Reading Javadoc is the prime way to learn this information.
    <p>
    <li>When a programmer thinks about implementing a class, he/she is 
          interested first in what <b>public</b> members the class will supply
          (again, what programmers using the class will be able to do); but in
          addition, he/she is also interested in HOW such members can be
          implemented.
        Typically, knowing WHAT requires reading Javadoc; knowing HOW requires
          writing Java code that specifies what state each object will store
          and how its method bodies work to manipulate this state.
        This programmer is often presented with many interesting decisions,
          because there are many ways implement the same functionality.
    <p>
    <li>When a programmer thinks about designing a class, he/she is again
          interested solely in what <b>public</b> members the class supplies.
        This person must decide what members to include and then specify the
          semantics of each member so that (a) users understand WHAT to do with
          the class and (b) implementors understand HOW to implement it.
        Designers do this by writing the <b>public</b> prototypes in a class
          and documenting them with Javadoc.
  </ul>
  These three views are a bit of a simplification, because often one person
    takes multiple roles, even all three: a programmer might need to use a
    a class for a specific application, so he/she designs a general class that
    will be usable for that application (and hopefully others), and then he/she
    impelments the class; and closing the circle, he/she uses it in the
    application.
  Good design is hard.
  A designer often needs lots of experience using/implementing classes before
    he/she can effective design them (so others can use/implement them easily).
  <p>
  In this course we will mostly take the roles of users (as we have in 
    previous lectures) and implementors (as we will in this one).
  As implementors, we will typically be given a design, and then be required
    to implement it.
  To accomplish this process, we will have to indentify the state that each
    object stores, then declare it and define the required constructors and
     methods.
  <p>
  Finally, who tests classes?
  We will see that classes may be tested from all three prespectives.
  <ul>
    <li>The designer tests a class by developing a test suite along with
           the Javadoc; because the designer doesn't know anything about the
           implementation, this is  black-box testing.
        Some test suites are open-ended (a driver) and some are closed
           (we will learn about JUnit testing).
    <p>
    <li>The implementor tests a class by running the designer's tests against
           the implementation, fixing errors exposed by the testing.
        The implementor might also develop further tests based on the
           actual implementation used (this is white-box testing).
    <p>
    <li>The user of a class implicitly tests it in an application program:
          if the application does not work as expected, it may indicate that
          the class(es) he/she is using are not correct (or, the user may
          just be using them incorrectly).
  </ul>
  The situation of a non-working application is interesting.
  Whose fault is it: the user of a class (for using it incorrectly) or
    the writer of a class (for implementing it incorrectly)
  We will examine this perspective at the end of the lecture, when we
    summarize classes (focusing on <b>private</b> members).
  <p>
  The most important thing to know about a class is that any member defined
   in a class can refer to any other member defined in that same class, EVEN IF
   ITS ACCESS MODIFIER IS <b>private</b>.
  So, access modifiers restrict what members defined OUTSIDE a class can
    access; they do not restrict what members defined INSIDE a class can
    access.
  This rule allows a class implementor to declare instance variables
    <b>private</b>, so they cannot be directly accessed by code OUTSIDE the
    class, and still write constructors/method INSIDE the class that access
    them; in fact, often accessor/query methods just return the values stored
    in some <b>private</b> instance variable.
  <p>
  To illustrate all this material, we will closely examine two classes and
    their drivers:
    <a href="../../programs/simpledicedemo.zip">
      SimpleDiceEnsemble</a> and
    <a href="../../programs/rationaldemo.zip">Rational</a>.
</td>
</tbody>
</table>



<!-- Fields -->

<a name="Fields"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Instance Variables</b></td>
<td width ="80%">
  Let's start by looking at the implementation details for two sample classes.
  The <b>SimpleDiceEnsemble</b> class must store information characterizing the
    ensemble (number of dice and sides per die) and information about its
    current state (number of rolls, pip sum, whether all die show the same
    numer of pips).
  It declares its instance variables as follows.
  <b><pre>  private int     numberOfDice;
  private int     sidesPerDie;
  private int     rollCount;
  private int     pipSum;
  private boolean allSame;</pre></b>
  <p>
  The <b>Rational</b> class is much simpler: it must store only the numerator
    and denominator of the rational number (fraction).
  It declares its instance variables as follows.
  <b><pre>  private int numerator;
  private int denominator;</pre></b>
  <p>
  Classes typically group the declarations of all their fields at the top or
     bottom (although there are no rules requiring this placement)
  Recall that Javadoc pages show fields first, so declaring them at the top
    is reasonable.
  Another perspective is that instance variables are <b>private</b> details,
     so declaring them at the bottom (out of the way) is reasonable.
  <p>
  Whenever <b>new</b> constructs an object, the first thing that it does is
    process all the field declarations in the class, which includes reserving
    space for all these field and initializing them.
  Unlike local variables, ALL FIELDS ARE INITIALIZED when they are declared:
    if we do not explicitly initialize them in their declarations, then Java
    implicitly initializes them: for the primitive types, it uses <b>0</b> for
     <b>int</b>, <b>0.</b> for <b>double</b>, <b>false</b> for
    <b>boolean</b>, and the null character for <b>char</b>; for all reference
    types  it uses <b>null</b> (meaning that they do not refer to any object).
  <p>
  In the examples above, all instance variables are initialized to <b>0</b>
     and <b>false</b>; in <b>SimpleDiceEnsemble</b> it is as if we had 
     explicitly written
  <b><pre>  private int     numberOfDice = 0;
  private int     sidesPerDie  = 0;
  private int     rollCount    = 0;
  private int     pipSum       = 0;
  private boolean allSame      = false;</pre></b>
  We will soon see that constructors can (and often do) store more appropriate
    values in these variables, based on the arguments that we supply to the
    constructor.
  So technically, when a constructor stores a value into an instance variable,
    it is reinitialization, not initialization, because an initial value has 
    already been stored there by Java, when it executes its declaration.
  Still, we will speak about initializing instance variables in constructors
    (and reinitialization if we want to be precise).
</td>
</tbody>
</table>


<!-- Constructors -->

<a name="Constructors">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">

<td width ="20%"><b>Constructors</b></td>
<td width ="80%">
  The main purpose of any constructor is to ensure that all the instance
    variables of the object being constructed are initialized correctly.
  This is done in the body of the constructor, which contains exactly the
   same statements that can appear inthe body of a <b>void</b> method.
  <p>
  For some instance variables a constructor may do nothing special: it leaves
    them with the initial values they received when declared.
  In other cases it initializes (actually reinitializes, given the
    discussion above) instance variables using the arguments passed to the
    constructor's parameters; the constructor often validates these arguments
    first (throwing <b>IllegalArgumentException</b> if they are incorrect).
  <p>
  There are classes, some quite complicated, in which constructors take no
    arguments and reinitialize no fields.
  In these cases, the fields are initialized correctly in their declarations
    (either explicitly or implicitly).
  The <b>Timer</b> class is one example of this kind of class.
  Its constructor looks like
  <b><pre>  public Timer ()
  {}</pre></b>
  In fact, if we fail to define any constructor for a class, Java will
    automatically supply one that looks like this one (with the appropriate
    class name).
  But, if we define even one constructor for a class, Java will not
    overload the constructor(s) by defining this one.
  <p>
  Most classes define at least one constructor (and many overload the
    constructor).
  These constructors always have parameter that help reinitialize instance
    variables.
  <p>
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>SimpleDiceEnsemble</b></td>
<td width ="80%">
  The first constructor defined in the <b>SimpleDiceEnsemble</b> class is
<b><pre>  public SimpleDiceEnsemble (int numberOfDice, int sidesPerDie)
      throws IllegalArgumentException {
    if (numberOfDice < 1)
      throw new IllegalArgumentException
        ("SimpleDiceEnsemble constructor: " +
         "Number of dice ("+numberOfDice+") < 1"); 
    if (sidesPerDie < 1)
      throw new IllegalArgumentException
        ("SimpleDiceEnsemble constructor: " +
         "Sides per die ("+sidesPerDie+") < 1"); 

    this.numberOfDice = numberOfDice;
    this.sidesPerDie  = sidesPerDie;
    //rollCount: see declaration for implicit initializaton to 0
    //pipSum and allSame indeterminate until roll
  }</pre></b>
  It first validates the values of its two parameters: if either does not make
     sense (we must have at least one die, and it must have at least one side),
     the constructor throws an <b>IllegalArgumentException</b> with an 
     appropriate message.
  If the parameters do make sense, it copies them into two of the instance
    variables (reinitializing them).
  The other three instance variables are not reinitialized: the initial
    values they received when decared are correct: <b>rollCount</b> should
    always start at zero, and <b>pipSum</b> and <b>allSame</b>, although they
    store zero/false, really represent nothing, because the dice haven't been
    rolled yet (so any values would work for these).
</td>
</tbody>
</table>
<a name="NameConflicts">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Interlude: Variable Name Conflicts and Resolving
                 them with "this"</b></td>
<td width ="80%">
  We must take a briefly diversion to discuss variable name conflicts and how 
    to resolve them with  the keyword <b>this</b>.
  There are three kinds of variable names in Java.
  <ol>
    <li>The name of a parameter (defined in the constructor/method header)
    <li>The name of a local variable (defined in the constructor/method body)
    <li>The name of a field (defined in its class)
  </ol>
  The Java compiler automatically implements a syntax constraint that prohibits
    defining a parameter with the same name as a local variable.
  So, the compiler would detect and report an error in following code
  <pre><b>  public static int returnIt (int a) {
    int a = 1;
    return a;
  }</b></pre>
  In fact, Java points at the local variable declaration of <b>a</b> and says,
    "Variable 'a' is already defined in this method".
  <p> 
  But, Java does allow instance variables to have the same names as parameters
    or local variables.
  When this happens, it is called a variable name conflict, because when we
    use that common name, there is a conflict as to what it means.
  Whenever there is a variable name conflict, the name by itself NEVER refers
    to the instance variable; it ALWAYS refers to the parameter or local
    variable.
  If instead we want to refer to the instance variable, we must preface its
   name with <b>this.</b> (<b>this</b> is a keyword).
  In a constructor, <b>this</b> is a reference to the object being constructed;
    and <b>this.numberOfDice</b> refers to the <b>numberOfDice</b> instance
    variable defined inside the class.
  In fact, writing <b>this.numberOfDice</b> is always a legal way to refer to
    the <b>numberOfDice</b> instance variable in the object being constructed,
    whether or not there is a variable name conflict.
  <p>
  So, in the constructor above, both parameter variables have a name conflict
    with two of the instance variables.
  The <b>if</b> statements, which check <b>numberOfDice</b> and
    <b>sidesPerDie</b>, are testing the parameter variables; the statements
<pre><b>  this.numberOfDice = numberOfDice;
  this.sidesPerDie  = sidesPerDie;</pre></b>
  store the values of the parameter variables (which disappear when the
    constructor finishes executing) into the instance variables (which exist so
    long as the object they are in exists).
  If we wrote <b>numberOfDice = numberOfDice;</b> then Java would just store
    the parameter's value back into the parameter variable: it stores nothing
    into the instance variable!
  Such a statement can cause a very hard to locate bug!
  <p>
  Another way around this whole "name conflict" problem is to change the
    parameter names; e.g. use <b>number</b> and <b>sides</b>.
  With no name conflicts, so we can write just <b>numberOfDice = number;</b>
    and <b>sidesPerDie = sides</b>.
  But, it is often the case that a well chosen name for an instance variable is
    replicated as a parameter name, because it captures exactly the right
    description; in such cases we must understand name conflicts and use
    <b>this</b> to resolve them.
  <p>
  To help avoid confusion, some style guidelines for Java specify that every
    access to an instance variable should be prefixed by <b>this.</b> to
    indicated explicitly it that is accessing a field.
  I'm still on the fence about this style rule.
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Back to Discussing Constructors</b></td>
<td width ="80%">
  The second <b>SimpleDiceEnsemble</b> constructor has a much different form.
  First, it has no parameters; second, it does not throw any exceptions
   (this information is all specified in the constructor's header).
  We could have written this constructor as
<pre><b>  public SimpleDiceEnsemble () {
    numberOfDice = 2;
    sidesPerDie  = 6;
  }</b></pre>
  which initializes the two instance variables so that the object represents
    two, six-sided dice.
  Note that because there are no parameter names in this constructor, so there
    are no name conflicts; therefore, we can use the instance variables
    directly with the <b>this.</b> prefix (although we could include this
    prefix for stylistic reasons).
  <p>
  But Java provides an even simpler way to define this constructor (even if 
    it requires us to learn a new language feature: a different context in
    which to use <b>this</b>).
  The actual constructor appears as
  <pre><b>  public SimpleDiceEnsemble () 
  {this(2,6);}</b></pre>
  In the constructor above <b>this</b> says "to initialize the instance
    variables, use another constructor from <b>this</b> class, one taking two
    <b>int</b> arguments.
  This is a common pattern, where one general constructor (with many
    parameters) is used by one or more special constructors (with fewer
    parameters) to do the initializations.
  Note that if we needed, we could add more statements to the constuctor AFTER
    this one (here, none are needed).
  <p>
  In fact, another way to handle all the initialization in this class is to
    declare
  <b><pre>  private int     numberOfDice = 2;
  private int     sidesPerDie  = 6;
  private int     rollCount;
  private int     pipSum;
  private boolean allSame;</pre></b>
  The first constructor would work as before,  reinitializing
    <b>numberOfDice</b> and <b>sidesPerDie</b> using the parameters.
  But the second constructor could be simplified to contain nothing in its
     body, because now when the instance variables are declared, they correctly
     represent two, six-sided dice.
  <p>
  Thus, constructors act as middlemen: they accept arguments, check these
    values for correctness, and ultimately use them to (re)initialize instance
    variables (if they are correct).
  Because instance variables are <b>private</b>, they can be initialized only
    in the declaration themselves, and reinitialized by a constructor defined
    inside the class.
  <p>
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Rational</b></td>
<td width ="80%">
  The first and most general constructor defined in the <b>Rational</b> class
    is
<pre><b>  public Rational (int numerator, int denominator)
    throws IllegalArgumentException {
    if (denominator == 0)
      throw new IllegalArgumentException
        ("Rational Construtor: - denominator 0");

    if (numerator == 0)
      denominator = 1;
    
    //Ensure non-negative denominator; if a rational is
    // negative, its numerator is negative
    if (denominator < 0) {
      denominator = -denominator;
      numerator   = -numerator;
    }
    
    //call gcd (greatest commmon divisor)
    //  a private static method defined in this class
    int common = gcd(numerator,denominator);  //or ...Rational.gcd(...)
    
    //name conflict
    this.numerator   = numerator  /common;
    this.denominator = denominator/common;
  }</b></pre>
  This constructor ultimately stores very special values into its two
    instance variables, carefully checking/altering its parameters before
    doing so.
  First, it cannot construct a rational value with a denominator or zero,
    is if the parameter has this values, it throws an exception.
  For all other numerators and denominators, it stores values according
    to the following rules.
  <ul>
    <li>Zero is always stored as 0/1
    <li>The denominator is always stored as a positive value
    <li>The numerator and denominator are reduced to have no common factors
  </ul>
  So, if we declare <b>Rational x = new Rational(2,-4);</b> then <b>x</b>
    refers to an object that stores -1 for the numerator and 2 for the
    denominator (try some other examples).
  The parameters are examined and changed as needed in all but the last two
    statements; at the end, <b>this.</b> is used to resolve the name conflicts.
  Note the call to the method <b>gcd</b>, which is a <b>static</b> method
    defined in this class.
  Any non-<b>static</b> method can call a <b>static</b> method.
  <p>
  The following more special constructors create new objects by using
    <b>this</b> (in the sense of using another constructor in this class
    to initialize the instance variables)
<pre><b>  public Rational (int numerator)
  {this(numerator, 1);}

  public Rational ()
  {this(0, 1);}</b></pre>
  <p>
  In the first of these constructors, we specify a only a numerator parameter
   and by using <b>this</b> construct a rational with that value over <b>1</b>;
   in the case of a parameterless constuctor, we construct a rational with the
   value <b>0</b> over <b>1</b>; we could also have written <b>this(0);</b>
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Blank Final</b></td>
<td width ="80%">
  Recall that we can declare 
    <a href="../morejava/lecture.html#Final">blank final</a> local variables.
  We can also declare blank final instance variables, but we must follow and
    additional constraint.
  Java allows us to declare an intance variable <b>final</b> and not initialize
    it in its declaration (the definition of blank final)
  But, we must initialize this variable in EVERY constructor that we write,
    otherwise the Java compiler will detect and report an error.
  Of course, the Java compiler will ensure that we never try to assign a
    second value to any <b>final</b> variable, including <b>final</b> instance
    variables.
</td>
</tbody>
</table>




<!-- Methods -->

<a name="Methods"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Methods</b></td>
<td width ="80%">
  Method bodies follow the same rules as constructor bodies, in terms of their
    use of parameter variables, local variables, and instance variables
    (and in terms of <b>this</b>, variable name conflicts, etc).
  In fact, when we illustrate the call frame for a non-<b>static</b> method,
    it will show an <b>implicit parameter</b> named <b>this</b> and we will see
     how this parameter gets initialized by an <b>implicit argument</b> when
     such a method is called.
  <p>
  Recall that methods are divided into two categories
  <ul>
    <li>Mutator/command methods can access and store into instance
          variables declared in the class; they change the state of the
          object they are called on.
    <p>
    <li>Accessor/query methods can access instance variables declared in the
          class, but not store into them; they do not change the state of the
          object they are called on.
  </ul>
  We cannot tell just by looking at a method header whether it defines an 
     accessor or a mutator (we must look at the method body or Javadoc).
  Yet, this is a fundamentally important piece of information about any method.
  <p>
  Often, one can tell which it is by the name of the method: accessor method
     names often begin with <b>get</b>.
  Also, <b>void</b> methods are almost always mutators: if they don't return a
    result, the only interesting thing they can do is change the state
    of the object they were called on.
  Some methods, like <b>nextToken</b> in the <b>StringTokenizer</b> clas act
    as both a mutator/command and accessor/query: changing an object's state
    and returning some value.
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>SimpleDiceEnsemble</b></td>
<td width ="80%">
  The <b>SimpleDiceEnsemble</b> class defines the <b>roll</b> method to be
    both a mutator/command and accessor/query (it is the only mutator in the
    class).
  It is defined as follows.
<b><pre>  public SimpleDiceEnsemble roll () {
    this.rollCount++;
    int firstThrow = this.randomDie();
    this.pipSum    = firstThrow;
    this.allSame   = true;
    for (int i=2; i<=this.numberOfDice; i++) {
      int nextThrow =  this.randomDie();
      this.pipSum += nextThrow;
      this.allSame = this.allSame && (nextThrow == firstThrow);
    }
    return this;
  }</pre></b>
  Here, for clarity in the discussion to come, I have prefaced each instance
    variable by <b>this.</b> (even though there are no name conflicts).
  The <b>roll</b> method has no parameters; it declares two local variables
    (<b>firstThrow</b> and <b>nextThrow</b>) that it uses to change the
    <b>rollCount</b>, <b>pipSum</b>, and <b>allSame</b> instance variables
  <p>
  Methods often have few or no parameters, because they primarily operate on
    the instance variables of an object.
  The pips showing for each die are computed by the <b>randomDie</b> method,
    which We will examine later.
  <p>
  Let us see how to hand simulate a call to this method by using a call frame.
  Pay close attention to how <b>this</b>, the implicit parameter, is 
    initialized by the implicit argument.
  Assume that we have declared
  <b><pre>  SimpleDiceEnsemble dice = new SimpleDiceEnsemble(2,6);</pre></b>
  and now we execute the statement
  <b><pre>  dice.roll();</pre></b>
  We illustrate the call of this method by the call frame below (assume that
    we roll a <b>3</b> on the first die and a <b>5</b> on the second).
  <p>
</td>
</tbody>
</table>
  <image src="images/thiscallframe.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  The implicit parameter <b>this</b> appears in every non-<b>static</b> call
    frame; <b>roll</b> declares no explicit parameters.
  <b>this is always initialized to refer to the object on which the
    method was called.</b>
  In this case, the call was <b>dice.roll()</b> so <b>dice</b> is the
    implcit argument and <b>this</b> is initialized to refer to the same
    object as <b>dice</b> (the equivalent of <b>this = dice</b>, which looks
    a lot like an argument initializing a parameter, even though both are
    implicit).
  <p>
  This method then examines and changes the instance variables
    in this object, as well as the local loop index variable <b>i</b>. 
  Hand simulate this code, again assuming <b>randomDie</b>
    returns <b>3</b> when it is called the first time and <b>5</b> the second.
  <p>
  Note that by writing <b>this.rollCount</b> we are explicitly showing which
    object is being referred to when the <b>rollCount</b> index variable is
    accessed.
  As stated above, even if we wrote just <b>rollCount</b>, because there are
    no name conflicts, the meaning of using this variable is exactly the same
    as <b>this.rollCount</b>.
  <p>
  Notice too the call to <b>this.randomDie()</b>; it means to call the
    <b>randomDie</b> method on the object that <b>this</b> refers to,
    which is the same object on which <b>roll</b> is called.
  Generally, non-<b>static</b> methods inside a class can call other
    non-<b>static</b> methods in that same class, to help them accomplish
    their task on an object.
  As in the case of instance variables, writing <b>randomDie()</b> has
    exactly the same meaning here: calling another method on the same object
    that <b>roll</b> was called on.
  The <b>randomDie</b> method must be able to access the <b>sidesPerDie</b>
    instance variable to compute a random roll of a die with that many sides.
  In the actual code for <b>SimpleDiceEnsemble</b>, <b>this</b> is used only
    where necessary.
  <p>
  Finally, the <b>return</b> statement returns the reference stored in
    <b>this</b>: the code above does nothing with the returned result, but
    if we had instead written
  <b><pre>  System.out.Println(dice.roll().getPipSum());</pre></b>
    Java would have called the <b>getPipSum</b> method on the returned
    reference, printing a value of <b>8</b>.
  <p>
  The <b>SimpleDiceEnsemble</b> class defines many accessor methods, two of
   which are shown below.
  <pre><b>  public int getRollCount ()
  {return rollCount;}
  

  public int getPipSum () throws IllegalStateException {
    if (rollCount == 0)
      throw new IllegalStateException("getPipSum - dice not rolled");

    return pipSum;
  }</b></pre>
  Accessors are often simpler than mutators.
  The forms of many of these methods are actually quite common: just
    returning the value stored in one of the <b>private</b> instance variables.
  Note that by making the <b>rollCount</b> and <b>pipSum</b> instance variables
    <b>private</b>, no code external to the class can directly examine or
     change these variables, possibly trashing them; yet such code can always
     determine the current values stored in these instance variables
     indirectly, by calling their accessor/query methods.
  So, accessor/query methods allow any code to determine the value stored in a
    <b>private</b> instance variable without giving that code direct access to
    change that instance variable.
  <p>
  Note that the second method first checks that the <b>pipSum</b> instance
    variable actually stores a computed value before returning it; if the dice
    have not yet been rolled, it throws the <b>IllegalStateException</b>: the
    object is not in a good state yet to call this method.
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Rational</b></td>
<td width ="80%">
  The <b>Rational</b> class is immutable.
  All its methods are accessors, although many construct and return values
    of primitive types or  references to new <b>Rational</b> objects (the
    result of computing on the state(s) of old one(s), just as many
    <b>String</b> and <b>BigInteger</b> methods do).
  In the <b>Rational</b> class, I have adopted the style of always using
    <b>this.</b> when accessing instance variables.
  Two simple accessors that DO NOT construct objects are
  <pre><b>  public int getNumerator()
  {return this.numerator;}


  public boolean equals (Rational other)
  {return this.numerator   == other.numerator && 
          this.denominator == other.denominator;}</b></pre>
  The first method just returns the value stored in the
     <b>private numerator</b> instance variable (but, we could write just
     <b>return numerator;</b>).
  <p>
  The second method returns whether or not (a) the object the method is called
    on, and (b) the object the method is passed as a parameter, are equal.
  Given the canonical way <b>Rational</b> stores these objects (zero as
     <b>0/1</b>; denominators always positive; no common factors), they are
     equal if and only if both pairs of instance variables are equal.
  Note that if we did not store these objects canonically, then this method
    would not work: e.g., comparing the rational 1/2 vs 2/4; the rational 0/1
     vs 0/12; the rational -1/2 vs 1/-2.
  Here, using <b>this.</b> adds a certain symmetry to our code (but, we could
    write just  <b>numerator == other.numerator</b> and
     <b>denominator = other.denominator</b>).
  <p>
  Finally, note that there is NOTHING SPECIAL about the parameter name
   <b>other</b> (I've known students to get superstitious about this
   parameter name): so long as the parameter name appears identically in the
   code, we can use any name we want.
  <p>
  We illustrate this method call by the call frame below.
  <p>
</td>
</tbody>
</table>
  <image src="images/equals.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  Notice that the implicit parameter, <b>this</b>, refers to the object that
    <b>a</b> refers to: the implicit argument; the explicit parameter,
    <b>other</b>, refers to the object that the explicit argument <b>b</b>
    refers to. 
  Again, there is nothing special about the parameter named <b>other</b>; we
    can name this parameter anything we want.
  If we called <b>b.equals(a)</b> the references stored in the implicit and
    explicit parameters would be swapped.
  This method call returns a result of <b>false</b>, because although the
    numerators are the same, the denominators are different.
  <p>
  Two more complicated accessors that DO construct objects are
<pre><b>  public Rational abs()
  {return new Rational(Math.abs(this.numerator),this.denominator);}


  public Rational add (Rational other) { 
    int a = this.numerator;          //  a     c     ad + cb
    int b = this.denominator;        // --- + --- = ---------
    int c = other.numerator;         //  b     d        bd
    int d = other.denominator;       //
    
    return new Rational(a*d + c*b, b*d);
  }</b></pre>
  The <b>abs</b> method constructs and returns a new <b>Rational</b> object,
    whose state is the absolute value of the state of the object that this
    method was called on; we know the <b>denominator</b> is always positive,
    so we can use its value directly.
  The return type of <b>Rational</b> means that this method returns a
    reference to an object that is an instance of the <b>Rational</b> class.
  In the <b>abs</b> method, we return a newly constructed <b>Rational</b>
    whose numerator is non-negative (all denominators are already positive).
  <p>
  The <b>add</b> method constructs and returns a new <b>Rational</b> object,
    whose state is the sum the states of the object that this
    method was called on and the object passed as the explicit argument.
  If we wrote
    <b><pre>  Rational x = new Rational(1,2), y = new Rational(1,3);
  Rational z = x.add(y);</pre></b>
  We would illustrate these variable and method call by the call frame below
  (note that for space reasons, I have left out the four local variables
   <b>a</b>, <b>b</b>, <b>c</b>, and <b>d</b>, which store the values
   <b>1</b>, <b>2</b>, <b>1</b>, and <b>3</b> respectively).
  <p>
</td>
</tbody>
</table>
  <image src="images/add.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  In this <b>add</b> method, we return a newly constructed <b>Rational</b>
    whose numerator and denomiator are computed according to the standard
    algorithm for adding rational values.
  Note that the code in the complicated constructor for this class will
    automatically reduce the results to lowest terms.
  If we call <b>x.add(y)</b> then <b>this</b> refers the state of the object
    that <b>x</b> refers to: the object on which <b>add</b> is called; and
    <b>other</b> refers to the state of the object that <b>y</b> refers to:
    the object that is an argument to <b>add</b>
  Of course, if we call <b>y.add(x)</b> then <b>this</b> and <b>other</b>
    would refer to the opposite objects (but since addition is symmetric, it
    would return the same result).
  <p>
  Because this method returns a reference to a <b>Rational</b> object, we can
    cascade our method calls. If we wanted to compute the sum of the objects
    all three variables refer to, we can write
  <b>x.add(y).add(z)</b> which first creates an object containing the sum
   of <b>x</b> and <b>y</b>, and then it adds this object to <b>z</b>,
   producing an object storing the total sum.
  We can also write <b>x.add(y.add(z))</b>, which produces the same result
    by adding objects in a different order.
  <p>
  Each of these classes include a <b>toString</b> method that returns a
    <b>String</b> catenating together all the state of the object (which is
    used mostly for debugging purposes).
  Such <b>toString</b> methods are often easy to write; examine them.
</td>
</tbody>
</table>



<!-- Private & Static Methods -->

<a name="SpecialMethods"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Special Methods</b></td>
<td width ="80%">
  There are two kinds of special methods that we examine here briefly: 
    <b>private</b> and <b>static</b>.
  Both kinds occur in classes that we will write, but they do not occur
    frequently.
</td>
</tbody>
</table>
<a name="PrivateMethods">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Private Methods</b></td>
<td width ="80%">
  First, sometimes a class will define <b>private</b> methods.
  Such a method is callable only from other methods defined in that class,
    not from any methods outside the class to use.
  Typically, <b>private</b> methods are small helper methods; they are useful
    for the implementor of the class, but not useful (or dangerous) for someone
    outside the class; like many methods, they hide some details.
  The <b>SimpleDiceEnsemble</b> defines the <b>randomDie()</b> method, which
    uses a random numuber generator to simulate throwing one die.
  The <b>roll</b> method has two calls to this one: one outside its loop and
    one inside the loop (which may get executed multiple times).
<pre><b>  private int randomDie ()
  {return (int)Math.round(Math.random()*sidesPerDie + .5);}</pre></b>
  Notice that this method uses the instance variable <b>sidesPerDie</b>.
  The <b>static</b> method <b>random</b> defined in the <b>Math</b> class 
   always returns a <b>double</b> result in the semiopen range <b>[0,1)</b>; 
   the expression transforms this value into an <b>int</b> between <b>1</b> and
   <b>sidesPerDie</b>, with each value equally likely to occur.
</td>
</tbody>
</table>
<a name="StaticMethods">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Static Methods</b></td>
<td width ="80%">
  Second, sometimes a class (one with a constructor) will define <b>static</b>
    methods, either <b>public</b> or <b>private</b>.
  The <b>Rational</b> class defines the <b>prompt</b> method as
    <b>public static</b>.
<pre><b>  public static Rational prompt(String s) {
    System.out.println(s);
    for (;;)
      try{
        int numerator   = Prompt.forInt("  Enter numerator  ");
        int denominator = Prompt.forInt("  Enter denominator");
        return new Rational(numerator,denominator);
      }catch (Exception e)
        {System.out.println("Illegal value entered; try again");}
  }</pre></b>
  Any class can call this method in its code as follows.
    <pre><b>  Rational x = Rational.prompt("Enter x");</b></pre>
  Recall that to use a <b>static</b> method outside a class, we must
    prefix its name by the name of its class NOT A REFRENCE TO AN OBJECT
    OF THAT CLASS.
  The console interaction would look like
  <pre><b>  Enter x
    Enter numerator  : 1
    Enter denominator: 2</b></pre>
  <p>
  Why make this method <b>static</b>?
  Because its sole purpose it to construct/return a reference to an object.
  If we made this method non-<b>static</b>, we would have to write something
    like
  <pre><b>  //get an object (storing 0/1) to call prompt with
  Rational x = new Rational();
 
  //store new value in x, throwing away 0/1 that we just created.
  x = x.prompt("Enter x");</b></pre>
  In this case, we first construct an object to call the non-<b>static</b>
    method on, but we just throw away the original object, replacing it by a
    reference to an object containing the user-input rational.
  Thus, it is much simpler and easier to use this method if it is 
     <b>static</b>.
  <p>
  The <b>Rational</b> class also defines the <b>gcd</b> method as
    <b>private static</b>.
<b><pre>  private static int gcd (int x, int y) {
    ...lots of complicated code
  }</b></pre>
  This method is called only in the first constructor, to reduce to lowest
    terms the numerator and denominator (by dividing-out all common factors).
  Because this method is defined in the <b>Rational</b> class, we can call it
   as either <b>gcd(numerator,denomiator)</b> or as
    <b>Rational.gcd(numerator,denomiator)</b>.
  Note that because this method is <b>private</b>, it cannot be called
    from anywhere but inside a constructor or method defined in this class.
  <p>
  Finally, notice that the <b>randomDie</b> method cannot be <b>static</b>.
  That is because it must refer to the instance variable <b>sidesPerDie</b>;
    <b>static</b> methods can refer only their parameter variables and local
     variables (see <b>prompt</b> and <b>gcd</b>).
  The fact that we can call <b>static</b> methods without objects means
    that they have no guaranteed access any object's instance variables.
  Of course, we could have rewritten it as a <b>static</b> method if we added
    a parameter:
<pre><b>  private static int randomDie (int max)
  {return (int)Math.round(Math.random()*max + .5);}</pre></b>
  and then called this method in <b>roll</b> as <b>randomDie(sidesPerDie)</b>,
  but I thought the former way was simpler.
</td>
</tbody>
</table>


<!-- Static Fields -->

<a name="StaticFields"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Static Fields</b></td>
<td width ="80%">
  There are two main uses of <b>static</b> fields.
  The first and foremost is a place to declare constants (using the
    <b>final</b> access modifier) that other classes can use.
  For example, the <b>DateUtility</b> class declares <b>final</b> variables
    naming all the months.
  The <b>Rational</b> class declares the constants <b>ZERO</b> and <b>ONE</b>
   (both storing references to an object representing one of these values).
  Recall that one can call mutator on <b>final</b> variables to change their
    states, but one cannot store a new reference (to a different object) in
    a <b>final</b> variable.
  Because <b>Rational</b> is an immutable class (it contains no mutator
    methods) the instance values stored in these objects always will remain
    the same.
  <p>
  The second use of <b>static</b> fields is more subtle: we use them to store
    information shared by all objects in a class.
  Normally, each objects stores its own state in instance variables; but
   <b>static</b> variables are stored in a special spot that all objects
   can access.
  <p>
  Suppose that we wanted to be able to know how many times
    objects were constructed from a class (i.e., how many times <b>new</b> 
    operated on a certain class).
  We can declare <b>private static int allocated = 0;</b> in the class, and
    then include  the statement <b>allocated++;</b> in each constructor.
  Now, whenever an object is constructed, the <b>static</b> variable shared
    by all the objects in the class is incremented.
  Finally, we could define 
    <pre><b>  public static int getAllocated ()
  {return allocated;}</b></pre>
    to return its value.
  <p>
  So, what would happen if we did not declare this field to be <b>static</b>.
  If this information were stored in an instance variable (the only other
    choice), each object would store this value as part of its own state; each
    time an object was constructed it would initialize this instance variable
    to zero and then increment it in the constructor.
  Thus, if we constructed <b>n</b> objects, we would have <b>n</b> instance
    variables storing <b>1</b>, not one <b>static</b> field storing <b>n</b>.
  <p>
  The final strangeness about <b>static</b> fields is that their declarations
    (and intializations) are done just once, the first time Java needs to
    do something with a class.
  Contrast this with instance variable declarations which are executed each
    time that <b>new</b> constructs an object.
  <p>
  Most fields in class with constructors are instance variables.
  The ones that aren't are mostly the constants described above.
  If you see other <b>static</b> fields, study them careful to understand them.
</td>
</tbody>
</table>



<!-- Writing Javadoc -->

<a name="Javadoc"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Writing Javadoc Comments</b></td>
<td width ="80%">
  Java is the first popular programming language to come with a special
    program (of course, written in Java) for documenting its classes.
  This is important, because most interesting programming involves locating a
    collection of useful classes and determining what constructors
    and methods they define, and how to use them (based on their syntax and
    semantics).
  Having all this information stored, indexed, and viewable via standard web
    browsers (with links), has made a big difference in my programming
    efficiency.
  <p>
  We have already studied how to read web pages produced by Javadoc (both for
    the standard Java library and classes that I have provided for this
    course).
  Now we will begin to learn how to write our own Javadoc comments, to document
    classes that we write ourselves.
  <p>
  We can run Javadoc on Java source code (<b>.java</b> files).
  Even if we have added none of the special comments desrcribed below,
    Javadoc still produces a skeletal web page listing all the fields,
    constructors, and methods in <b>Summary</b> and <b>Detail</b> tables.
  Such web pages, though, won't have any commentary, and none of the 
   special <b>parameter</b>, <b>return</b>, and <b>throws</b> information.
  <p>
  In general, we can further document our classes with comments.
  Javadoc ignores general comments, but reads and process comments written 
    in a special form: comments that start with <code><b>/**</b></code>.
  These are called Javadoc comments.
  Notice that a Javadoc comment is also a general comment (starting with
    <b>/*</b>) so it is also treated as whitespace by the Java compiler.
  <p>
  Here is the Javadoc commment prefacing the <b>DiceEnsemble</b> class.
  View it along with the Javadoc pages it generates in the
    <a href="../../../common/classes/doc/index.html" target="_blank">
    Javadoc of Course API</a>.
  <pre><b>  /** 
   * Objects constructed from the &lt;code&gt;DiceEnsemble&lt;/code&gt;
   *   class act as collections of dice.
   * The number of dice in an ensemble (and the number of sides of
   *   each die)  can be controlled by the programmer.
   * The class models the basic operations need to roll the dice and
   *   determine the number of pips showing -both for individual dice
   *   and for the entire  ensemble.   
   * 
   * @author Richard E. Pattis
  */</b></pre>
  Javadoc <b>copies</b> the contents of this comment into the web page that it
    builds for this class; it appears near the top, right before the first
    <b>Summary</b> table.
  I write such comments in the <b>.java</b> file a special style, for ease of
    editing; each line is a sentence, with sentences longer than one line
    indented.
  The web browser renders this text as a nice paragraph.
  <p>
  Note that I said that Javadoc <b>copies</b> the contents of the message...
    and the web browser renders the text...
  This means that the comment can us embedded HTML markup tags; these tags are
    copied into the web page and rendered by the browser, just like normal
    HTML tags in text.
  Notice the use of <b>&lt;code&gt;DiceEnsemble&lt;/code&gt;</b> to render the
    name of this class in the <b>code</b> font; in a multi-paragraph
    description, we use <b>&lt;p&gt;</b> to separate the paragraphs.
  Generally, use what HTML markup tags you are familiar with to format your
    documentation.
  <p>
  Finally, note the special Javadoc markup tag <b>@author</b>; Javdoc makes
    special use of these tag, often creating special HTML for them.
  <p>
  A typical constructor or method is documented by a Javadoc comment of the
    following form; the comment appear in the <b.java</b> file right before
    the member it documents.
  <pre><b>  /**
  * One sentence. More documentation
  * @param  tag(s)
  * @return tag(s)
  * @throws tag(s)
  */</b></pre>
  This section always begins with at least one sentence ended by a period;
    other material (e.g., <b>More documentation</b>) can follow.
  All information up to and including the first period appears in the
    <b>Summary</b> section; it also appears in the <b>Detail</b> sections,
    followed by any other material (e.g., <b>More documentation</b>).
  <p>
  Again, each appearance of <b>@something</b> is a special Javadoc markup tag
    that Javadoc recognizes and processes by inserting special HTML markup
    commands to highlight the information coming after the tag.
  We should include only those tags that are relevant: a constructor/method 
   with no parameters has no  <b>@param</b> tags; otherwise we use one tag per
    parameter.
  A constructor or <b>void</b> method has no <b>return</b> tag; otherwise we
    use only one tag.
  A constructor/method throwing no exceptions has no <b>@throws</b> tags;
    otherwise we use one tag per exception. 
  <p> 
  The information documented by all these tags appears in the <b>Detail</b>
    sections.
  The words <b>Parameters</b>, <b>Returns</b>, and <b>Throws</b> are
    highlighted.
  The first word after <b>@param</b> should be the name of the parameter; it
    automatically is rendered in the <b>code</b> font, followed by a dash, and
    then the rest the information we write.
  The first word after <b>@throws</b> should be the name of the exception; it
    appears as a link to the class of that name, followed by a dash, and then
    the rest the information that we write.
  Again, we can embed any HTML markup tags directly in any comments processed
    by Javadoc (it will just copy them to the web page, where the browswer will
    interpret them).
  <p>
  Here are the Javadoc comment that precede the first constructor and the
    <b>roll</b> and <b>getPips</b> methods in the <b>DiceEnsemble</b> class.
  Notice that the <b>One sentence.</b> comment ends in a period, while the tags
    don't; words enclosed inside the <b>code</b> HTML commands are displayed
    in a special font.
  I group all the parameter tags together, separated by blank lines.
<pre><b>  /** 
  * Constructs a &lt;code&gt;DiceEnsemble&lt;/code&gt; object, specifying
  *   the number of dice and the number of sides per die.
  *
  * @param  numberOfDice specifies the number of dice in the ensemble
  * @param  sidesPerDie specifies the number of sides on each and every
  *           die in the ensemble (the pips showing are 1, 2, 3, ...
  *           &lt;code&gt;sidesPerDie&lt;/code&gt;)
  *
  * @throws IllegalArgumentException if either parameter is less than 1
 */
  public DiceEnsemble (int numberOfDice, int sidesPerDie)
    throws IllegalArgumentException
  {...}



  /** 
   * Returns this &lt;code&gt;DiceEnsemble&lt;/cod&gt; after rolling every
   *   die in it.
   * By using the return type <code>DiceEnsemble</code> instead of
   *   &lt;code&gt;void&lt;/code&gt;, we can "cascade" method calls, writing
   *   expressions such as: &lt;code&gt;d.roll().getPipSum()&lt;/code&gt;
   *   instead of writing roll as its own statement.
   *
   * @return the rolled dice ensemble
  */
  public DiceEnsemble roll ()
  {..}



  /** 
   * Returns the the number of pips showing on die &lt;code&gt;dieIndex&lt;/code&gt;
   *   (changed each time the ensemble is rolled).
   *
   * @param  dieIndex specifies the index of the die whose pips are
   *           returned
   *
   * @throws IllegalStateException if this ensemble has not been rolled
   * @throws IllegalArguementException if &lt;code&gt;dieIndex&lt;/code&gt;
   *           is outside the range [1,getNumberOfDice()].
   *
   * @return the the number of pips showing on die &lt;code&gt;dieIndex&lt;/code&gt;.
  */
  public int getPips (int dieIndex)
     throws IllegalStateException, IllegalArgumentException
  {...}</b></pre>
  <p>
  The documentation for 
    <a href="http://java.sun.com/j2se/1.4/docs/tooldocs/win32/javadoc.html"
      target="_blank">Javadoc</a>
    appears on the Sun Microsystems web site. 
  If you want to know more about Javadoc than this course covers, start
     reading here.
  <p>
  I will partially describe two other very interesting Javadoc tags:
    <b>@see</b> and <b>@link</b>.
  Both tags are use to create links to other fields, constructors, or methods
    either on this page or any other page documenting another class.
  The <b>@see</b> tag collects the references and puts them in a special
    section; the <b>@link</b> tag embeds links in any documentation, right
    where it appears.
  A typical use is
  <b><pre>  ...This method should never be called until first calling
  <b>the {@link DiceEnsemble#roll roll}</b> method to ensure the dice
  actually have some pips showing.</pre></b>
  The first piece of information is the way to refer to some field,
    constructor, or method; the second piece of information is what word the
    link should  appear as.
  The Javadoc web page has much more information about this interesting tag,
    including the following general forms.
  <p>
</td>
</tbody>
</table>
  <image src="images/linksyntax.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  <p>
  We can run the Javadoc program (to produce Javadoc web pages) from the
    cammand line; it has many interesting options.
  The standard way I run it is
<b><pre>  javadoc -d publicdocs -public *.java -link http://java.sun.com/j2se/1.3/docs/ap</pre></b>
  If you don't want to type all this information, you can download the
     <a href="../../../common/classes/generatedocs.bat">
       Generate Javadoc</a> batch file, which contains this command and another
    (one to generate Javadoc from the perspective of an implememtor, including
    all the <b>private</b> stuff).
  This batch file is also available under <b>Miscellaneous</b> in the  
     <a href="../../../common/online.html">Online Resources</a> web page.
  <p>
  Put this file in a folder that contains the <b>.java</b> files that you want
    to run through Javadoc.
  If you are runing under Windows, double-click the file named
    <b>generatedocs.bat</b>, and you will see a console window pop up; this
    window shows the Javadoc utility running (otherwise, cut/paste/execute
    the lines from this file).
  It creates a folder named <b>publicdocs</b> containing all the Javadoc
    comments related to public class members (the ones we have been reading as
    class users); and a folder named <b>privatedocs</b> containing all the
     Javadoc comments related to public and private class members (the ones
     we would read as class implementors).
  Each folder contains a file named <b>index.html</b>, which acts as the root
    for all the Javadoc web pages in that folder; click on it to start viewing
    the Javadoc
  <p>
  It can take a few seconds or so for each class that Javadoc examines
    and extracts into a web page.
  For debugging purposes (if your <b>@link</b> tags contain errors), twice
    you will be asked to press any key to continue (so if there are errors,
    you can stop and examine them, instead of having them scroll by).
</td>
</tbody>
</table>



<!-- Eclipse -->

<a name="Eclipse2"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Instance Variables in the Eclipse Debugger</b></td>
<td width ="80%">
  The Eclipse debugger includes a few useful features to illustrate classes
    from which we construct objects.
  All the material that we discussed previously in this lecture note (about
    the editor and  debugger) concerning <b>static</b> methods works for
    non-<b>static</b>  methods as well.
  We know that whenever a method is called, the debugger displays all its
    its parameter variables and local variables in the <b>Variables</b> tab.
  But in addition, whenever a non-<b>static</b> method is called on an object,
    this pane also displays a special entry named <b>this</b> (surprised? it
    was the same in the call frames) that refers to that object's instance
    variables (so, our call frames do accurately reflect the main aspect of
    <b>this</b>).
  <p>
  Suppose that we stop on the first line inside the <b>roll</b> method.
  The full name of the method (<b>packageName.ClassName.methodName</b>)
     appears  underneath<b> Thread[main]</b>); recall that <b>temp</b>
     is the package name for this class.
  Note that in the <b>Variables</b> tab </b>this</b> appears on a single line
   that is preceded by a box showing a <b>+</b> and followed by an id
   number (ignore the id number).
  <p>
</td>
</tbody>
</table>
  <image src="images/thisvars1.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  The box is is called a <b>disclosure box</b>; it is currently in its
    <b>non-disclosing</b> (or elided) state.
  By clicking this box, it toggles to it <b>disclosing</b> state: its contents
    will be replaced by a <b>-</b> and all the instance variables in the
    object <b>this</b> refers to will appear, indented, under <b>this</b>.
  (clicking this box again will return it to its non-disclosing state).
  This is the first time these two, six-sided dice are being rolled, so
    the instance variables <b>rollCount</b>, <b>pipSum</b>, and <b>allSame</b>
    all display their initial values.
  <p>
</td>
</tbody>
</table>
  <image src="images/thisvars2.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  By watching these instance variables change while single stepping through
    the statements in this method, we can see how this mutator/command changes
    the state of the object.
  When the last line of the method is reached, the instance variables now
   display their new values.
  <p>
</td>
</tbody>
</table>
  <image src="images/thisvars3.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  Understanding how the debugger treats objects is crucial to being able to
    debug classes quickly.
  Practice using these kinds of stepping and object observations using the
    drivers for the <b>SimpleDiceEnsemble</b> and <b>Rational</b> classes.
</td>
</tbody>
</table>


<!-- Class Roundup -->

<a name="ClassRoundup"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Summary and Class Invariants</b></td>
<td width ="80%">
  This has been a long lecture, discussing many interesting language features,
    and tons of technical terms.
  It looked as classes from a new perspective -that of a class implementor-
    leveraging off all the information that we have learned previously -as
    class users.
  Let me try to review the most important ideas here briefly.
  <p>
  We began by studying the form and meaning of <b>static</b> method
    definitions, along with the <b>return</b> and <b>throw</b> statements.
  We learned how to hand simulate these methods in call frames and how to
    use them in programs -in two ways: directly in an application
    (along with a <b>main</b> method) and as definitions in a library class.
  We examined how the Metrowerks IDE makes using methods easier (in the editor
    and the debugger).
  <p>
  Then we discussed how to define instance variables in a class, along with
    the related topics of how to write constructors that help initialize them
    and methods to manipulate them.
  We learned that a <b>private</b> member can be accessed from any other
    members in the class it is defined in (but not from members outside this
    class).
  We found two interesting uses for the keyword <b>this</b>: to specify
   instance variables (in variable name conflicts) and to help in constructors.
  Finally, we discussed writing Javadoc to document classes and their members.
  <p>
  Finally, I would like to look one more time at constructors and methods
    as middlemen with respect to <b>private</b> instance variables.
  An <b>invariant</b> is a statement about something that remains true while
    that something is manipulated; if such a statement is true, we say it is
    satisfied.
  A <b>class invariant</b> is a set of statements about the instance variables
    of objects constructed from the class: these statements must be true when
    an object is first constucted, and they must remain true after each method
    is called.
  <p>
  Of course, accessor/queries do not change state, so they can be ignored when
    discussing class invariants.
  In fact, many interesting class are immutable: e.g., <b>String</b>,
    <b>BigInteger</b>, and <b>Rational</b>; so their class invariants have to
    be true only after object construction.
  The <b>Rational</b> class, for example, has three invariants.
  <ul>
    <li>Zero is stored with a numerator of zero and a denominator of one.
    <li>The denominator is always stored as a positive value.
    <li>The numerator and denominator are reduced to have no common factors.
  </ul>
  The constructor carefully ensures that these are all true.
  Various methods (especially <b>equals</b>) assume that invariants are true
    in order to operate correctly (and sometimes efficiently).
  <p>
  The <b>DiceEnsemble</b> class, for another example, requires positive values
    for the number of dice and sides per die.
  Its constructor also ensures this invariant and the only accessor,
    <b>roll</b> does not change these instance variables.
  <p>
  Using <b>private</b> instance variables helps an implementor ensure class
    invariants.
  By declaring instance variables to be <b>private</b>, we know that the
    only place they can change is in the code for methods defined in that
    class. 
  Users of the class cannot change these variables directly and possibly
    make an invariant unsatisfied.
  <p>
  Imagine what would happen if we declared <b>numerator</b> or
    <b>denominator</b> to be <b>public</b>.
  An incompetent or malicious programmer could store anything in such
    instance variables, violating any or all of the invariants stated above.
  Thus, a class implementor prefers <b>private</b> instance variables
    (and sometimes <b>public final</b> ones will work too) so that users of the
    class cannot do bad things to its instances.
  This access modfier ensures that the constructors and methods of the class
    have ultimate control over what state changes are made to objects.
  <p>
  Now we come to how this aids us when debugging.
  Imagine a scenerio where the user of a class is getting bad results in 
    an application program; who is to blame, the user or implementor of the
    class.
  If an object's state ever doesn't satisfy its class invariants, the
    implementor has definitely made a mistake.
  If an object's state always satisfies its class invariants, but the
    postcondition of a method is not satisifed, then the implementor has also
    made a mistake.
  All other mistakes are the result of the user of a class.
  <p>
  A well designed class is a cohesive collection of related instance
    variables, the constructors that initialize them, and the methods that
    manipulate them.
  Each method performs some small, well-defined service.
  Taken together, these methods allow programmers to do everything needed to
    objects constructed from the class.
  It is the composition of these coordinated services, under control of the
    programmer, that make well-designed classes easy to reuse in many related
    applications.
  So, in a well-designed class, it is common to write many small methods (the
    classes that we have seen are typical); this is true even in more 
    complicated classes, which may have many more constructors, methods, and
     instance variables, but whose method definitions are still quite small.
  <p>
  It is not a goal of ICS-21 (nor 22 for that matter; ICS-23 gets closer with
     collection classes) to teach you how to design a (re)usable class.
  It is a goal to teach you how to read and use classes; it is also a goal for
    you to be able to implement (write the <b>.java</b> file) for a
    well-designed (by someone else) class.
  <p>
  Finally, if you want to read the <b>.java</b> source code files for any of
    Java's standard library classes, you can find them in the <b>src.jar</b>
    file in the <b>jdk1...</b> folder (or whatever folder representes the
    top of your Java file system: mine is
     <b>C:\Program Files\Java\jdk1....</b>.
  Open this file with <b>zip</b> and you can select and examine any of the
    nearly 2,000 files it contains.
  These files comprise industrial-strength code written by excellent
    programmers: don't expect to breeze through the code, but it is
    remarkably readable (say, compared to C/C++ libraries).
</td>
</tbody>
</table>


<!-- Problem Set -->

<a name="ProblemSet"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem Set</b></td>
<td width ="80%">
  To ensure that you understand all the material in this lecture, please solve
    the the announced problems after you read the lecture.
  <p>
  If you get stumped on any problem, go back and read the relevant part of the
     lecture.
  If you still have questions, please get help from the Instructor, a CA,
    or any other student.

  <ol> 
     <li>Write a statement that calls any of the "result-returning" methods (maybe just
           display the returned result on the console) and hand simulate its execution with
           a call frame.
     <p>
     

     <li>Java allows methods to have no parameters; such methods are defined and called by
           specifying their name followed and an empty argument list: e.g., <b>f()</b>.
         Use your knowledge of the semantics of the <b>return</b> statement to explain what
           happens for the following method and its calls.
         Don't get confused by what you think it does (or want it to do): follow the rules.
         <b><pre>  int f()
  {
    return 1;
    return 2;
  }</pre></b>
         What is displayed by <b>System.out.print("1st f = " + f() + " 2nd f = " + f());</b>
     <p>

  <li>Write a  method named <b>characteristic</b>, which returns 1 if its parameter is <b>true</b>
        and 0 if its parameter is <b>false</b>.
  <p>
     

  <li>Write a  method named <b>abs</b>, which returns the absolute value of its
        <b>int</b> parameter (it always returns the non-negative magnitude of its parameter;
        don't call the <b>Math.abs</b> method).
  <p>
     

  <li>Write a  method named <b>signum</b>, which returns <b>-1</b> if its <b>double</b> parameter
        is negative, <b>0</b> if its parameter is zero, and <b>+1</b> if its parameter is positive.
  <p>
     

  <li>Write a  method named <b>constrain</b>.
      Calling <b>constrain(1,5,10)</b> returns <b>5</b> because this middle value is between the first
         and third values.
      Calling <b>constrain(1,-5,10)</b> returns <b>1</b> because this middle value is smaller than the first
         value, so the method returns the first value.
      Calling <b>constrain(1,15,10)</b> returns <b>10</b> because this middle value is larger than the third
         value, so the method returns the third value.
      Thus, this method returns the middle value, but it is constrained to lie between the first and
        third values inclusize.
  <p>
     

  <li>Write a  method named <b>forChar</b>.
      We could call the method as <b>forChar("Enter an Upper-Case Letter", 'A', 'Z')</b> which
        always returns a <b>char</b> whose ASCII value is between <b>'A'</b> and <b>'Z'</b>; or
      we could call the method as <b>forChar("Enter a Digit", '0', '9')</b> which
        always returns a <b>char</b> whose ASCII value is between <b>'0'</b> and <b>'9'</b>.
  <p>
     

  <li>Why can't we write a  simple method named <b>makeChange</b>, which is supplied the amount of change
        to vend, and returns the number of quarters, dimes, nickels, and pennies needed to vend the
        required change.
      How do you think we can write a method to solve such a problem?
  <p>
     

  <li>Write a  method named <b>majority</b>, which returns the most frequently occuring value
        of its three <b>boolean</b> parameters: no matter the values, at two of three (and possibly
        three of three) will have the same value.
      For example, the call <b>majority(true,false,false)</b> returns <b>false</b>, while
        the call <b>majority(true,true,true)</b> returns <b>true</b>.
  <p>
     

  <li>Write a  method named <b>median</b>, which returns the middle value of its three arguments.
      For example, the call <b>median(3,2,5)</b> returns <b>3</b> because it is between <b>2</b>
        and <b>5</b>.
  <p>
     

  <li>Assume that we declare <b>char roman;</b> and store in it a character that is a
        roman numeral.
      Write a method that returns the <b>int</b> equivalent of the Roman numeral:
        <b>I</b> is <b>1</b>, <b>V</b> is <b>5</b>, 
        <b>X</b> is <b>10</b>, <b>L</b> is <b>50</b>, <b>C</b> is <b>100</b>,
        <b>D</b> is <b>500</b>, <b>M</b> is <b>1000</b>; if it stores any other character,
        return <b>-1</b>.
  <p> 
 
  <li>Write a  method named <b>isPrime</b>, which returns whether or not its parameter is a
        prime number.
      A prime number has only 1 and itself as divisors: neither 0 nor 1 are considered prime; 2 is
       the smallest prime number, then 3, 5, 7, 11, etc.
      Hint: Use a <b>for</b> loop to check for possible divisors, along with the <b>%</b> operator.
  <p>
     

  <li>Write a  method named <b>harmonic</b>, which takes one <b>int</b> parameter and returns a
        <b>double</b> value representing the harmonic series of that order.
      <b>harmonic(n)</b> is defined as <b>1 + 1/2 + 1/3 + ... 1/n</b>.
      So <b>harmonic(2)</b> returns <b>1.5</b>; and <b>harmonic(4)</b> returns <b>2.083333</b>.
  <p>
     

  <li>Write a  method named <b>fw</b>, which returns the number of characters needed to print its
        integer parameter.
      For example, <b>fw(5)</b> returns <b>1</b>; <b>fw(-5)</b> returns <b>2</b>;
        <b>fw(453)</b> returns <b>3</b>; and <b>fw(-243)</b> returns <b>4</b>.
      Hint: the number of digits in a number is related to how many times you can divide it
        by <b>10</b> and still have a non-zero value; treat negative numbers specially.
  <p>
     

  <li>Write a method named <b>block</b> that has an <b>int</b> height and width parameter, and a
      <b>char</b> parameter.
      This method returns a <b>String</b> which when printed displays a rectangle of that the specified 
      height and width, consisting of the specified character.
      Calling <b>System.out.println(block(5,20,'*'));</b> would print.
      <b><pre>  ******************** 
  ******************** 
  ******************** 
  ******************** 
  ********************</pre></b>
      Remember that catenating an escape sequence character (<b>'\n'</b>) in a <b>String</b> causes
        a carriage return when that character is printed.
   <p>

     <li>Suppose our program consists of the the methods <b>main</b>, <b>a</b>,
           <b>b</b>, <b>c</b>, <b>d</b>, and <b>e</b>.
         Also suppose <b>main</b> calls <b>a</b>, <b>b</b>, <b>d</b>, and <b>e</b>,
           <b>a</b> calls <b>c</b>, <b>b</b> calls <b>a</b>, <b>c</b> calls nothing else,
           <b>d</b> calls <b>a</b>, and <b>e</b> calls <b>d</b> and <b>c</b>.
         <ul>
            <li>Find two "natural orders" in which to write these methods in a file 
            <li>Find two "reverse natural orders" in which to write these methods in a file 
         </ul>     

      <p>
      <li>For all the sample methods in this lecture, identify the ones in
            which it makes sense to throw <b>IllegalArgumentExceptions</b> and
            describe under what conditions.
          Note that sometimes individual parameters will store reasonable
            values, but pairs of parameters will have values that are
            incompatible.

      <p>

      <li>As we saw in this lecture, we can specify that a parameter variable
            is <b>final</b>.
          For example, we can rewrite <b>factorial</b> as
<pre><b>  public static int factorial (final int n)
  {
    int answer = 1;
    for (int i=2; i<=n; i++)
      answer *= i;
    return answer;
  }</b></pre>
  What does <b>final</b> mean when added before a parameter?
  Does the <b>factorial</b> method still work correctly if its parameter is specified <b>final</b>?
  If it didn't, would we find out at compile-time or at run-time?
  Which methods in this lecture can have their parameters(s) declared to be
     <b>final</b>? Which cannot?
  Can any of the local variables in these methods be declared <b>final</b>?
<p>

<li>Define a class with the following characteristics:
      its name is <b>Utility</b> and
      it is in the <b>cs200</b> package.
    It contains two <b>static</b> methods, both named <b>factorial</b>: the
      first takes an <b>int</b> parameter and returns an <b>int</b> result;
      the second takes a <b>BigInteger</b> parameter and returns a
      <b>BigInteger</b> result.
    Important whatever classes are necessary to write the bodies of these
      methods successfully.
<p>

<li>Explain why when defining a class, we never need to write an import
       declaration for the <b>Math</b> class.
<p>

     <li>I predict that half the students in class will make the following mistake when
           they write one of their first few constructors.
         Can you spot the mistake (compare it to the correctly written constructor in this lecture)?
         What actually happens if we write this code?
         Will Java detect/report the error? If so, with what message? If not, what will Java do when
           it executes this code?
<pre><b>  public SimpleDiceEnsemble () 
  {
    int numberOfDice = 2;
    int sidesPerDie  = 6;
    int rollCount    = 0;
  }</b></pre>
  If we wrote each of these like <b>this.numberOfDice</b>, would it help?
<p>

<li>Explain how to simplify the following declarations and constructor.
I have used the style of always writing <b>this.</b> to access instance
  variables.
<pre><b>  private int a;
  private int b;
  private int c;

  public C (int a) 
  {
    this.a = a;
    this.b = 10;
    this.c = 0;
  }</b></pre><p>
<p>

     <li>Examine the code for the <b>SimpleDiceEnsemble</b> class.
     <ul>
       <li>Assume that we decide to roll the dice automatically, at the time
             when the ensemble is constructed, to initialize them.
           How could we modify the constructor to perform this task?
           What changes (if any) could we make the method headers and bodies?
       <li>Assume that we want users of this class to be able to retrieve the
             minimum and maximum number of pips showing after each roll.
           What extra instance variables should we declare?
           What new methods should we write and what changes to old methods
             should we make?
     </ul>
<p>
<li>
Write a class named <b>RangeTally</b>.
Each instance of this class stores four fields: the lower legal value, the
  upper legal value, the sum of all the int values in this range that it is
  has seen (via the <b>tally</b> method), and the total number of values that
  has seen (whether they were in range or not).
Its constructor should initialize these fields appropriately; its accessor,
  <b>getTally</b>, should return the sum of all values seen which were in
  range; its accessor, <b>getCount</b>, should return a count of all of values
   that it has seen (whether they were in range or not); its mutator,
  <b>tally</b>, is passed an <b>int</b> parameter that is conditionally tallied
  into the sum; it should change all fields as appropriate
For example, if we declare <b>RangeTally t = new RangeTally(1,10);</b> and
   execute the statements <b>t.tally(5); t.tally(8); t.tally(15);</b>
   and then <b>System.out.println(t.getTally()+":"+t.getCount());</b> Java
    prints </b>13:3</b> -the last value is counted, but not summed, because it
    is not in the range <b>1</b> to <b>10</b>, specified in the constructor.
</ol>
</td>
</tbody>
</table>


</body>
</html>
