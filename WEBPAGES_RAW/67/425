<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.0: http://docutils.sourceforge.net/" />
<title>SIP - A Tool for Generating Python Bindings for C and C++ Libraries</title>
<meta name="copyright" content="Copyright (c) 2004 Riverbank Computing Limited" />
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="sip-a-tool-for-generating-python-bindings-for-c-and-c-libraries">
<h1 class="title">SIP - A Tool for Generating Python Bindings for C and C++ Libraries</h1>
<h2 class="subtitle" id="reference-guide">Reference Guide</h2>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:info&#64;riverbankcomputing.co.uk">info&#64;riverbankcomputing.co.uk</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>4.0.1</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>Copyright (c) 2004 Riverbank Computing Limited</td></tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title"><a name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id19" name="id19">1   Introduction</a><ul class="auto-toc">
<li><a class="reference" href="#license" id="id20" name="id20">1.1   License</a></li>
<li><a class="reference" href="#features" id="id21" name="id21">1.2   Features</a></li>
<li><a class="reference" href="#sip-v3-x" id="id22" name="id22">1.3   SIP v3.x</a></li>
<li><a class="reference" href="#sip-components" id="id23" name="id23">1.4   SIP Components</a></li>
</ul>
</li>
<li><a class="reference" href="#installing-sip" id="id24" name="id24">2   Installing SIP</a><ul class="auto-toc">
<li><a class="reference" href="#downloading-sip" id="id25" name="id25">2.1   Downloading SIP</a></li>
<li><a class="reference" href="#configuring-sip" id="id26" name="id26">2.2   Configuring SIP</a><ul class="auto-toc">
<li><a class="reference" href="#configuring-sip-using-mingw" id="id27" name="id27">2.2.1   Configuring SIP Using MinGW</a></li>
<li><a class="reference" href="#configuring-sip-using-the-borland-c-compiler" id="id28" name="id28">2.2.2   Configuring SIP Using the Borland C++ Compiler</a></li>
</ul>
</li>
<li><a class="reference" href="#building-sip" id="id29" name="id29">2.3   Building SIP</a></li>
</ul>
</li>
<li><a class="reference" href="#using-sip" id="id30" name="id30">3   Using SIP</a><ul class="auto-toc">
<li><a class="reference" href="#a-simple-c-example" id="id31" name="id31">3.1   A Simple C++ Example</a></li>
<li><a class="reference" href="#id9" id="id32" name="id32">3.2   A Simple C Example</a></li>
<li><a class="reference" href="#a-more-complex-c-example" id="id33" name="id33">3.3   A More Complex C++ Example</a></li>
<li><a class="reference" href="#ownership-of-objects" id="id34" name="id34">3.4   Ownership of Objects</a></li>
</ul>
</li>
<li><a class="reference" href="#the-sip-command-line" id="id35" name="id35">4   The SIP Command Line</a></li>
<li><a class="reference" href="#sip-specification-files" id="id36" name="id36">5   SIP Specification Files</a><ul class="auto-toc">
<li><a class="reference" href="#syntax-definition" id="id37" name="id37">5.1   Syntax Definition</a></li>
<li><a class="reference" href="#additional-sip-types" id="id38" name="id38">5.2   Additional SIP Types</a><ul class="auto-toc">
<li><a class="reference" href="#sip-pycallable" id="id39" name="id39">5.2.1   SIP_PYCALLABLE</a></li>
<li><a class="reference" href="#sip-pydict" id="id40" name="id40">5.2.2   SIP_PYDICT</a></li>
<li><a class="reference" href="#sip-pylist" id="id41" name="id41">5.2.3   SIP_PYLIST</a></li>
<li><a class="reference" href="#sip-pyobject" id="id42" name="id42">5.2.4   SIP_PYOBJECT</a></li>
<li><a class="reference" href="#sip-pytuple" id="id43" name="id43">5.2.5   SIP_PYTUPLE</a></li>
<li><a class="reference" href="#sip-pyslice" id="id44" name="id44">5.2.6   SIP_PYSLICE</a></li>
<li><a class="reference" href="#sip-qobject" id="id45" name="id45">5.2.7   SIP_QOBJECT</a></li>
<li><a class="reference" href="#sip-rxobj-con" id="id46" name="id46">5.2.8   SIP_RXOBJ_CON</a></li>
<li><a class="reference" href="#sip-rxobj-dis" id="id47" name="id47">5.2.9   SIP_RXOBJ_DIS</a></li>
<li><a class="reference" href="#sip-signal" id="id48" name="id48">5.2.10   SIP_SIGNAL</a></li>
<li><a class="reference" href="#sip-slot" id="id49" name="id49">5.2.11   SIP_SLOT</a></li>
<li><a class="reference" href="#sip-slot-con" id="id50" name="id50">5.2.12   SIP_SLOT_CON()</a></li>
<li><a class="reference" href="#sip-slot-dis" id="id51" name="id51">5.2.13   SIP_SLOT_DIS()</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#sip-directives" id="id52" name="id52">6   SIP Directives</a><ul class="auto-toc">
<li><a class="reference" href="#accesscode" id="id53" name="id53">6.1   %AccessCode</a></li>
<li><a class="reference" href="#cmodule" id="id54" name="id54">6.2   %CModule</a></li>
<li><a class="reference" href="#convertfromtypecode" id="id55" name="id55">6.3   %ConvertFromTypeCode</a></li>
<li><a class="reference" href="#converttosubclasscode" id="id56" name="id56">6.4   %ConvertToSubClassCode</a></li>
<li><a class="reference" href="#converttotypecode" id="id57" name="id57">6.5   %ConvertToTypeCode</a></li>
<li><a class="reference" href="#copying" id="id58" name="id58">6.6   %Copying</a></li>
<li><a class="reference" href="#doc" id="id59" name="id59">6.7   %Doc</a></li>
<li><a class="reference" href="#end" id="id60" name="id60">6.8   %End</a></li>
<li><a class="reference" href="#exporteddoc" id="id61" name="id61">6.9   %ExportedDoc</a></li>
<li><a class="reference" href="#feature" id="id62" name="id62">6.10   %Feature</a></li>
<li><a class="reference" href="#if" id="id63" name="id63">6.11   %If</a></li>
<li><a class="reference" href="#import" id="id64" name="id64">6.12   %Import</a></li>
<li><a class="reference" href="#include" id="id65" name="id65">6.13   %Include</a></li>
<li><a class="reference" href="#id16" id="id66" name="id66">6.14   %License</a></li>
<li><a class="reference" href="#mappedtype" id="id67" name="id67">6.15   %MappedType</a></li>
<li><a class="reference" href="#methodcode" id="id68" name="id68">6.16   %MethodCode</a></li>
<li><a class="reference" href="#module" id="id69" name="id69">6.17   %Module</a></li>
<li><a class="reference" href="#modulecode" id="id70" name="id70">6.18   %ModuleCode</a></li>
<li><a class="reference" href="#moduleheadercode" id="id71" name="id71">6.19   %ModuleHeaderCode</a></li>
<li><a class="reference" href="#optionalinclude" id="id72" name="id72">6.20   %OptionalInclude</a></li>
<li><a class="reference" href="#platforms" id="id73" name="id73">6.21   %Platforms</a></li>
<li><a class="reference" href="#postinitialisationcode" id="id74" name="id74">6.22   %PostInitialisationCode</a></li>
<li><a class="reference" href="#timeline" id="id75" name="id75">6.23   %Timeline</a></li>
<li><a class="reference" href="#typecode" id="id76" name="id76">6.24   %TypeCode</a></li>
<li><a class="reference" href="#typeheadercode" id="id77" name="id77">6.25   %TypeHeaderCode</a></li>
<li><a class="reference" href="#virtualcatchercode" id="id78" name="id78">6.26   %VirtualCatcherCode</a></li>
</ul>
</li>
<li><a class="reference" href="#sip-annotations" id="id79" name="id79">7   SIP Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#argument-annotations" id="id80" name="id80">7.1   Argument Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#allownone" id="id81" name="id81">7.1.1   AllowNone</a></li>
<li><a class="reference" href="#array" id="id82" name="id82">7.1.2   Array</a></li>
<li><a class="reference" href="#arraysize" id="id83" name="id83">7.1.3   ArraySize</a></li>
<li><a class="reference" href="#constrained" id="id84" name="id84">7.1.4   Constrained</a></li>
<li><a class="reference" href="#getwrapper" id="id85" name="id85">7.1.5   GetWrapper</a></li>
<li><a class="reference" href="#in" id="id86" name="id86">7.1.6   In</a></li>
<li><a class="reference" href="#out" id="id87" name="id87">7.1.7   Out</a></li>
<li><a class="reference" href="#transfer" id="id88" name="id88">7.1.8   Transfer</a></li>
<li><a class="reference" href="#transferback" id="id89" name="id89">7.1.9   TransferBack</a></li>
<li><a class="reference" href="#transferthis" id="id90" name="id90">7.1.10   TransferThis</a></li>
</ul>
</li>
<li><a class="reference" href="#function-annotations" id="id91" name="id91">7.2   Function Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#autogen" id="id92" name="id92">7.2.1   AutoGen</a></li>
<li><a class="reference" href="#default" id="id93" name="id93">7.2.2   Default</a></li>
<li><a class="reference" href="#factory" id="id94" name="id94">7.2.3   Factory</a></li>
<li><a class="reference" href="#newthread" id="id95" name="id95">7.2.4   NewThread</a></li>
<li><a class="reference" href="#posthook" id="id96" name="id96">7.2.5   PostHook</a></li>
<li><a class="reference" href="#prehook" id="id97" name="id97">7.2.6   PreHook</a></li>
<li><a class="reference" href="#pyname" id="id98" name="id98">7.2.7   PyName</a></li>
<li><a class="reference" href="#releasegil" id="id99" name="id99">7.2.8   ReleaseGIL</a></li>
</ul>
</li>
<li><a class="reference" href="#license-annotations" id="id100" name="id100">7.3   License Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#licensee" id="id101" name="id101">7.3.1   Licensee</a></li>
<li><a class="reference" href="#signature" id="id102" name="id102">7.3.2   Signature</a></li>
<li><a class="reference" href="#timestamp" id="id103" name="id103">7.3.3   Timestamp</a></li>
<li><a class="reference" href="#type" id="id104" name="id104">7.3.4   Type</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#sip-api-for-handwritten-code" id="id105" name="id105">8   SIP API for Handwritten Code</a><ul class="auto-toc">
<li><a class="reference" href="#sip-api-major-nr" id="id106" name="id106">8.1   SIP_API_MAJOR_NR</a></li>
<li><a class="reference" href="#sip-api-minor-nr" id="id107" name="id107">8.2   SIP_API_MINOR_NR</a></li>
<li><a class="reference" href="#sip-build" id="id108" name="id108">8.3   SIP_BUILD</a></li>
<li><a class="reference" href="#sip-version" id="id109" name="id109">8.4   SIP_VERSION</a></li>
<li><a class="reference" href="#sip-version-str" id="id110" name="id110">8.5   SIP_VERSION_STR</a></li>
<li><a class="reference" href="#sipbadcatcherresult" id="id111" name="id111">8.6   sipBadCatcherResult()</a></li>
<li><a class="reference" href="#sipbadlengthforslice" id="id112" name="id112">8.7   sipBadLengthForSlice()</a></li>
<li><a class="reference" href="#sipbuildresult" id="id113" name="id113">8.8   sipBuildResult()</a></li>
<li><a class="reference" href="#sipcallmethod" id="id114" name="id114">8.9   sipCallMethod()</a></li>
<li><a class="reference" href="#sipclassname" id="id115" name="id115">8.10   sipClassName()</a></li>
<li><a class="reference" href="#sipconnectrx" id="id116" name="id116">8.11   sipConnectRx()</a></li>
<li><a class="reference" href="#sipconvertfromsequenceindex" id="id117" name="id117">8.12   sipConvertFromSequenceIndex()</a></li>
<li><a class="reference" href="#sipconvertfromsliceobject" id="id118" name="id118">8.13   sipConvertFromSliceObject()</a></li>
<li><a class="reference" href="#sipconverttocpp" id="id119" name="id119">8.14   sipConvertToCpp()</a></li>
<li><a class="reference" href="#sipdisconnectrx" id="id120" name="id120">8.15   sipDisconnectRx()</a></li>
<li><a class="reference" href="#sipemitsignal" id="id121" name="id121">8.16   sipEmitSignal()</a></li>
<li><a class="reference" href="#sipfree" id="id122" name="id122">8.17   sipFree()</a></li>
<li><a class="reference" href="#sipgetsender" id="id123" name="id123">8.18   sipGetSender()</a></li>
<li><a class="reference" href="#sipgetwrapper" id="id124" name="id124">8.19   sipGetWrapper()</a></li>
<li><a class="reference" href="#sipinttypeclassmap" id="id125" name="id125">8.20   sipIntTypeClassMap</a></li>
<li><a class="reference" href="#sipissubclassinstance" id="id126" name="id126">8.21   sipIsSubClassInstance()</a></li>
<li><a class="reference" href="#sipmalloc" id="id127" name="id127">8.22   sipMalloc()</a></li>
<li><a class="reference" href="#sipmapinttoclass" id="id128" name="id128">8.23   sipMapIntToClass()</a></li>
<li><a class="reference" href="#sipmapstringtoclass" id="id129" name="id129">8.24   sipMapStringToClass()</a></li>
<li><a class="reference" href="#sipparseresult" id="id130" name="id130">8.25   sipParseResult()</a></li>
<li><a class="reference" href="#sipstringtypeclassmap" id="id131" name="id131">8.26   sipStringTypeClassMap</a></li>
<li><a class="reference" href="#siptransfer" id="id132" name="id132">8.27   sipTransfer()</a></li>
<li><a class="reference" href="#sipwrappertype" id="id133" name="id133">8.28   sipWrapperType</a></li>
<li><a class="reference" href="#generated-type-convertors" id="id134" name="id134">8.29   Generated Type Convertors</a></li>
<li><a class="reference" href="#generated-type-objects" id="id135" name="id135">8.30   Generated Type Objects</a></li>
<li><a class="reference" href="#generated-derived-classes" id="id136" name="id136">8.31   Generated Derived Classes</a></li>
</ul>
</li>
<li><a class="reference" href="#using-the-sip-module-in-applications" id="id137" name="id137">9   Using the SIP Module in Applications</a></li>
<li><a class="reference" href="#the-sip-build-system" id="id138" name="id138">10   The SIP Build System</a><ul class="auto-toc">
<li><a class="reference" href="#sipconfig-functions" id="id139" name="id139">10.1   <tt class="literal"><span class="pre">sipconfig</span></tt> Functions</a></li>
<li><a class="reference" href="#sipconfig-classes" id="id140" name="id140">10.2   <tt class="literal"><span class="pre">sipconfig</span></tt> Classes</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id19" name="introduction">1   Introduction</a></h1>
<p>This is the reference guide for SIP 4.0.1.  SIP is a tool for
automatically generating <a class="reference" href="http://www.python.org">Python</a> bindings for C and
C++ libraries.  SIP was originally developed in 1998 for
<a class="reference" href="http://www.riverbankcomputing.co.uk/pyqt/">PyQt</a> - the Python bindings for
the Qt GUI toolkit - but is suitable for generating bindings for any C or C++
library.</p>
<p>This version of SIP generates bindings for Python v2.3 or later.  If you want
to generate bindings for earlier versions of Python (going back as far as
Python v1.5) then you need to use <a class="reference" href="#sip-v3-x">SIP v3.x</a>.</p>
<p>There are many other similar tools available.  One of the original such tools
is <a class="reference" href="http://www.swig.org">SWIG</a> and, in fact, SIP is so called because it
started out as a small SWIG.  Unlike SWIG, SIP is specifically designed for
bringing together Python and C/C++ and goes to great lengths to make the
integration as tight as possible.</p>
<p>The homepage for SIP is <a class="reference" href="http://www.riverbankcomputing.co.uk/sip/">http://www.riverbankcomputing.co.uk/sip/</a>.  Here you
will always find the latest stable version, current development snapshots, and
the latest version of this documentation.</p>
<div class="section" id="license">
<h2><a class="toc-backref" href="#id20" name="license">1.1   License</a></h2>
<p>SIP is licensed under the same terms as Python itself.  SIP places no
restrictions on the license you may apply to the bindings you create.</p>
</div>
<div class="section" id="features">
<h2><a class="toc-backref" href="#id21" name="features">1.2   Features</a></h2>
<p>SIP, and the bindings it produces, have the following features.</p>
<blockquote>
<ul class="simple">
<li>bindings are fast to load and minimise memory consumption especially when
only a small sub-set of a large library is being used</li>
<li>automatic conversion between standard Python and C/C++ data types</li>
<li>overloading of functions and methods with different argument signatures</li>
<li>access to a C++ class's protected methods</li>
<li>the ability to define a Python class that is a sub-class of a C++ class,
including abstract C++ classes</li>
<li>support for ordinary C++ functions, class methods, static class methods,
virtual class methods and abstract class methods</li>
<li>the ability to re-implement C++ virtual and abstract methods in Python</li>
<li>support for global and class variables</li>
<li>support for C++ namespaces</li>
<li>support for C++ exceptions and wrapping them as Python exceptions</li>
<li>the ability to define mappings between C++ classes and similar Python
data types that are automatically invoked</li>
<li>the ability to automatically exploit any available run time type
information to ensure that the class of a Python instance object matches
the class of the corresponding C++ instance</li>
<li>full support of the Python interpreter lock, including the ability to
specify that a C++ function of method may block, therefore allowing the
lock to be released and other Python threads to run</li>
<li>support for the concept of ownership of a C++ instance (i.e. what part of
the code is responsible for calling the instance's destructor) and how
the ownership may change during the execution of an application</li>
<li>the ability to generate bindings for a C++ class library that itself is
built on another C++ class library which also has had bindings generated
so that the different bindings integrate and share code properly</li>
<li>a sophisticated versioning system that allows the full lifetime of a C++
class library, including any platform specific or optional features, to
be described in a single set of specification files</li>
<li>the ability to include documentation in the specification files which can
be extracted and subsequently processed by external tools</li>
<li>the ability to include copyright notices and licensing information in the
specification files that is automatically included in all generated
source code</li>
<li>a build system, written in Python, that you can extend to configure,
compile and install your own bindings without worrying about platform
specific issues</li>
<li>SIP, and the bindings it produces, runs under UNIX, Linux, Windows and
MacOS/X</li>
</ul>
</blockquote>
<p>SIP also understands the signal/slot type safe callback mechanism implemented
by Qt.  SIP allows new Python signals to be defined, and allows any Python
callable object to be used as a slot.</p>
</div>
<div class="section" id="sip-v3-x">
<h2><a class="toc-backref" href="#id22" name="sip-v3-x">1.3   SIP v3.x</a></h2>
<p>SIP v3.x differs from current versions in the following respects.</p>
<blockquote>
<ul class="simple">
<li>It uses Python's classic classes to wrap C++ classes (and so generated
bindings can be built against any version of Python).</li>
<li>It does not support the creation of bindings for C libraries.</li>
<li>It does not generate bindings that will work on MacOS/X.</li>
<li>It is not formally documented.  However, most of this document does
apply to SIP v3.x - just don't be surprised if you come across something
that doesn't.</li>
</ul>
</blockquote>
<p>New releases of SIP v3.x may be made in the future, but no significant
development will be done.</p>
</div>
<div class="section" id="sip-components">
<h2><a class="toc-backref" href="#id23" name="sip-components">1.4   SIP Components</a></h2>
<p>SIP comprises a number of different components.</p>
<blockquote>
<ul class="simple">
<li>The SIP code generator (<tt class="literal"><span class="pre">sip</span></tt> or <tt class="literal"><span class="pre">sip.exe</span></tt>).  This processes <tt class="literal"><span class="pre">.sip</span></tt>
specification files and generates C or C++ bindings.  It is covered in
detail in <a class="reference" href="#using-sip">Using SIP</a>.</li>
<li>The SIP header file (<tt class="literal"><span class="pre">sip.h</span></tt>).  This contains definitions and data
structures needed by the generated C and C++ code.</li>
<li>The SIP module (<tt class="literal"><span class="pre">sip.so</span></tt> or <tt class="literal"><span class="pre">sip.pyd</span></tt>).  This is a Python extension
module that is imported automatically by SIP generated bindings and
provides them with some common utility functions.  See also <a class="reference" href="#using-the-sip-module-in-applications">Using the
SIP Module in Applications</a>.</li>
<li>The SIP build system (<tt class="literal"><span class="pre">sipconfig.py</span></tt>).  This is a pure Python module
that is created when SIP is configured and encapsulates all the necessary
information about your system including relevant directory names,
compiler and linker flags, and version numbers.  It also includes several
Python classes and functions which help you write configuration scripts
for your own bindings.  It is covered in detail in <a class="reference" href="#the-sip-build-system">The SIP Build
System</a>.</li>
</ul>
</blockquote>
</div>
</div>
<div class="section" id="installing-sip">
<h1><a class="toc-backref" href="#id24" name="installing-sip">2   Installing SIP</a></h1>
<div class="section" id="downloading-sip">
<h2><a class="toc-backref" href="#id25" name="downloading-sip">2.1   Downloading SIP</a></h2>
<p>You can get the latest release of the SIP source code from
<a class="reference" href="http://www.riverbankcomputing.co.uk/sip/download.php">http://www.riverbankcomputing.co.uk/sip/download.php</a>.</p>
<p>SIP is also included with all of the major Linux distributions.  However, it
may be a version or two out of date.</p>
<p>You may also find more up to date pre-compiled binaries on
<a class="reference" href="http://sourceforge.net/project/showfiles.php?group_id=61057">SourceForge</a>.</p>
</div>
<div class="section" id="configuring-sip">
<h2><a class="toc-backref" href="#id26" name="configuring-sip">2.2   Configuring SIP</a></h2>
<p>After unpacking the source package (either a <tt class="literal"><span class="pre">.tar.gz</span></tt> or a <tt class="literal"><span class="pre">.zip</span></tt> file
depending on your platform) you should then check for any <tt class="literal"><span class="pre">README</span></tt> files
that relate to your platform.</p>
<p>Next you need to configure SIP by executing the <tt class="literal"><span class="pre">configure.py</span></tt> script.  For
example:</p>
<pre class="literal-block">
python configure.py
</pre>
<p>This assumes that the Python interpreter is on your path.  Something like the
following may be appropriate on Windows:</p>
<pre class="literal-block">
c:\python23\python configure.py
</pre>
<p>If you have multiple versions of Python installed then make sure you use the
interpreter for which you wish SIP to generate bindings for.</p>
<p>Qt support is automatically enabled if the <tt class="literal"><span class="pre">QTDIR</span></tt> environment variable is
set.  Use the <tt class="literal"><span class="pre">-x</span></tt> command line option to disable it.</p>
<p>The full set of command line options is:</p>
<table class="option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td>
<kbd><span class="option">-h</span></kbd></td>
<td>Display a help message.</td></tr>
<tr><td>
<kbd><span class="option">-b</span> <var>dir</var></kbd></td>
<td>The SIP code generator will be installed in the directory <tt class="literal"><span class="pre">dir</span></tt>.</td></tr>
<tr><td>
<kbd><span class="option">-d</span> <var>dir</var></kbd></td>
<td>The SIP module will be installed in the directory <tt class="literal"><span class="pre">dir</span></tt>.</td></tr>
<tr><td>
<kbd><span class="option">-e</span> <var>dir</var></kbd></td>
<td>The SIP header file will be installed in the directory <tt class="literal"><span class="pre">dir</span></tt>.</td></tr>
<tr><td>
<kbd><span class="option">-k</span></kbd></td>
<td>The SIP module will be built as a static library.  This is useful when
building the SIP module as a Python builtin</td></tr>
<tr><td>
<kbd><span class="option">-l</span> <var>lib</var></kbd></td>
<td>Explicitly specify the type of Qt library to use, either <tt class="literal"><span class="pre">qt</span></tt>,
<tt class="literal"><span class="pre">qt-mt</span></tt>, <tt class="literal"><span class="pre">qtmt</span></tt> or <tt class="literal"><span class="pre">qte</span></tt>.  This is useful if, for example, you
have the non-threaded (<tt class="literal"><span class="pre">qt</span></tt>) and threaded (<tt class="literal"><span class="pre">qt-mt</span></tt>) versions of
the Qt library installed in the same directory.</td></tr>
<tr><td>
<kbd><span class="option">-p</span> <var>platform</var></kbd></td>
<td>Explicitly specify the platform/compiler to be used by the build
system.  If Qt support is enabled then the platform/compiler used to
build Qt will be used, otherwise a platform specific default will be
used.  The <tt class="literal"><span class="pre">-h</span></tt> option will display all the supported
platform/compilers and the default.</td></tr>
<tr><td>
<kbd><span class="option">-u</span></kbd></td>
<td>The SIP module will be built with debugging symbols.</td></tr>
<tr><td>
<kbd><span class="option">-v</span> <var>dir</var></kbd></td>
<td>By default <tt class="literal"><span class="pre">.sip</span></tt> files will be installed in the directory <tt class="literal"><span class="pre">dir</span></tt>.</td></tr>
<tr><td>
<kbd><span class="option">-x</span></kbd></td>
<td>Disable the SIP module's support for Qt.  Support is automatically
disabled if the <tt class="literal"><span class="pre">QTDIR</span></tt> environment variables isn't set.</td></tr>
</tbody>
</table>
<p>The configure.py script takes many other options that allows the build system
to be finely tuned.  These are of the form <tt class="literal"><span class="pre">name=value</span></tt> or <tt class="literal"><span class="pre">name+=value</span></tt>.
The <tt class="literal"><span class="pre">-h</span></tt> option will display each supported <tt class="literal"><span class="pre">name</span></tt>, although not all are
applicable to all platforms.</p>
<p>The <tt class="literal"><span class="pre">name=value</span></tt> form means that <tt class="literal"><span class="pre">value</span></tt> will replace the existing value of
<tt class="literal"><span class="pre">name</span></tt>.</p>
<p>The <tt class="literal"><span class="pre">name+=value</span></tt> form means that <tt class="literal"><span class="pre">value</span></tt> will be appended to the existing
value of <tt class="literal"><span class="pre">name</span></tt>.</p>
<p>For example, the following will reduce the size of module binaries compiled
with GCC:</p>
<pre class="literal-block">
python configure.py CXXFLAGS+=-fno-exceptions LFLAGS+=-s
</pre>
<p>A pure Python module called <tt class="literal"><span class="pre">sipconfig.py</span></tt> is generated by <tt class="literal"><span class="pre">configure.py</span></tt>.
This defines each <tt class="literal"><span class="pre">name</span></tt> and its corresponding <tt class="literal"><span class="pre">value</span></tt>.  Looking at it will
give you a good idea of how the build system uses the different options.  It is
covered in detail in <a class="reference" href="#the-sip-build-system">The SIP Build System</a>.</p>
<div class="section" id="configuring-sip-using-mingw">
<h3><a class="toc-backref" href="#id27" name="configuring-sip-using-mingw">2.2.1   Configuring SIP Using MinGW</a></h3>
<p>SIP, and the modules it generates, can be built with MinGW, the Windows port of
GCC.  If you have Qt installed (and built with MinGW) then <tt class="literal"><span class="pre">configure.py</span></tt>
will automatically select the correct configuration.  If you do not have Qt
installed (or you are disabling support for it) then you must use the <tt class="literal"><span class="pre">-p</span></tt>
command line option to specify the correct platform.  For example:</p>
<pre class="literal-block">
c:\python23\python configure.py -p win32-g++
</pre>
<p>You must also make sure you have a MinGW-compatible version of the Python
library.  See <a class="reference" href="http://sebsauvage.net/python/mingw.html">http://sebsauvage.net/python/mingw.html</a> for instructions to do
this.</p>
</div>
<div class="section" id="configuring-sip-using-the-borland-c-compiler">
<h3><a class="toc-backref" href="#id28" name="configuring-sip-using-the-borland-c-compiler">2.2.2   Configuring SIP Using the Borland C++ Compiler</a></h3>
<p>SIP, and the modules it generates, can be built with the free Borland C++
compielr.  If you have Qt installed (and built with the Borland compiler) then
<tt class="literal"><span class="pre">configure.py</span></tt> will automatically select the correct configuration.  If you
do not have Qt installed (or you are disabling support for it) then you must
use the <tt class="literal"><span class="pre">-p</span></tt> command line option to specify the correct platform.  For
example:</p>
<pre class="literal-block">
c:\python23\python configure.py -p win32-borland
</pre>
<p>You must also make sure you have a Borland-compatible version of the Python
library.  If you are using the standard Python distribution (built using the
Microsoft compiler) then you must convert the format of the Python library.
For example:</p>
<pre class="literal-block">
coff2omf python23.lib python23_bcpp.lib
</pre>
</div>
</div>
<div class="section" id="building-sip">
<h2><a class="toc-backref" href="#id29" name="building-sip">2.3   Building SIP</a></h2>
<p>The next step is to build SIP by running your platform's <tt class="literal"><span class="pre">make</span></tt> command.  For
example:</p>
<pre class="literal-block">
make
</pre>
<p>The final step is to install SIP by running the following command:</p>
<pre class="literal-block">
make install
</pre>
<p>(Depending on your system you may require root or administrator privileges.)</p>
<p>This will install the various SIP components.</p>
</div>
</div>
<div class="section" id="using-sip">
<h1><a class="toc-backref" href="#id30" name="using-sip">3   Using SIP</a></h1>
<p>Bindings are generated by the SIP code generator from a number of specification
files, typically with a <tt class="literal"><span class="pre">.sip</span></tt> extension.  Specification files look very
similar to C and C++ header files, but often with additional information (in
the form of a <em>directive</em> or an <em>annotation</em>) and code so that the bindings
generated can be finely tuned.</p>
<div class="section" id="a-simple-c-example">
<h2><a class="toc-backref" href="#id31" name="a-simple-c-example">3.1   A Simple C++ Example</a></h2>
<p>We start with a simple, but complete, example.  Let's say you have a C++
library that implements a single class called <tt class="literal"><span class="pre">Word</span></tt>.  The class has one
constructor that takes a <tt class="literal"><span class="pre">\0</span></tt> terminated character string as its single
argument.  The class has one method called <tt class="literal"><span class="pre">reverse()</span></tt> which takes no
arguments and returns a <tt class="literal"><span class="pre">\0</span></tt> terminated character string.  The interface to
the class is defined in a header file called <tt class="literal"><span class="pre">word.h</span></tt> which might look
something like this:</p>
<pre class="literal-block">
// Define the interface to the word library.

class Word {
    const char *the_word;

public:
    Word(const char *w);

    char *reverse() const;
};
</pre>
<p>The corresponding SIP specification file would then look something like this:</p>
<pre class="literal-block">
// Define the SIP wrapper to the word library.

%Module word 0

class Word {

%TypeHeaderCode
#include &lt;word.h&gt;
%End

public:
    Word(const char *);

    char *reverse() const;
};
</pre>
<p>Obviously a SIP specification file looks very much like a C++ (or C) header
file, but SIP does not include a full C++ parser.  Let's look at the
differences between the two files.</p>
<blockquote>
<ul class="simple">
<li>The <a class="reference" href="#module">%Module</a> directive has been added <a class="footnote-reference" href="#id5" id="id1" name="id1"><sup>1</sup></a>.  This is used to name the
Python module that is being created and to give it a <em>generation</em> number.
In this example these are <tt class="literal"><span class="pre">word</span></tt> and <tt class="literal"><span class="pre">0</span></tt> respectively.  The
generation number is effectively the version number of the module.</li>
<li>The <a class="reference" href="#typeheadercode">%TypeHeaderCode</a> directive has been added.  The text between this
and the following <a class="reference" href="#end">%End</a> directive is included literally in the code
that SIP generates.  Normally it is used, as in this case, to
<tt class="literal"><span class="pre">#include</span></tt> the corresponding C++ (or C) header file <a class="footnote-reference" href="#id6" id="id2" name="id2"><sup>2</sup></a>.</li>
<li>The declaration of the private variable <tt class="literal"><span class="pre">this_word</span></tt> has been removed.
SIP does not support access to either private or protected instance
variables.</li>
<li>The name of the argument to the constructor has been removed.  SIP does
not support named arguments <a class="footnote-reference" href="#id7" id="id3" name="id3"><sup>3</sup></a>.</li>
</ul>
</blockquote>
<p>If we want to we can now generate the C++ code in the current directory by
running the following command:</p>
<pre class="literal-block">
sip -c . word.sip
</pre>
<p>However, that still leaves us with the task of compiling the generated code and
linking it against all the necessary libraries.  It's much easier to use the
SIP build system to do the whole thing.</p>
<p>Using the SIP build system is simply a matter of writing a small Python script.
In this simple example we will assume that the <tt class="literal"><span class="pre">word</span></tt> library we are wrapping
and it's header file are installed in standard system locations and will be
found by the compiler and linker without having to specify any additional
flags.  In a more realistic example your Python script may take command line
options, or search a set of directories to deal with different configurations
and installations.</p>
<p>This is the simplest script (conventionally called <tt class="literal"><span class="pre">configure.py</span></tt>):</p>
<pre class="literal-block">
import os
import sipconfig

# The name of the SIP build file generated by SIP and used by the build
# system.
build_file = &quot;word.sbf&quot;

# Get the SIP configuration information.
config = sipconfig.Configuration()

# Run SIP to generate the code.
os.system(&quot; &quot;.join([config.sip_bin, &quot;-c&quot;, &quot;.&quot;, &quot;-b&quot;, build_file, &quot;word.sip&quot;]))

# Create the Makefile.
makefile = sipconfig.SIPModuleMakefile(config, build_file)

# Add the library we are wrapping.  The name doesn't include any platform
# specific prefixes or extensions (e.g. the &quot;lib&quot; prefix on UNIX, or the
# &quot;.dll&quot; extension on Windows).
makefile.extra_libs = [&quot;word&quot;]

# Generate the Makefile itself.
makefile.generate()
</pre>
<p>Hopefully this script is self-documenting.  The key parts are the
<tt class="literal"><span class="pre">Configuration</span></tt> and <tt class="literal"><span class="pre">SIPModuleMakefile</span></tt> classes.  The build system contains
other Makefile classes, for example to build programs or to call other
Makefiles in sub-directories.</p>
<p>After running the script (using the Python interpreter the extension module is
being created for) the generated C++ code and <tt class="literal"><span class="pre">Makefile</span></tt> will be in the
current directory.</p>
<p>To compile and install the extension module, just run the following
commands <a class="footnote-reference" href="#id8" id="id4" name="id4"><sup>4</sup></a>:</p>
<pre class="literal-block">
make
make install
</pre>
<p>That's all there is to it.</p>
<table class="footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id5">[1]</a></td><td>All SIP directives start with a <tt class="literal"><span class="pre">%</span></tt> as the first non-whitespace
character of a line.</td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="id6">[2]</a></td><td>SIP includes many code directives like this.  They differ in where the
supplied code is placed by SIP in the generated code.</td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id7">[3]</a></td><td>It is planned that a future version of SIP will allow arguments to be
named and that the names will be used as Python keyword arguments.</td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4" name="id8">[4]</a></td><td>On Windows you might run <tt class="literal"><span class="pre">nmake</span></tt> or <tt class="literal"><span class="pre">mingw32-make</span></tt> instead.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id32" name="id9">3.2   A Simple C Example</a></h2>
<p>Let's now look at a very similar example of wrapping a C library:</p>
<pre class="literal-block">
/* Define the interface to the word library. */

struct Word {
    const char *the_word;
};

struct Word *create_word(const char *w);
char *reverse(struct Word *word);
</pre>
<p>The corresponding SIP specification file would then look something like this:</p>
<pre class="literal-block">
/* Define the SIP wrapper to the word library. */

%CModule word 0

struct Word {

%TypeHeaderCode
#include &lt;word.h&gt;
%End

    const char *the_word;
};

struct Word *create_word(const char *);
char *reverse(struct Word *);
</pre>
<p>Again, let's look at the differences between the two files.</p>
<blockquote>
<ul class="simple">
<li>The <a class="reference" href="#cmodule">%CModule</a> directive has been added.  This has the same syntax as
the <a class="reference" href="#module">%Module</a> directive used in the previous example but tells SIP that
the library being wrapped is implemented in C rather than C++.</li>
<li>The <a class="reference" href="#typeheadercode">%TypeHeaderCode</a> directive has been added.</li>
<li>The names of the arguments to the functions have been removed.</li>
</ul>
</blockquote>
<p>The <tt class="literal"><span class="pre">configure.py</span></tt> build system script described in the previous example can
be used for this example without change.</p>
</div>
<div class="section" id="a-more-complex-c-example">
<h2><a class="toc-backref" href="#id33" name="a-more-complex-c-example">3.3   A More Complex C++ Example</a></h2>
<p>In this last example we will wrap a C++ library that contains a class that is
derived from a Qt class.  This will demonstrate how SIP allows a class
hierarchy to be split across multiple Python extension modules, and will
introduce SIP's versioning system.</p>
<p>The library contains a single C++ class called <tt class="literal"><span class="pre">Hello</span></tt> which is derived from
Qt's <tt class="literal"><span class="pre">QLabel</span></tt> class.  It behaves just like <tt class="literal"><span class="pre">QLabel</span></tt> except that the text
in the label is hard coded to be <tt class="literal"><span class="pre">Hello</span> <span class="pre">World</span></tt>.  To make the example more
interesting we'll also say that the library only supports Qt v3.0 and later,
and also includes a function called <tt class="literal"><span class="pre">setDefault()</span></tt> that is not implemented
in the Windows version of the library.</p>
<p>The <tt class="literal"><span class="pre">hello.h</span></tt> header file looks something like this:</p>
<pre class="literal-block">
// Define the interface to the hello library.

#include &lt;qlabel.h&gt;
#include &lt;qwidget.h&gt;
#include &lt;qstring.h&gt;

class Hello : public QLabel {
    // This is needed by the Qt Meta-Object Compiler.
    Q_OBJECT

public:
    Hello(QWidget *parent, const char *name = 0, WFlags f = 0);

private:
    // Prevent instances from being copied.
    Hello(const Hello &amp;);
    Hello &amp;operator=(const Hello &amp;);
};

#if !defined(Q_OS_WIN)
void setDefault(const QString &amp;def);
#endif
</pre>
<p>The corresponding SIP specification file would then look something like this:</p>
<pre class="literal-block">
// Define the SIP wrapper to the hello library.

%Module hello 0

%Import qt/qtmod.sip

%If (Qt_3_0_0 -)

class Hello : QLabel {

%TypeHeaderCode
#include &lt;hello.h&gt;
%End

public:
    Hello(QWidget * /TransferThis/, const char * = 0, WFlags = 0);

private:
    Hello(const Hello &amp;);
};

%If (!WS_WIN)
void setDefault(const QString &amp;);
%End

%End
</pre>
<p>Again we look at the differences, but we'll skip those that we've looked at in
previous examples.</p>
<blockquote>
<ul class="simple">
<li>The <a class="reference" href="#import">%Import</a> directive has been added to specify that we are extending
the class hierarchy defined in the file <tt class="literal"><span class="pre">qt/qtmod.sip</span></tt>.  This file is
part of PyQt.  The build system will take care of finding the file's
exact location.</li>
<li>The <a class="reference" href="#if">%If</a> directive has been added to specify that
everything <a class="footnote-reference" href="#id13" id="id10" name="id10"><sup>5</sup></a> up to the matching <a class="reference" href="#end">%End</a> directive only applies to Qt
v3.0 and later.  <tt class="literal"><span class="pre">Qt_3_0_0</span></tt> is a <em>tag</em> defined in <tt class="literal"><span class="pre">qtmod.sip</span></tt> <a class="footnote-reference" href="#id14" id="id11" name="id11"><sup>6</sup></a>
using the <a class="reference" href="#timeline">%Timeline</a> directive.  <a class="reference" href="#timeline">%Timeline</a> is used to define a tag
for each version of a library's API you are wrapping allowing you to
maintain all the different versions in a single SIP specification.  The
build system provides support to <tt class="literal"><span class="pre">configure.py</span></tt> scripts for working out
the correct tags to use according to which version of the library is
actually installed.</li>
<li>The <tt class="literal"><span class="pre">public</span></tt> keyword used in defining the super-classes has been
removed.  This is not supported by SIP.</li>
<li>The <a class="reference" href="#transferthis">TransferThis</a> annotation has been added to the first argument
of the constructor.  It specifies that if the argument is not 0 (i.e. the
<tt class="literal"><span class="pre">Hello</span></tt> instance being constructed has a parent) then ownership of the
instance is transferred from Python to C++.  It is needed because Qt
maintains objects (i.e. instances derived from the <tt class="literal"><span class="pre">QObject</span></tt> class) in
a hierachy.  When an object is destroyed all of its children are also
automatically destroyed.  It is important, therefore, that the Python
garbage collector doesn't also try and destroy them.  This is covered in
more detail in <a class="reference" href="#ownership-of-objects">Ownership of Objects</a>.  SIP provides many other
annotations that can be applied to arguments, functions and classes.
Multiple annotations are separated by commas.  Annotations may have
values.</li>
<li>The <tt class="literal"><span class="pre">=</span></tt> operator has been removed.  This operator is not supported by
SIP.</li>
<li>The <a class="reference" href="#if">%If</a> directive has been added to specify that everything up to the
matching <a class="reference" href="#end">%End</a> directive does not apply to Windows.  <tt class="literal"><span class="pre">WS_WIN</span></tt> is
another tag defined by PyQt, this time using the <a class="reference" href="#platforms">%Platforms</a> directive.
Tags defined by the <a class="reference" href="#platforms">%Platforms</a> directive are mutually exclusive, i.e.
only one may be valid at a time <a class="footnote-reference" href="#id15" id="id12" name="id12"><sup>7</sup></a>.</li>
</ul>
</blockquote>
<p>One question you might have at this point is why bother to define the private
copy constructor when it can never be called from Python?  The answer is to
prevent the automatic generation of a public copy constructor.</p>
<p>We now look at the <tt class="literal"><span class="pre">configure.py</span></tt> script.  This is a little different to the
script in the previous examples for two related reasons.</p>
<p>Firstly, PyQt includes a pure Python module called <tt class="literal"><span class="pre">pyqtconfig</span></tt> that extends
the SIP build system for modules, like our example, that build on top of PyQt.
It deals with the details of which version of Qt is being used (i.e. it
determines what the correct tags are) and where it is installed.  This is
called a module's configuration module.</p>
<p>Secondly, we generate a configuration module (called <tt class="literal"><span class="pre">helloconfig</span></tt>) for our
own <tt class="literal"><span class="pre">hello</span></tt> module.  There is no need to do this, but if there is a chance
that somebody else might want to extend your C++ library then it would make
life easier for them.</p>
<p>Now we have two scripts.  First the <tt class="literal"><span class="pre">configure.py</span></tt> script:</p>
<pre class="literal-block">
import os
import sipconfig
import pyqtconfig

# The name of the SIP build file generated by SIP and used by the build
# system.
build_file = &quot;hello.sbf&quot;

# Get the PyQt configuration information.
config = pyqtconfig.Configuration()

# Get the extra SIP flags needed by the imported qt module.  Note that
# this normally only includes those flags (-x and -t) that relate to SIP's
# versioning system.
qt_sip_flags = config.pyqt_qt_sip_flags

# Run SIP to generate the code.  Note that we tell SIP where to find the qt
# module's specification files using the -I flag.
os.system(&quot; &quot;.join([config.sip_bin, &quot;-c&quot;, &quot;.&quot;, &quot;-b&quot;, build_file, &quot;-I&quot;, config.pyqt_sip_dir, qt_sip_flags, &quot;hello.sip&quot;]))

# We are going to install the SIP specification file for this module and
# its configuration module.
installs = []

installs.append([&quot;hello.sip&quot;, os.path.join(config.default_sip_dir, &quot;hello&quot;)])

installs.append([&quot;helloconfig.py&quot;, config.default_mod_dir])

# Create the Makefile.  The QtModuleMakefile class provided by the
# pyqtconfig module takes care of all the extra preprocessor, compiler and
# linker flags needed by the Qt library.
makefile = pyqtconfig.QtModuleMakefile(
    configuration=config,
    build_file=build_file,
    installs=installs
)

# Add the library we are wrapping.  The name doesn't include any platform
# specific prefixes or extensions (e.g. the &quot;lib&quot; prefix on UNIX, or the
# &quot;.dll&quot; extension on Windows).
makefile.extra_libs = [&quot;hello&quot;]

# Generate the Makefile itself.
makefile.generate()

# Now we create the configuration module.  This is done by merging a Python
# dictionary (whose values are normally determined dynamically) with a
# (static) template.
content = {
    # Publish where the SIP specifications for this module will be
    # installed.
    &quot;hello_sip_dir&quot;:    config.default_sip_dir,

    # Publish the set of SIP flags needed by this module.  As these are the
    # same flags needed by the qt module we could leave it out, but this
    # allows us to change the flags at a later date without breaking
    # scripts that import the configuration module.
    &quot;hello_sip_flags&quot;:  qt_sip_flags
}

# This create the helloconfig.py module from the helloconfig.py.in template
# and the dictionary.
sipconfig.create_config_module(&quot;helloconfig.py&quot;, &quot;helloconfig.py.in&quot;, content)
</pre>
<p>Next we have the <tt class="literal"><span class="pre">helloconfig.py.in</span></tt> template script:</p>
<pre class="literal-block">
import pyqtconfig

# These are installation specific values created when Hello was configured.
# The following line will be replaced when this template is used to create
# the final configuration module.
# &#64;SIP_CONFIGURATION&#64;

class Configuration(pyqtconfig.Configuration):
    &quot;&quot;&quot;The class that represents Hello configuration values.
    &quot;&quot;&quot;
    def __init__(self, sub_cfg=None):
        &quot;&quot;&quot;Initialise an instance of the class.

        sub_cfg is the list of sub-class configurations.  It should be None
        when called normally.
        &quot;&quot;&quot;
        # This is all standard code to be copied verbatim except for the
        # name of the module containing the super-class.
        if sub_cfg:
            cfg = sub_cfg
        else:
            cfg = []

        cfg.append(_pkg_config)

        pyqtconfig.Configuration.__init__(self, cfg)

class HelloModuleMakefile(pyqtconfig.QtModuleMakefile):
    &quot;&quot;&quot;The Makefile class for modules that %Import hello.
    &quot;&quot;&quot;
    def finalise(self):
        &quot;&quot;&quot;Finalise the macros.
        &quot;&quot;&quot;
        # Make sure our C++ library is linked.
        self.extra_libs.append(&quot;hello&quot;)

        # Let the super-class do what it needs to.
        pyqtconfig.QtModuleMakefile.finalise(self)
</pre>
<p>Again, we hope that the scripts are self documenting.</p>
<table class="footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10" name="id13">[5]</a></td><td>Some parts of a SIP specification aren't subject to version control.</td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11" name="id14">[6]</a></td><td>Actually in <tt class="literal"><span class="pre">versions.sip</span></tt>.  PyQt uses the <a class="reference" href="#include">%Include</a> directive to
split the SIP specification for Qt across a large number of separate
<tt class="literal"><span class="pre">.sip</span></tt> files.</td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12" name="id15">[7]</a></td><td>Tags can also be defined by the <a class="reference" href="#feature">%Feature</a> directive.  These tags are
not mutually exclusive, i.e. any number may be valid at a time.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="ownership-of-objects">
<h2><a class="toc-backref" href="#id34" name="ownership-of-objects">3.4   Ownership of Objects</a></h2>
<p>When a C++ instance is wrapped a corresponding Python object is created.  The
Python object behaves as you would expect in regard to garbage collection - it
is garbage collected when its reference count reaches zero.  What then happens
to the corresponding C++ instance?  The obvious answer might be that the
instance's destructor is called.  However the library API may say that when the
instance is passed to a particular function, the library takes ownership of the
instance, i.e. responsibility for calling the instance's destructor is
transferred from the SIP generated module to the library.</p>
<p>The <a class="reference" href="#transferthis">TransferThis</a>, <a class="reference" href="#transfer">Transfer</a> and <a class="reference" href="#transferback">TransferBack</a> annotations are used to specify
where, and it what direction, transfers of ownership happen.  It is very
important that these are specified correctly to avoid crashes (where both
Python and C++ call the destructor) and memory leaks (where neither Python and
C++ call the destructor).</p>
<p>This applies equally to C structures where the structure is returned to the
heap using the <tt class="literal"><span class="pre">free()</span></tt> function.</p>
<p>See also <a class="reference" href="#siptransfer">sipTransfer()</a>.</p>
</div>
</div>
<div class="section" id="the-sip-command-line">
<h1><a class="toc-backref" href="#id35" name="the-sip-command-line">4   The SIP Command Line</a></h1>
<p>The syntax of the SIP command line is:</p>
<pre class="literal-block">
sip [options] [specification]
</pre>
<p><tt class="literal"><span class="pre">specification</span></tt> is the name of the specification file for the module.  If it
is omitted then <tt class="literal"><span class="pre">stdin</span></tt> is used.</p>
<p>The full set of command line options is:</p>
<table class="option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td>
<kbd><span class="option">-h</span></kbd></td>
<td>Display a help message.</td></tr>
<tr><td>
<kbd><span class="option">-V</span></kbd></td>
<td>Display the SIP version number.</td></tr>
<tr><td>
<kbd><span class="option">-a</span> <var>file</var></kbd></td>
<td>The name of the Scintilla API file to generate.  This file contains a
description of the module API in a form that the Scintilla editor
component can use for auto-completion and call tips.  By default the
file is not generated.</td></tr>
<tr><td>
<kbd><span class="option">-b</span> <var>file</var></kbd></td>
<td>The name of the build file to generate.  This file contains the
information about the module needed by the SIP build system to generate
a platform and compiler specific Makefile for the module.  By default
the file is not generated.</td></tr>
<tr><td>
<kbd><span class="option">-c</span> <var>dir</var></kbd></td>
<td>The name of the directory (which must exist) into which all of the
generated C or C++ code is placed.  By default no code is generated.</td></tr>
<tr><td>
<kbd><span class="option">-d</span> <var>file</var></kbd></td>
<td>The name of the documentation file to generate.  Documentation is
included in specification files using the <a class="reference" href="#doc">%Doc</a> and <a class="reference" href="#exporteddoc">%ExportedDoc</a>
directives.  By default the file is not generated.</td></tr>
<tr><td>
<kbd><span class="option">-e</span></kbd></td>
<td>Support for C++ exceptions is enabled.  The causes all calls to C++
code to be enclosed in <tt class="literal"><span class="pre">try</span></tt>/<tt class="literal"><span class="pre">catch</span></tt> blocks and C++ exceptions
converted to Python exceptions.  By default exception support is
disabled.</td></tr>
<tr><td>
<kbd><span class="option">-g</span></kbd></td>
<td>The GIL is always released when making calls to C or C++ code and
reacquired on return.  (This is the SIP v3.x behaviour.)  By default
the enhanced GIL management functions described in PEP 311 are used so
that the GIL is released only when necessary.</td></tr>
<tr><td>
<kbd><span class="option">-I</span> <var>dir</var></kbd></td>
<td>The directory is added to the list of directories searched when looking
for a specification file given in an <a class="reference" href="#include">%Include</a> or <a class="reference" href="#import">%Import</a>
directive.  This option may be given any number of times.</td></tr>
<tr><td>
<kbd><span class="option">-j</span> <var>number</var></kbd></td>
<td>The generated code is split into the given number of files.  This make
it easier to use the parallel build facility of most modern
implementations of <tt class="literal"><span class="pre">make</span></tt>.  By default 1 file is generated for each C
structure or C++ class.</td></tr>
<tr><td>
<kbd><span class="option">-r</span></kbd></td>
<td>Debugging statements that trace the execution of the bindings are
automatically generated.  By default the statements are not generated.</td></tr>
<tr><td>
<kbd><span class="option">-s</span> <var>suffix</var></kbd></td>
<td>The suffix to use for generated C or C++ source files.  By default
<tt class="literal"><span class="pre">.c</span></tt> is used for C and <tt class="literal"><span class="pre">.cpp</span></tt> for C++.</td></tr>
<tr><td>
<kbd><span class="option">-t</span> <var>tag</var></kbd></td>
<td>The SIP version tag (declared using the <a class="reference" href="#timeline">%Timeline</a> directive) or the
SIP platform tag (declared using the <a class="reference" href="#platforms">%Platforms</a> directive) to
generate code for.  This option may be given any number of times so
long as the tags do not conflict.</td></tr>
<tr><td>
<kbd><span class="option">-w</span></kbd></td>
<td>The display of warning messages is enabled.  By default warning
messages are disabled.</td></tr>
<tr><td>
<kbd><span class="option">-x</span> <var>feature</var></kbd></td>
<td>The feature (declared using the <a class="reference" href="#feature">%Feature</a> directive) is disabled.</td></tr>
<tr><td>
<kbd><span class="option">-z</span> <var>file</var></kbd></td>
<td>The name of a file containing more command line options.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="sip-specification-files">
<h1><a class="toc-backref" href="#id36" name="sip-specification-files">5   SIP Specification Files</a></h1>
<p>A SIP specification consists of some C/C++ type and function declarations and
some directives.  The declarations may contain annotations which provide SIP
with additional information that cannot be expressed in C/C++.  SIP does not
include a full C/C++ parser.</p>
<p>It is important to understand that a SIP specification describes the Python
API, i.e. the API available to the Python programmer when they <tt class="literal"><span class="pre">import</span></tt> the
generated module.  It does not have to accurately represent the underlying
C/C++ library.  There is nothing wrong with omitting functions that make
little sense in a Python context, or adding functions implemented with
handwritten code that have no C/C++ equivalent.  It is even possible (and
sometimes necessary) to specify a different super-class hierarchy for a C++
class.  All that matters is that the generated code compiles properly.</p>
<p>In most cases the Python API matches the C/C++ API.  In some cases handwritten
code (see <a class="reference" href="#methodcode">%MethodCode</a>) is used to map from one to the other without SIP
having to know the details itself.  However, there are a few cases where SIP
generates a thin wrapper around a C++ method or constructor (see <a class="reference" href="#generated-derived-classes">Generated
Derived Classes</a>) and needs to know the exact C++ signature.  To deal with
these cases SIP allows two signatures to be specified.  For example:</p>
<pre class="literal-block">
class Klass
{
public:
    // The Python signature is a tuple, but the underlying C++ signature
    // is a 2 element array.
    Klass(SIP_PYTUPLE) [(int *)];
%MethodCode
        int iarr[2];

        if (PyArg_ParseTuple(a0, &quot;ii&quot;, &amp;iarr[0], &amp;iarr[1]))
        {
            // Note that we use the SIP generated derived class
            // constructor.
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipKlass(iarr);
            Py_END_ALLOW_THREADS
        }
%End
};
</pre>
<div class="section" id="syntax-definition">
<h2><a class="toc-backref" href="#id37" name="syntax-definition">5.1   Syntax Definition</a></h2>
<p>The following is a semi-formal description of the syntax of a specification
file.</p>
<pre class="literal-block">
<em>specification</em> ::= {<em>module-statement</em>}

<em>module-statement</em> ::= [<em>module-directive</em> | <em>statement</em>]

<em>module-directive</em> ::= [<a class="reference" href="#cmodule">%CModule</a> | <a class="reference" href="#copying">%Copying</a> | <a class="reference" href="#doc">%Doc</a> |
        <a class="reference" href="#exporteddoc">%ExportedDoc</a> | <a class="reference" href="#feature">%Feature</a> | <a class="reference" href="#import">%Import</a> | <a class="reference" href="#include">%Include</a> |
        <a class="reference" href="#id16">%License</a> | <a class="reference" href="#mappedtype">%MappedType</a> <a class="reference" href="#module">%Module</a> | <a class="reference" href="#modulecode">%ModuleCode</a> |
        <a class="reference" href="#moduleheadercode">%ModuleHeaderCode</a> | <a class="reference" href="#optionalinclude">%OptionalInclude</a> | <a class="reference" href="#platforms">%Platforms</a> |
        <a class="reference" href="#postinitialisationcode">%PostInitialisationCode</a> | <a class="reference" href="#timeline">%Timeline</a>]

<em>statement</em> :: [<em>class-statement</em> | <em>function</em> | <em>variable</em>]

<em>class-statement</em> :: [<a class="reference" href="#if">%If</a> | <em>class</em> | <em>enum</em> | <em>namespace</em> |
        <em>opaque-class</em> | <em>struct</em> | <em>typedef</em>]

<em>class</em> ::= <tt class="literal"><span class="pre">class</span></tt> <em>name</em> [<tt class="literal"><span class="pre">:</span></tt> <em>super-classes</em>] <tt class="literal"><span class="pre">{</span></tt> {<em>class-line</em>} <tt class="literal"><span class="pre">};</span></tt>

<em>super-classes</em> ::= <em>name</em> [<tt class="literal"><span class="pre">,</span></tt> <em>super-classes</em>]

<em>class-line</em> ::= [<em>class-statement</em> | <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> |
        <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> | <a class="reference" href="#typecode">%TypeCode</a> | <a class="reference" href="#typeheadercode">%TypeHeaderCode</a> |
        <em>constructor</em> | <em>destructor</em> | <em>method</em> | <em>static-method</em> |
        <em>virtual-method</em> | <em>special-method</em> | <em>operator</em> |
        <em>class-variable</em> | <tt class="literal"><span class="pre">public:</span></tt> | <tt class="literal"><span class="pre">public</span> <span class="pre">slots:</span></tt> |
        <tt class="literal"><span class="pre">protected:</span></tt> | <tt class="literal"><span class="pre">protected</span> <span class="pre">slots:</span></tt> | <tt class="literal"><span class="pre">private:</span></tt> |
        <tt class="literal"><span class="pre">private</span> <span class="pre">slots:</span></tt> | <tt class="literal"><span class="pre">signals:</span></tt>]

<em>constructor</em> ::= <em>name</em> <tt class="literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="literal"><span class="pre">)</span></tt> [<em>exceptions</em>]
        [<em>function-annotations</em>] [<em>c++-constructor-signature</em>] <tt class="literal"><span class="pre">;</span></tt>
        [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>c++-constructor-signature</em> ::= <tt class="literal"><span class="pre">[(</span></tt> [<em>argument-list</em>] <tt class="literal"><span class="pre">)]</span></tt>

<em>destructor</em> ::= [<tt class="literal"><span class="pre">virtual</span></tt>] <tt class="literal"><span class="pre">~</span></tt> <em>name</em> <tt class="literal"><span class="pre">()</span></tt> [<em>exceptions</em>]
        [<em>function-annotations</em>] <tt class="literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]
        [<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a>]

<em>method</em> ::= <em>type</em> <em>name</em> <tt class="literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="literal"><span class="pre">)</span></tt> [<tt class="literal"><span class="pre">const</span></tt>]
        [<em>exceptions</em>] [<tt class="literal"><span class="pre">=</span> <span class="pre">0</span></tt>] [<em>function-annotations</em>] [<em>c++-signature</em>]
        <tt class="literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>c++-signature</em> ::= <tt class="literal"><span class="pre">[</span></tt> <em>type</em> <tt class="literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="literal"><span class="pre">)]</span></tt>

<em>static-method</em> ::= <tt class="literal"><span class="pre">static</span></tt> <em>function</em>

<em>virtual-method</em> ::= <tt class="literal"><span class="pre">virtual</span></tt> <em>type</em> <em>name</em> <tt class="literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="literal"><span class="pre">)</span></tt>
        [<tt class="literal"><span class="pre">const</span></tt>] [<em>exceptions</em>] [<tt class="literal"><span class="pre">=</span> <span class="pre">0</span></tt>] [<em>function-annotations</em>]
        [<em>c++-signature</em>] <tt class="literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>] [<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a>]

<em>special-method</em> ::= <em>type</em> <em>special-method-name</em>
        <tt class="literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="literal"><span class="pre">)</span></tt> [<em>function-annotations</em>] <tt class="literal"><span class="pre">;</span></tt>
        [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>special-method-name</em> ::= [ <tt class="literal"><span class="pre">__add__</span></tt> | <tt class="literal"><span class="pre">__and__</span></tt> | <tt class="literal"><span class="pre">__call__</span></tt> |
        <tt class="literal"><span class="pre">__cmp__</span></tt> | <tt class="literal"><span class="pre">__contains__</span></tt> | <tt class="literal"><span class="pre">__delitem__</span></tt> | <tt class="literal"><span class="pre">__div__</span></tt> |
        <tt class="literal"><span class="pre">__eq__</span></tt> | <tt class="literal"><span class="pre">__ge__</span></tt> | <tt class="literal"><span class="pre">__getitem__</span></tt> | <tt class="literal"><span class="pre">__gt__</span></tt> |
        <tt class="literal"><span class="pre">__iadd__</span></tt> | <tt class="literal"><span class="pre">__iand__</span></tt> | <tt class="literal"><span class="pre">__idiv__</span></tt> | <tt class="literal"><span class="pre">__ilshift__</span></tt> |
        <tt class="literal"><span class="pre">__imod__</span></tt> | <tt class="literal"><span class="pre">__imul__</span></tt> | <tt class="literal"><span class="pre">__int__</span></tt> | <tt class="literal"><span class="pre">__invert__</span></tt> |
        <tt class="literal"><span class="pre">__ior__</span></tt> | <tt class="literal"><span class="pre">__irshift__</span></tt> | <tt class="literal"><span class="pre">__isub__</span></tt> | <tt class="literal"><span class="pre">__ixor__</span></tt> |
        <tt class="literal"><span class="pre">__le__</span></tt> | <tt class="literal"><span class="pre">__len__</span></tt> | <tt class="literal"><span class="pre">__lshift__</span></tt> | <tt class="literal"><span class="pre">__lt__</span></tt> |
        <tt class="literal"><span class="pre">__mod__</span></tt> | <tt class="literal"><span class="pre">__mul__</span></tt> | <tt class="literal"><span class="pre">__ne__</span></tt> | <tt class="literal"><span class="pre">__neg__</span></tt> |
        <tt class="literal"><span class="pre">__nonzero__</span></tt> | <tt class="literal"><span class="pre">__or__</span></tt> | <tt class="literal"><span class="pre">__repr__</span></tt> | <tt class="literal"><span class="pre">__rshift__</span></tt> |
        <tt class="literal"><span class="pre">__setitem__</span></tt> | <tt class="literal"><span class="pre">__str__</span></tt> | <tt class="literal"><span class="pre">__sub__</span></tt> | <tt class="literal"><span class="pre">__unicode__</span></tt> |
        <tt class="literal"><span class="pre">__xor__</span></tt>]

<em>operator</em> ::= <em>type</em> <tt class="literal"><span class="pre">operator</span></tt> <em>operator-name</em>
        <tt class="literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="literal"><span class="pre">)</span></tt> [<tt class="literal"><span class="pre">const</span></tt>] [<em>exceptions</em>]
        [<em>function-annotations</em>] <tt class="literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>operator-name</em> ::= [<tt class="literal"><span class="pre">+</span></tt> | <tt class="literal"><span class="pre">-</span></tt> | <tt class="literal"><span class="pre">*</span></tt> | <tt class="literal"><span class="pre">/</span></tt> | <tt class="literal"><span class="pre">%</span></tt> | <tt class="literal"><span class="pre">&amp;</span></tt> |
        <tt class="literal"><span class="pre">|</span></tt> | <tt class="literal"><span class="pre">^</span></tt> | <tt class="literal"><span class="pre">&lt;&lt;</span></tt> | <tt class="literal"><span class="pre">&gt;&gt;</span></tt> | <tt class="literal"><span class="pre">+=</span></tt> | <tt class="literal"><span class="pre">-=</span></tt> | <tt class="literal"><span class="pre">*=</span></tt> |
        <tt class="literal"><span class="pre">/=</span></tt> | <tt class="literal"><span class="pre">%=</span></tt> | <tt class="literal"><span class="pre">&amp;=</span></tt> | <tt class="literal"><span class="pre">|=</span></tt> | <tt class="literal"><span class="pre">^=</span></tt> | <tt class="literal"><span class="pre">&lt;&lt;=</span></tt> | <tt class="literal"><span class="pre">&gt;&gt;=</span></tt> |
        <tt class="literal"><span class="pre">~</span></tt> | <tt class="literal"><span class="pre">()</span></tt> | <tt class="literal"><span class="pre">[]</span></tt> | <tt class="literal"><span class="pre">&lt;</span></tt> | <tt class="literal"><span class="pre">&lt;=</span></tt> | <tt class="literal"><span class="pre">==</span></tt> | <tt class="literal"><span class="pre">!=</span></tt> |
        <tt class="literal"><span class="pre">&gt;</span></tt> | <tt class="literal"><span class="pre">&gt;&gt;=</span></tt>]

<em>class-variable</em> ::= [<tt class="literal"><span class="pre">static</span></tt>] <em>variable</em>

<em>enum</em> ::= <tt class="literal"><span class="pre">enum</span></tt> [<em>name</em>] <tt class="literal"><span class="pre">{</span></tt> {<em>enum-line</em>} <tt class="literal"><span class="pre">};</span></tt>

<em>enum-line</em> ::= [<a class="reference" href="#if">%If</a> | <em>name</em>]

<em>function</em> ::= <em>type</em> <em>name</em> <tt class="literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="literal"><span class="pre">)</span></tt> [<em>exceptions</em>]
        [<em>function-annotations</em>] <tt class="literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>namespace</em> ::= <tt class="literal"><span class="pre">namespace</span></tt> <em>name</em> <tt class="literal"><span class="pre">{</span></tt> {<em>namespace-line</em>} <tt class="literal"><span class="pre">};</span></tt>

<em>namespace-line</em> ::= <em>statement</em>

<em>opaque-class</em> ::= <tt class="literal"><span class="pre">class</span></tt> <em>scoped-name</em> <tt class="literal"><span class="pre">;</span></tt>

<em>struct</em> ::= <tt class="literal"><span class="pre">struct</span></tt> <em>name</em> <tt class="literal"><span class="pre">{</span></tt> {<em>class-line</em>} <tt class="literal"><span class="pre">};</span></tt>

<em>typedef</em> ::= <tt class="literal"><span class="pre">typedef</span></tt> <em>type</em> <em>name</em> <tt class="literal"><span class="pre">;</span></tt>

<em>variable</em>::= <em>type</em> <em>name</em> <tt class="literal"><span class="pre">;</span></tt> [<a class="reference" href="#accesscode">%AccessCode</a>]

<em>exceptions</em> ::= <tt class="literal"><span class="pre">throw</span> <span class="pre">(</span></tt> [<em>exception-list</em>] <tt class="literal"><span class="pre">)</span></tt>

<em>exception-list</em> ::= <em>scoped-name</em> [<tt class="literal"><span class="pre">,</span></tt> <em>exception-list</em>]

<em>argument-list</em> ::= <em>argument</em> [<tt class="literal"><span class="pre">,</span></tt> <em>argument-list</em>]

<em>argument</em> ::= [<em>type</em> [<em>argument-annotations</em>] [<em>default-value</em>] | 
        <a class="reference" href="#sip-qobject">SIP_QOBJECT</a> | <a class="reference" href="#sip-rxobj-con">SIP_RXOBJ_CON</a> | <a class="reference" href="#sip-rxobj-dis">SIP_RXOBJ_DIS</a> | <a class="reference" href="#sip-signal">SIP_SIGNAL</a> |
        <a class="reference" href="#sip-slot">SIP_SLOT</a> | SIP_SLOT_CON()_ | SIP_SLOT_DIS()_]

<em>default-value</em> ::= <tt class="literal"><span class="pre">=</span></tt> <em>expression</em>

<em>expression</em> ::= [<em>value</em> | <em>value</em> <em>binary-operator</em> <em>expression</em>]

<em>value</em> ::= [<em>unary-operator</em>] <em>simple-value</em>

<em>simple-value</em> ::= [<em>scoped-name</em> | <em>function-call</em> | <em>real-value</em> |
        <em>integer-value</em> | <em>boolean-value</em> | <em>string-value</em> |
        <em>character-value</em>]

<em>function-call</em> ::= <em>scoped-name</em> <tt class="literal"><span class="pre">(</span></tt> [<em>value-list</em>] <tt class="literal"><span class="pre">)</span></tt>

<em>value-list</em> ::= <em>value</em> [<tt class="literal"><span class="pre">,</span></tt> <em>value-list</em>]

<em>real-value</em> ::= a floating point number

<em>integer-value</em> ::= a number

<em>boolean-value</em> ::= [<tt class="literal"><span class="pre">true</span></tt> | <tt class="literal"><span class="pre">false</span></tt>]

<em>string-value</em> ::= <tt class="literal"><span class="pre">&quot;</span></tt> {<em>character</em>} <tt class="literal"><span class="pre">&quot;</span></tt>

<em>character-value</em> ::= <tt class="literal"><span class="pre">`</span></tt> <em>character</em> <tt class="literal"><span class="pre">`</span></tt>

<em>unary-operator</em> ::= [<tt class="literal"><span class="pre">!</span></tt> | <tt class="literal"><span class="pre">~</span></tt> | <tt class="literal"><span class="pre">-</span></tt> | <tt class="literal"><span class="pre">+</span></tt>]

<em>binary-operator</em> ::= [<tt class="literal"><span class="pre">-</span></tt> | <tt class="literal"><span class="pre">+</span></tt> | <tt class="literal"><span class="pre">*</span></tt> | <tt class="literal"><span class="pre">/</span></tt> | <tt class="literal"><span class="pre">&amp;</span></tt> | <tt class="literal"><span class="pre">|</span></tt>]

<em>function-annotations</em> ::= see <a class="reference" href="#function-annotations">Function Annotations</a>

<em>argument-annotations</em> ::= see <a class="reference" href="#argument-annotations">Argument Annotations</a>

<em>type</em> ::= [<tt class="literal"><span class="pre">const</span></tt>] <em>base-type</em> {<tt class="literal"><span class="pre">*</span></tt>} [<tt class="literal"><span class="pre">&amp;</span></tt>]

<em>type-list</em> ::= <em>type</em> [<tt class="literal"><span class="pre">,</span></tt> <em>type-list</em>]

<em>base-type</em> ::= [<em>scoped-name</em> | <em>template</em> | <tt class="literal"><span class="pre">struct</span></tt> <em>scoped-name</em> |
        <tt class="literal"><span class="pre">short</span></tt> | <tt class="literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt> | <tt class="literal"><span class="pre">int</span></tt> | <tt class="literal"><span class="pre">unsigned</span></tt> |
        <tt class="literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> | <tt class="literal"><span class="pre">long</span></tt> | <tt class="literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt> | <tt class="literal"><span class="pre">float</span></tt> |
        <tt class="literal"><span class="pre">double</span></tt> | <tt class="literal"><span class="pre">bool</span></tt> | <tt class="literal"><span class="pre">char</span></tt> | <tt class="literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt> | <tt class="literal"><span class="pre">void</span></tt> |
        <a class="reference" href="#sip-pycallable">SIP_PYCALLABLE</a> | <a class="reference" href="#sip-pydict">SIP_PYDICT</a> | <a class="reference" href="#sip-pylist">SIP_PYLIST</a> | <a class="reference" href="#sip-pyobject">SIP_PYOBJECT</a> |
        <a class="reference" href="#sip-pytuple">SIP_PYTUPLE</a> | <a class="reference" href="#sip-pyslice">SIP_PYSLICE</a>]

<em>scoped-name</em> ::= <em>name</em> [<tt class="literal"><span class="pre">::</span></tt> <em>scoped-name</em>]

<em>template</em> ::= <em>scoped-name</em> <tt class="literal"><span class="pre">&lt;</span></tt> <em>type-list</em> <tt class="literal"><span class="pre">&gt;</span></tt>

<em>name</em> ::= _A-Za-z {_A-Za-z0-9}
</pre>
<p>Here is a short list of differences between C++ and the subset supported by
SIP that might trip you up.</p>
<blockquote>
<ul class="simple">
<li>SIP does not support the use of <tt class="literal"><span class="pre">[]</span></tt> in types.  Use pointers instead.</li>
<li><tt class="literal"><span class="pre">operator</span></tt> can only be used in a class.</li>
<li>Variables declared outside of a class are effectively read-only.</li>
<li>Functions and methods do not support argument names.</li>
<li>A class's list of super-classes doesn't not include any access specifier
(e.g. <tt class="literal"><span class="pre">public</span></tt>).</li>
</ul>
</blockquote>
</div>
<div class="section" id="additional-sip-types">
<h2><a class="toc-backref" href="#id38" name="additional-sip-types">5.2   Additional SIP Types</a></h2>
<p>SIP supports a number of additional data types that can be used in Python
signatures.</p>
<div class="section" id="sip-pycallable">
<h3><a class="toc-backref" href="#id39" name="sip-pycallable">5.2.1   SIP_PYCALLABLE</a></h3>
<p>This is a <tt class="literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python callable object.</p>
</div>
<div class="section" id="sip-pydict">
<h3><a class="toc-backref" href="#id40" name="sip-pydict">5.2.2   SIP_PYDICT</a></h3>
<p>This is a <tt class="literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python dictionary object.</p>
</div>
<div class="section" id="sip-pylist">
<h3><a class="toc-backref" href="#id41" name="sip-pylist">5.2.3   SIP_PYLIST</a></h3>
<p>This is a <tt class="literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python list object.</p>
</div>
<div class="section" id="sip-pyobject">
<h3><a class="toc-backref" href="#id42" name="sip-pyobject">5.2.4   SIP_PYOBJECT</a></h3>
<p>This is a <tt class="literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> of any Python type.</p>
</div>
<div class="section" id="sip-pytuple">
<h3><a class="toc-backref" href="#id43" name="sip-pytuple">5.2.5   SIP_PYTUPLE</a></h3>
<p>This is a <tt class="literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python tuple object.</p>
</div>
<div class="section" id="sip-pyslice">
<h3><a class="toc-backref" href="#id44" name="sip-pyslice">5.2.6   SIP_PYSLICE</a></h3>
<p>This is a <tt class="literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python slice object.</p>
</div>
<div class="section" id="sip-qobject">
<h3><a class="toc-backref" href="#id45" name="sip-qobject">5.2.7   SIP_QOBJECT</a></h3>
<p>This is a <tt class="literal"><span class="pre">QObject</span> <span class="pre">*</span></tt> that is a C++ instance of a class derived from Qt's
<tt class="literal"><span class="pre">QObject</span></tt> class.</p>
</div>
<div class="section" id="sip-rxobj-con">
<h3><a class="toc-backref" href="#id46" name="sip-rxobj-con">5.2.8   SIP_RXOBJ_CON</a></h3>
<p>This is a <tt class="literal"><span class="pre">QObject</span> <span class="pre">*</span></tt> that is a C++ instance of a class derived from Qt's
<tt class="literal"><span class="pre">QObject</span></tt> class.  It is used as the type of the receiver instead of <tt class="literal"><span class="pre">const</span>
<span class="pre">QObject</span> <span class="pre">*</span></tt> in functions that implement a connection to a slot.</p>
</div>
<div class="section" id="sip-rxobj-dis">
<h3><a class="toc-backref" href="#id47" name="sip-rxobj-dis">5.2.9   SIP_RXOBJ_DIS</a></h3>
<p>This is a <tt class="literal"><span class="pre">QObject</span> <span class="pre">*</span></tt> that is a C++ instance of a class derived from Qt's
<tt class="literal"><span class="pre">QObject</span></tt> class.  It is used as the type of the receiver instead of <tt class="literal"><span class="pre">const</span>
<span class="pre">QObject</span> <span class="pre">*</span></tt> in functions that implement a disconnection from a slot.</p>
</div>
<div class="section" id="sip-signal">
<h3><a class="toc-backref" href="#id48" name="sip-signal">5.2.10   SIP_SIGNAL</a></h3>
<p>This is a <tt class="literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> that is used as the type of the signal instead of
<tt class="literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> in functions that implement the connection or disconnection
of an explicitly generated signal to a slot.</p>
</div>
<div class="section" id="sip-slot">
<h3><a class="toc-backref" href="#id49" name="sip-slot">5.2.11   SIP_SLOT</a></h3>
<p>This is a <tt class="literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> that is used as the type of the member instead of
<tt class="literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> in functions that implement the connection or disconnection
of an explicitly generated signal to a slot.</p>
</div>
<div class="section" id="sip-slot-con">
<h3><a class="toc-backref" href="#id50" name="sip-slot-con">5.2.12   SIP_SLOT_CON()</a></h3>
<p>This is a <tt class="literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> that is used as the type of the member instead of
<tt class="literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> in functions that implement the connection of an internally
generated signal to a slot.  The type includes a comma separated list of types
that is the C++ signature of of the signal.</p>
<p>To take an example, <tt class="literal"><span class="pre">QAccel::connectItem()</span></tt> connects an internally generated
signal to a slot.  The signal is emitted when the keyboard accelerator is
activated and it has a single integer argument that is the ID of the
accelerator.  The C++ signature is:</p>
<pre class="literal-block">
bool connectItem(int id, const QObject *receiver, const char *member);
</pre>
<p>The corresponding SIP specification is:</p>
<pre class="literal-block">
bool connectItem(int, SIP_RXOBJ_CON, SIP_SLOT_CON(int));
</pre>
</div>
<div class="section" id="sip-slot-dis">
<h3><a class="toc-backref" href="#id51" name="sip-slot-dis">5.2.13   SIP_SLOT_DIS()</a></h3>
<p>This is a <tt class="literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> that is used as the type of the member instead of
<tt class="literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> in functions that implement the disconnection of an
internally generated signal to a slot.  The type includes a comma separated
list of types that is the C++ signature of of the signal.</p>
</div>
</div>
</div>
<div class="section" id="sip-directives">
<h1><a class="toc-backref" href="#id52" name="sip-directives">6   SIP Directives</a></h1>
<p>In this section we describe each of the directives that can be used in
specification files.  All directives begin with <tt class="literal"><span class="pre">%</span></tt> as the first
non-whitespace character in a line.</p>
<p>Some directives have arguments or contain blocks of code or documentation.  In
the following descriptions these are shown in <em>italics</em>.  Optional arguments
are enclosed in [<em>brackets</em>].</p>
<p>Some directives are used to specify handwritten code.  Handwritten code must
not define names that start with the prefix <tt class="literal"><span class="pre">sip</span></tt>.</p>
<div class="section" id="accesscode">
<h2><a class="toc-backref" href="#id53" name="accesscode">6.1   %AccessCode</a></h2>
<pre class="literal-block">
%AccessCode
    <em>code</em>
%End
</pre>
<p>This directive is used immediately after the declaration of an instance of a
wrapped class or structure, or a pointer to such an instance.  You use it to
provide handwritten code that overrides the default behaviour.</p>
<p>For example:</p>
<pre class="literal-block">
class Klass;

Klass *klassInstance;
%AccessCode
    // In this contrived example the C++ library we are wrapping defines
    // klassInstance as Klass ** (which SIP doesn't support) so we
    // explicitly dereference it.
    if (klassInstance &amp;&amp; *klassInstance)
        return *klassInstance;

    // This will get converted to None.
    return 0;
%End
</pre>
</div>
<div class="section" id="cmodule">
<h2><a class="toc-backref" href="#id54" name="cmodule">6.2   %CModule</a></h2>
<pre class="literal-block">
%CModule <em>name</em> [<em>version</em>]
</pre>
<p>This directive is used to identify that the library being wrapped is a C
library and to define the name of the module and it's optional version number.</p>
<p>See the <a class="reference" href="#module">%Module</a> directive for an explanation of the version number.</p>
<p>For example:</p>
<pre class="literal-block">
%CModule dbus 1
</pre>
</div>
<div class="section" id="convertfromtypecode">
<h2><a class="toc-backref" href="#id55" name="convertfromtypecode">6.3   %ConvertFromTypeCode</a></h2>
<pre class="literal-block">
%ConvertFromTypeCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the <a class="reference" href="#mappedtype">%MappedType</a> directive to specify the
handwritten code that converts an instance of a mapped type to a Python
object.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl>
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the instance of the mapped type to be converted.  It
may be zero.</dd>
</dl>
<p>The handwritten code must explicitly return a <tt class="literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt>.  If there was an
error then a Python exception must be raised and <tt class="literal"><span class="pre">NULL</span></tt> returned.</p>
<p>The following example converts a <tt class="literal"><span class="pre">QValueList&lt;int&gt;</span></tt> instance to a Python
list of numbers:</p>
<pre class="literal-block">
%ConvertFromTypeCode
    // Handle the case where the C++ instance is 0.
    if (!sipCpp)
        return PyList_New(0);

    PyObject *l;

    // Create the Python list of the correct length.
    if ((l = PyList_New(sipCpp -&gt; count())) == NULL)
        return NULL;

    // Go through each int in the C++ instance and convert it to a number.
    for (uint i = 0; i &lt; sipCpp -&gt; count(); ++i)
        if (PyList_SetItem(l, i, PyInt_FromLong((*sipCpp)[i])) &lt; 0)
        {
            // There was an error so garbage collect the Python list.
            Py_DECREF(l);
            return NULL;
        }

    // Return the Python list.
    return l;
%End
</pre>
</div>
<div class="section" id="converttosubclasscode">
<h2><a class="toc-backref" href="#id56" name="converttosubclasscode">6.4   %ConvertToSubClassCode</a></h2>
<pre class="literal-block">
%ConvertToSubClassCode
    <em>code</em>
%End
</pre>
<p>When SIP needs to wrap a C++ class instance it first checks to make sure it
hasn't already done so.  If it has then it just returns a new reference to the
corresponding Python object.  Otherwise it creates a new Python object of the
appropriate type.  In C++ a function may be defined to returned an instance of
a certain class, but can often return a sub-class instead.</p>
<p>This directive is used to specify handwritten code that exploits any available
real-time type information (RTTI) to see if there is a more specific Python
type that can be used when wrapping the C++ instance.  The RTTI may be
provided by the compiler or by the C++ instance itself.</p>
<p>The directive is included in the specification of one of the classes that the
handwritten code handles the type conversion for.  It doesn't matter which
one, but a sensible choice would be the one at the root of that class
hierarchy in the module.</p>
<p>Note that if a class hierarchy extends over a number of modules then this
directive should be used in each of those modules to handle the part of the
hierarchy defined in that module.  SIP will ensure that the different pieces
of code are called in the right order to determine the most specific Python
type to use.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl>
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the C++ class instance.</dd>
<dt>sipWrapperType *sipClass</dt>
<dd>The handwritten code must set this to the SIP generated Python type object
that corresponds to the class instance.  (The type object for class
<tt class="literal"><span class="pre">Klass</span></tt> is <tt class="literal"><span class="pre">sipClass_Klass</span></tt>.)  If the RTTI of the class instance isn't
recognised then <tt class="literal"><span class="pre">sipClass</span></tt> must be set to <tt class="literal"><span class="pre">NULL</span></tt>.</dd>
</dl>
<p>The handwritten code must not explicitly return.</p>
<p>The following example shows the sub-class conversion code for <tt class="literal"><span class="pre">QEvent</span></tt> based
class hierarchy in PyQt:</p>
<pre class="literal-block">
class QEvent
{
%ConvertToSubClassCode
    // QEvent sub-classes provide a unique type ID.
    switch (sipCpp -&gt; type())
    {
    case QEvent::Timer:
        sipClass = sipClass_QTimerEvent;
        break;

    case QEvent::KeyPress:
    case QEvent::KeyRelease:
        sipClass = sipClass_QKeyEvent;
        break;

    // Skip the remaining event types the keep the example short.

    default:
        // We don't recognise the type.
        sipClass = NULL;
    }
%End

    // The rest of the class specification.

};
</pre>
<p>The SIP API includes the <a class="reference" href="#sipmapinttoclass">sipMapIntToClass()</a> and <a class="reference" href="#sipmapstringtoclass">sipMapStringToClass()</a>
functions that convert integer and string based RTTI to Python type objects
based on ordered lookup tables.</p>
</div>
<div class="section" id="converttotypecode">
<h2><a class="toc-backref" href="#id57" name="converttotypecode">6.5   %ConvertToTypeCode</a></h2>
<pre class="literal-block">
%ConvertToTypeCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify the handwritten code that converts a Python
object to a mapped type instance.  It is used as part of the <a class="reference" href="#mappedtype">%MappedType</a>
directive and as part of a class specification.  The code is also called to
determine if the Python object is of the correct type prior to conversion.</p>
<p>When used as part of a class specification is can automatically convert
additional types of Python object.  For example, PyQt uses it in the
specification of the <tt class="literal"><span class="pre">QString</span></tt> class to allow Python string objects and
Unicode objects to be used wherever <tt class="literal"><span class="pre">QString</span></tt> instances are expected.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl>
<dt>int *sipIsErr</dt>
<dd>If this is <tt class="literal"><span class="pre">NULL</span></tt> then the code is being asked to check the type of the
Python object.  The check must not have any side effects.  Otherwise the
code is being asked to convert the Python object and a non-zero value
should be returned through this pointer if an error occurred during the
conversion.</dd>
<dt>PyObject *sipPy</dt>
<dd>This is the Python object to be converted.</dd>
<dt><em>type</em> **sipCppPtr</dt>
<dd>This is a pointer through which the address of the mapped type instance (or
zero if appropriate) is returned.  Its value is undefined if <tt class="literal"><span class="pre">sipIsErr</span></tt>
is <tt class="literal"><span class="pre">NULL</span></tt>.</dd>
</dl>
<p>The handwritten code must explicitly return an <tt class="literal"><span class="pre">int</span></tt> that is either zero or
non-zero.  Its meaning depends on the value of <tt class="literal"><span class="pre">sipIsErr</span></tt>.</p>
<p>If <tt class="literal"><span class="pre">sipIsErr</span></tt> is <tt class="literal"><span class="pre">NULL</span></tt> then a non-zero value is returned if the Python
object has a type that can be converted to the mapped type.  Otherwise zero is
returned.</p>
<p>If <tt class="literal"><span class="pre">sipIsErr</span></tt> is not <tt class="literal"><span class="pre">NULL</span></tt> then a non-zero value is returned if the
mapped type instance returned through <tt class="literal"><span class="pre">sipCppPtr</span></tt> was created on the heap.
Otherwise zero is returned.</p>
<p>The following example converts a Python list of numbers to a
<tt class="literal"><span class="pre">QValueList&lt;int&gt;</span></tt> instance:</p>
<pre class="literal-block">
%ConvertToTypeCode
    // See if we are just being asked to check the type of the Python
    // object.
    if (sipIsErr == NULL)
        return PyList_Check(sipPy);

    // We map None to a 0 pointer.
    if (sipPy == Py_None)
    {
        *sipCppPtr = 0;

        // There is nothing on the heap.
        return 0;
    }

    // Create the instance on the heap.
    QValueList&lt;int&gt; *qvl = new QValueList&lt;int&gt;;

    PyErr_Clear();

    for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
    {
        qvl -&gt; append(PyInt_AsLong(PyList_GET_ITEM(sipPy, i)));

        if (PyErr_Occurred() != NULL)
        {
            // Tidy up.
            delete qvl;

            // Set the error flag.
            *sipIsErr = 1;

            // There is nothing on the heap.
            return 0;
        }
    }

    // Return the instance on the heap.
    *sipCppPtr = qvl;

    // The result is a pointer to an instance on the heap.
    return 1;
%End
</pre>
</div>
<div class="section" id="copying">
<h2><a class="toc-backref" href="#id58" name="copying">6.6   %Copying</a></h2>
<pre class="literal-block">
%Copying
    <em>text</em>
%End
</pre>
<p>This directive is used to specify some arbitrary text that will be included at
the start of all source files generated by SIP.  It is normally used to
include copyright and licensing terms.</p>
<p>For example:</p>
<pre class="literal-block">
%Copying
Copyright (c) 2004 Riverbank Computing Limited
%End
</pre>
</div>
<div class="section" id="doc">
<h2><a class="toc-backref" href="#id59" name="doc">6.7   %Doc</a></h2>
<pre class="literal-block">
%Doc
    <em>text</em>
%End
</pre>
<p>This directive is used to specify some arbitrary text that will be extracted
by SIP when the <tt class="literal"><span class="pre">-d</span></tt> command line option is used.  The directive can be
specified any number of times and SIP will concatenate all the separate pieces
of text in the order that it sees them.</p>
<p>Documentation that is specified using this directive is local to the module in
which it appears.  It is ignored by modules that <a class="reference" href="#import">%Import</a> it.  Use the
<a class="reference" href="#exporteddoc">%ExportedDoc</a> directive for documentation that should be included by all
modules that <a class="reference" href="#import">%Import</a> this one.</p>
<p>For example:</p>
<pre class="literal-block">
%Doc
&lt;h1&gt;An Example&lt;/h1&gt;
&lt;p&gt;
This fragment of documentation is HTML and is local to the module in
which it is defined.
&lt;/p&gt;
%End
</pre>
</div>
<div class="section" id="end">
<h2><a class="toc-backref" href="#id60" name="end">6.8   %End</a></h2>
<p>This isn't a directive in itself, but is used to terminate a number of
directives that allow a block of handwritten code or text to be specified.</p>
</div>
<div class="section" id="exporteddoc">
<h2><a class="toc-backref" href="#id61" name="exporteddoc">6.9   %ExportedDoc</a></h2>
<pre class="literal-block">
%ExportedDoc
    <em>text</em>
%End
</pre>
<p>This directive is used to specify some arbitrary text that will be extracted
by SIP when the <tt class="literal"><span class="pre">-d</span></tt> command line option is used.  The directive can be
specified any number of times and SIP will concatenate all the separate pieces
of text in the order that it sees them.</p>
<p>Documentation that is specified using this directive will also be included by
modules that <a class="reference" href="#import">%Import</a> it.</p>
<p>For example:</p>
<pre class="literal-block">
%ExportedDoc
==========
An Example
==========

This fragment of documentation is reStructuredText and will appear in the
module in which it is defined and all modules that %Import it.
%End
</pre>
</div>
<div class="section" id="feature">
<h2><a class="toc-backref" href="#id62" name="feature">6.10   %Feature</a></h2>
<pre class="literal-block">
%Feature <em>name</em>
</pre>
<p>This directive is used to declare a feature.  Features (along with
<a class="reference" href="#platforms">%Platforms</a> and <a class="reference" href="#timeline">%Timeline</a>) are used by the <a class="reference" href="#if">%If</a> directive to control
whether or not parts of a specification are processed or ignored.</p>
<p>Features are mutually independent of each other - any combination of features
may be enabled or disable.  By default all features are enabled.  The SIP
<tt class="literal"><span class="pre">-x</span></tt> command line option is used to disable a feature.</p>
<p>If a feature is enabled then SIP will automatically generate a corresponding C
preprocessor symbol for use by handwritten code.  The symbol is the name of
the feature prefixed by <tt class="literal"><span class="pre">SIP_FEATURE_</span></tt>.</p>
<p>For example:</p>
<pre class="literal-block">
%Feature FOO_SUPPORT

%If (FOO_SUPPORT)
void foo();
%End
</pre>
</div>
<div class="section" id="if">
<h2><a class="toc-backref" href="#id63" name="if">6.11   %If</a></h2>
<pre class="literal-block">
%If (<em>expression</em>)
    <em>specification</em>
%End
</pre>
<p>where</p>
<pre class="literal-block">
<em>expression</em> ::= [<em>ored-qualifiers</em> | <em>range</em>]

<em>ored-qualifiers</em> ::= [<em>qualifier</em> | <em>qualifier</em> <tt class="literal"><span class="pre">||</span></tt> <em>ored-qualifiers</em>]

<em>qualifier</em> ::= [<tt class="literal"><span class="pre">!</span></tt>] [<em>feature</em> | <em>platform</em>]

<em>range</em> ::= [<em>version</em>] <tt class="literal"><span class="pre">-</span></tt> [<em>version</em>]
</pre>
<p>This directive is used in conjunction with features (see <a class="reference" href="#feature">%Feature</a>),
platforms (see <a class="reference" href="#platforms">%Platforms</a>) and versions (see <a class="reference" href="#timeline">%Timeline</a>) to control
whether or not parts of a specification are processed or not.</p>
<p>A <em>range</em> of versions means all versions starting with the lower bound up to
but excluding the upper bound.  If the lower bound is omitted then it is
interpreted as being before the earliest version.  If the upper bound is
omitted then it is interpreted as being after the latest version.</p>
<p>For example:</p>
<pre class="literal-block">
%Feature SUPPORT_FOO
%Platforms {WIN32_PLATFORM POSIX_PLATFORM MACOS_PLATFORM}
%Timeline {V1_0 V1_1 V2_0 V3_0}

%If (!SUPPORT_FOO)
    // Process this if the SUPPORT_FOO feature is disabled.
%End

%If (POSIX_PLATFORM || MACOS_PLATFORM)
    // Process this if either the POSIX_PLATFORM or MACOS_PLATFORM
    // platforms are enabled.
%End

%If (V1_0 - V2_0)
    // Process this if either V1_0 or V1_1 is enabled.
%End

%If (V2_0 - )
    // Process this if either V2_0 or V3_0 is enabled.
%End

%If ( - )
    // Always process this.
%End
</pre>
<p>Note that this directive is not implemented as a preprocessor.  Only the
following parts of a specification are affected by it:</p>
<blockquote>
<ul class="simple">
<li><tt class="literal"><span class="pre">class</span></tt></li>
<li><a class="reference" href="#convertfromtypecode">%ConvertFromTypeCode</a></li>
<li><a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a></li>
<li><a class="reference" href="#converttotypecode">%ConvertToTypeCode</a></li>
<li><tt class="literal"><span class="pre">enum</span></tt></li>
<li>functions</li>
<li><a class="reference" href="#if">%If</a></li>
<li><a class="reference" href="#mappedtype">%MappedType</a></li>
<li><a class="reference" href="#methodcode">%MethodCode</a></li>
<li><a class="reference" href="#modulecode">%ModuleCode</a></li>
<li><a class="reference" href="#moduleheadercode">%ModuleHeaderCode</a></li>
<li><tt class="literal"><span class="pre">namespace</span></tt></li>
<li><tt class="literal"><span class="pre">struct</span></tt></li>
<li><tt class="literal"><span class="pre">typedef</span></tt></li>
<li><a class="reference" href="#typecode">%TypeCode</a></li>
<li><a class="reference" href="#typeheadercode">%TypeHeaderCode</a></li>
<li>variables</li>
<li><a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a></li>
</ul>
</blockquote>
<p>Also note that the only way to specify the logical and of qualifiers is to use
nested <a class="reference" href="#if">%If</a> directives.</p>
</div>
<div class="section" id="import">
<h2><a class="toc-backref" href="#id64" name="import">6.12   %Import</a></h2>
<pre class="literal-block">
%Import <em>filename</em>
</pre>
<p>This directive is used to import the specification of another module.  This is
needed if the current module makes use of any types defined in the imported
module, e.g. as an argument to a function, or to sub-class.</p>
<p>If <em>filename</em> cannot be opened then SIP prepends <em>filename</em> with the name of
the directory containing the current specification file (i.e. the one
containing the <a class="reference" href="#import">%Import</a> directive) and tries again.  If this also fails then
SIP prepends <em>filename</em> with each of the directories, in turn, specified by
the <tt class="literal"><span class="pre">-I</span></tt> command line option.</p>
<p>For example:</p>
<pre class="literal-block">
%Import qt/qtmod.sip
</pre>
</div>
<div class="section" id="include">
<h2><a class="toc-backref" href="#id65" name="include">6.13   %Include</a></h2>
<pre class="literal-block">
%Include <em>filename</em>
</pre>
<p>This directive is used to include contents of another file as part of the
specification of the current module.  It is the equivalent of the C
preprocessor's <tt class="literal"><span class="pre">#include</span></tt> directive and is used to structure a large module
specification into manageable pieces.</p>
<p><a class="reference" href="#include">%Include</a> follows the same search process as <a class="reference" href="#import">%Import</a> when trying to open
<em>filename</em>.</p>
<p>For example:</p>
<pre class="literal-block">
%Include qwidget.sip
</pre>
</div>
<div class="section" id="id16">
<h2><a class="toc-backref" href="#id66" name="id16">6.14   %License</a></h2>
<pre class="literal-block">
%License /<em>license-annotations</em>/
</pre>
<p>This directive is used to specify the contents of an optional license
dictionary.  The license dictionary is called <tt class="literal"><span class="pre">__license__</span></tt> and is stored in
the module dictionary.  The elements of the dictionary are specified using the
<a class="reference" href="#licensee">Licensee</a>, <a class="reference" href="#signature">Signature</a>, <a class="reference" href="#timestamp">Timestamp</a> and <a class="reference" href="#type">Type</a> annotations.  Only the <a class="reference" href="#type">Type</a>
annotation is compulsory.</p>
<p>Note that this directive isn't an attempt to impose any licensing restrictions
on a module.  It is simply a method for easily embedding licensing information
in a module so that it is accessible to Python scripts.</p>
<p>For example:</p>
<pre class="literal-block">
%License /Type=&quot;GPL&quot;/
</pre>
</div>
<div class="section" id="mappedtype">
<h2><a class="toc-backref" href="#id67" name="mappedtype">6.15   %MappedType</a></h2>
<pre class="literal-block">
%MappedType <em>type</em>
{
    [<em>header-code</em>]
    [<em>convert-to-code</em>]
    [<em>convert-from-code</em>]
}
</pre>
<p>This directive is used to define an automatic mapping between a C or C++ type
and a Python type.  The C/C++ <em>type</em> being mapped must be either a structure,
a class, or a template.  Mapped types are the only way SIP supports templates.</p>
<p><em>header-code</em> is the <a class="reference" href="#typeheadercode">%TypeHeaderCode</a> used to specify the library interface
to the type being mapped.</p>
<p><em>convert-to-code</em> is the <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> used to specify the handwritten
code that converts a Python object to an instance of the mapped type.</p>
<p><em>convert-from-code</em> is the <a class="reference" href="#convertfromtypecode">%ConvertFromTypeCode</a> used to specify the
handwritten code that converts an instance of the mapped type to a Python
object.</p>
<p>For example:</p>
<pre class="literal-block">
%MappedType QValueList&lt;int&gt;
{
%TypeHeaderCode
// Include the library interface to the type being mapped.
#include &lt;qvaluelist.h&gt;
%End

%ConvertToTypeCode
    // See the %ConvertToTypeCode example for the code that converts a
    // Python list of numbers to a QValueList&lt;int&gt; instance.
%End

%ConvertFromTypeCode
    // See the %ConvertFromTypeCode example for the code that converts a
    // QValueList&lt;int&gt; instance to a Python list of numbers.
%End
}
</pre>
<p>In this example we can use <tt class="literal"><span class="pre">QValueList&lt;int&gt;</span></tt> throughout the module's
specification files (and in any module that imports this one).  The generated
code will automatically map this to and from a Python list of numbers when
appropriate.</p>
</div>
<div class="section" id="methodcode">
<h2><a class="toc-backref" href="#id68" name="methodcode">6.16   %MethodCode</a></h2>
<pre class="literal-block">
%MethodCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the specification of a global function, class
method, operator, constructor or destructor to specify handwritten code that
replaces the normally generated call to the function being wrapped.  It is
usually used to handle argument types and results that SIP cannot deal with
automatically.</p>
<p>The specified code is embedded in-line after the function's arguments have
been successfully converted from Python objects to their C or C++ equivalents.
The specified code must not include any <tt class="literal"><span class="pre">return</span></tt> statements.</p>
<p>The the context of a destructor the specified code is embedded in-line in the
Python type's deallocation function.</p>
<p>The specified code must also handle the Python Global Interpreter Lock (GIL).
If compatibility with <a class="reference" href="#sip-v3-x">SIP v3.x</a> is required then the GIL must be released
immediately before the C++ call and reacquired immediately afterwards as shown
in this example fragment:</p>
<pre class="literal-block">
Py_BEGIN_ALLOW_THREADS
sipCpp -&gt; foo();
Py_END_ALLOW_THREADS
</pre>
<p>If compatibility with <a class="reference" href="#sip-v3-x">SIP v3.x</a> is not required then this is optional but
should be done if the C++ function might block the current thread or take a
significant amount of time to execute.  (See the <a class="reference" href="#releasegil">ReleaseGIL</a> annotation.)</p>
<p>The following variables are made available to the handwritten code:</p>
<dl>
<dt><em>type</em> a0</dt>
<dd><p class="first">There is a variable for each argument of the Python signature (excluding
any <tt class="literal"><span class="pre">self</span></tt> argument) named <tt class="literal"><span class="pre">a0</span></tt>, <tt class="literal"><span class="pre">a1</span></tt>, etc.  The <em>type</em> of the
variable is the same as the type defined in the specification with the
following exceptions:</p>
<ul class="simple">
<li>if the argument is only used to return a value (e.g. it is an <tt class="literal"><span class="pre">int</span> <span class="pre">*</span></tt>
without an <a class="reference" href="#in">In</a> annotation) then the type has one less level of
indirection (e.g. it will be an <tt class="literal"><span class="pre">int</span></tt>)</li>
<li>if the argument is a structure or class (or a reference or a pointer to a
structure or class) then <em>type</em> will always be a pointer to the structure
or class.</li>
</ul>
<p class="last">Note that handwritten code for destructors never has any arguments.</p>
</dd>
<dt>PyObject *a0Wrapper</dt>
<dd>This variable is made available only if the corresponding argument wraps a
C structure or C++ class instance and the <a class="reference" href="#getwrapper">GetWrapper</a> annotation is
specified.  The variable is a pointer to the Python object that wraps the
argument.</dd>
<dt><em>type</em> *sipCpp</dt>
<dd>If the directive is used in the context of a class constructor then this
must be set by the handwritten code to the constructed instance.  In any
other class context then this is a pointer to the class instance.  Its
<em>type</em> is a pointer to the structure or class.</dd>
<dt>int sipIsErr</dt>
<dd><p class="first">The handwritten code should set this to a non-zero value, and raise an
appropriate Python exception, if an error is detected.</p>
<p class="last"><tt class="literal"><span class="pre">sipIsErr</span></tt> is not provided for destructors.</p>
</dd>
<dt><em>type</em> sipRes</dt>
<dd><p class="first">The handwritten code should set this to the result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the Python
signature in the specification with the following exception:</p>
<ul class="simple">
<li>if the argument is a structure or class (or a reference or a pointer to a
structure or class) then <em>type</em> will always be a pointer to the structure
or class.</li>
</ul>
<p class="last"><tt class="literal"><span class="pre">sipRes</span></tt> is not provided for inplace operators (e.g. <tt class="literal"><span class="pre">+=</span></tt> or
<tt class="literal"><span class="pre">__imul__</span></tt>) as their results are handled automatically, nor for class
constructors.</p>
</dd>
<dt>PyObject *sipSelf</dt>
<dd>If the directive is used in the context of a class method then this is the
Python object that wraps the the structure or class instance,
i.e. <tt class="literal"><span class="pre">self</span></tt>.</dd>
</dl>
<p>For example:</p>
<pre class="literal-block">
class Klass
{
public:
    int foo(SIP_PYTUPLE);
%MethodCode
        // The C++ API takes a 2 element array of integers but passing a
        // two element tuple is more Pythonic.

        int iarr[2];

        if (PyArg_ParseTuple(a0, &quot;ii&quot;, &amp;iarr[0], &amp;iarr[1]))
        {
            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp -&gt; Klass::foo(iarr);
            Py_END_ALLOW_THREADS
        }
        else
        {
            // PyArg_ParseTuple() will have raised the exception.
            sipIsErr = 1;
        }
%End
};
</pre>
<p>Note the use of the fully scoped method name in the example (i.e.
<tt class="literal"><span class="pre">Klass::foo()</span></tt> rather than just <tt class="literal"><span class="pre">foo()</span></tt>).  This is required for virtual
methods <a class="footnote-reference" href="#id18" id="id17" name="id17"><sup>8</sup></a> in order to avoid virtual call loops, but is a good habit to get
into for all public methods.</p>
<p>If a method is in the <tt class="literal"><span class="pre">protected</span></tt> section of a C++ class then the call
should instead be:</p>
<pre class="literal-block">
sipRes = sipCpp -&gt; sipProtect_foo(iarr);
</pre>
<table class="footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17" name="id18">[8]</a></td><td>See <a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a> for a description of how SIP generated code
handles the reimplementation of C++ virtual methods in Python.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="module">
<h2><a class="toc-backref" href="#id69" name="module">6.17   %Module</a></h2>
<pre class="literal-block">
%Module <em>name</em> [<em>version</em>]
</pre>
<p>This directive is used to identify that the library being wrapped is a C++
library and to define the name of the module and it's optional version number.</p>
<p>The optional version number is useful if you (or others) might create other
modules that build on this module, i.e. if another module might <a class="reference" href="#import">%Import</a>
this module.  Under the covers, a module exports an API that is used by modules
that <a class="reference" href="#import">%Import</a> it and the API is given a version number.  A module built on
that module knows the version number of the API that it is expecting.  If,
when the modules are imported at run-time, the version numbers do not match
then a Python exception is raised.  The dependent module must then be re-built
using the correct specification files for the base module.</p>
<p>The version number should be incremented whenever a module is changed.  Some
changes don't affect the exported API, but it is good practice to change the
version number anyway.</p>
<p>For example:</p>
<pre class="literal-block">
%Module qt 5
</pre>
</div>
<div class="section" id="modulecode">
<h2><a class="toc-backref" href="#id70" name="modulecode">6.18   %ModuleCode</a></h2>
<pre class="literal-block">
%ModuleCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code, typically the
implementations of utility functions, that can be called by other handwritten
code in the module.</p>
<p>For example:</p>
<pre class="literal-block">
%ModuleCode
// Print an object on stderr for debugging purposes.
void dump_object(PyObject *o)
{
    PyObject_Print(o, stderr, 0);
    fprintf(stderr, &quot;\n&quot;);
}
%End
</pre>
<p>See also <a class="reference" href="#moduleheadercode">%ModuleHeaderCode</a>.</p>
</div>
<div class="section" id="moduleheadercode">
<h2><a class="toc-backref" href="#id71" name="moduleheadercode">6.19   %ModuleHeaderCode</a></h2>
<pre class="literal-block">
%ModuleHeaderCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code, typically the declarations
of utility functions, that is placed in a header file that is included by all
generated code.</p>
<p>For example:</p>
<pre class="literal-block">
%ModuleHeaderCode
void dump_object(PyObject *o);
%End
</pre>
<p>See also <a class="reference" href="#modulecode">%ModuleCode</a>.</p>
</div>
<div class="section" id="optionalinclude">
<h2><a class="toc-backref" href="#id72" name="optionalinclude">6.20   %OptionalInclude</a></h2>
<pre class="literal-block">
%OptionalInclude <em>filename</em>
</pre>
<p>This directive is identical to the <a class="reference" href="#include">%Include</a> directive except that SIP
silently continues processing if <em>filename</em> could not be opened.</p>
<p>For example:</p>
<pre class="literal-block">
%OptionalInclude license.sip
</pre>
</div>
<div class="section" id="platforms">
<h2><a class="toc-backref" href="#id73" name="platforms">6.21   %Platforms</a></h2>
<pre class="literal-block">
%Platforms {<em>name</em> <em>name</em> ...}
</pre>
<p>This directive is used to declare a set of platforms.  Platforms (along with
<a class="reference" href="#feature">%Feature</a> and <a class="reference" href="#timeline">%Timeline</a>) are used by the <a class="reference" href="#if">%If</a> directive to control
whether or not parts of a specification are processed or ignored.</p>
<p>Platforms are mutually exclusive - only one platform can be enabled at a time.
By default all platforms are disabled.  The SIP <tt class="literal"><span class="pre">-t</span></tt> command line option is
used to enable a platform.</p>
<p>For example:</p>
<pre class="literal-block">
%Platforms {WIN32_PLATFORM POSIX_PLATFORM MACOS_PLATFORM}

%If (WIN32_PLATFORM)
void undocumented();
%End

%If (POSIX_PLATFORM)
void documented();
%End
</pre>
</div>
<div class="section" id="postinitialisationcode">
<h2><a class="toc-backref" href="#id74" name="postinitialisationcode">6.22   %PostInitialisationCode</a></h2>
<pre class="literal-block">
%PostInitialisationCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
at the very end of the generated module initialisation code.</p>
<p>For example:</p>
<pre class="literal-block">
%PostInitialisationCode
    // The code will be executed when the module is first imported and
    // after all other initialisation has been completed.
%End
</pre>
</div>
<div class="section" id="timeline">
<h2><a class="toc-backref" href="#id75" name="timeline">6.23   %Timeline</a></h2>
<pre class="literal-block">
%Timeline {<em>name</em> <em>name</em> ...}
</pre>
<p>This directive is used to declare a set of versions released over a period of
time.  Versions (along with <a class="reference" href="#feature">%Feature</a> and <a class="reference" href="#platforms">%Platforms</a>) are used by the
<a class="reference" href="#if">%If</a> directive to control whether or not parts of a specification are
processed or ignored.</p>
<p>Versions are mutually exclusive - only one version can be enabled at a time.
By default all versions are disabled.  The SIP <tt class="literal"><span class="pre">-t</span></tt> command line option is
used to enable a version.</p>
<p>For example:</p>
<pre class="literal-block">
%Timeline {V1_0 V1_1 V2_0 V3_0}

%If (V1_0 - V2_0)
void foo();
%End

%If (V2_0 -)
void foo(int = 0);
%End
</pre>
</div>
<div class="section" id="typecode">
<h2><a class="toc-backref" href="#id76" name="typecode">6.24   %TypeCode</a></h2>
<pre class="literal-block">
%TypeCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the specification of a C structure or a C++
class to specify handwritten code, typically the implementations of utility
functions, that can be called by other handwritten code in the structure or
class.</p>
<p>For example:</p>
<pre class="literal-block">
class Klass
{
%TypeCode
// Print an instance on stderr for debugging purposes.
static void dump_klass(const Klass *k)
{
    fprintf(stderr,&quot;Klass %s at %p\n&quot;, k -&gt; name(), k);
}
%End

    // The rest of the class specification.

};
</pre>
<p>Because the scope of the code is normally within the generated file that
implements the type, any utility functions would normally be declared
<tt class="literal"><span class="pre">static</span></tt>.  However a naming convention should still be adopted to prevent
clashes of function names within a module in case the SIP <tt class="literal"><span class="pre">-j</span></tt> command line
option is used.</p>
</div>
<div class="section" id="typeheadercode">
<h2><a class="toc-backref" href="#id77" name="typeheadercode">6.25   %TypeHeaderCode</a></h2>
<pre class="literal-block">
%TypeHeaderCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that defines the interface
to a C or C++ type being wrapped, either a structure, a class, or a template.
It is used within a class definition or a <a class="reference" href="#mappedtype">%MappedType</a> directive.</p>
<p>Normally <em>code</em> will be a pre-processor <tt class="literal"><span class="pre">#include</span></tt> statement.</p>
<p>For example:</p>
<pre class="literal-block">
// Wrap the Klass class.
class Klass
{
%TypeHeaderCode
#include &lt;klass.h&gt;
%End

    // The rest of the class specification.
};
</pre>
</div>
<div class="section" id="virtualcatchercode">
<h2><a class="toc-backref" href="#id78" name="virtualcatchercode">6.26   %VirtualCatcherCode</a></h2>
<pre class="literal-block">
%VirtualCatcherCode
    <em>code</em>
%End
</pre>
<p>For most classes there are corresponding <a class="reference" href="#generated-derived-classes">generated derived classes</a> that
contain reimplementations of the class's virtual methods.  These methods (which
SIP calls catchers) determine if there is a corresponding Python
reimplementation and call it if so.  If there is no Python reimplementation
then the method in the original class is called instead.</p>
<p>This directive is used to specify handwritten code that replaces the normally
generated call to the Python reimplementation and the handling of any returned
results.  It is usually used to handle argument types and results that SIP
cannot deal with automatically.</p>
<p>This directive can also be used in the context of a class destructor to
specify handwritten code that is embedded in-line in the internal derived
class's destructor.</p>
<p>In the context of a method the Python Global Interpreter Lock (GIL) is
automatically acquired before the specified code is executed and automatically
released afterwards.</p>
<p>In the context of a destructor the specified code must handle the GIL.  The
GIL must be acquired before any calls to the Python API and released after the
last call as shown in this example fragment:</p>
<pre class="literal-block">
SIP_BLOCK_THREADS
Py_DECREF(obj);
SIP_UNBLOCK_THREADS
</pre>
<p>The following variables are made available to the handwritten code in the
context of a method:</p>
<dl>
<dt><em>type</em> a0</dt>
<dd>There is a variable for each argument of the C++ signature named <tt class="literal"><span class="pre">a0</span></tt>,
<tt class="literal"><span class="pre">a1</span></tt>, etc.  The <em>type</em> of the variable is the same as the type defined in
the specification.</dd>
<dt>int sipIsErr</dt>
<dd>The handwritten code should set this to a non-zero value, and raise an
appropriate Python exception, if an error is detected.</dd>
<dt>PyObject *sipMethod</dt>
<dd>This object is the Python reimplementation of the virtual C++ method.  It
is normally passed to <a class="reference" href="#sipcallmethod">sipCallMethod()</a>.</dd>
<dt><em>type</em> sipRes</dt>
<dd>The handwritten code should set this to the result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the C++ signature
in the specification.</dd>
</dl>
<p>No variables are made available in the context of a destructor.</p>
<p>For example:</p>
<pre class="literal-block">
class Klass
{
public:
    virtual int foo(SIP_PYTUPLE) [int (int *)];
%MethodCode
        // The C++ API takes a 2 element array of integers but passing a
        // two element tuple is more Pythonic.

        int iarr[2];

        if (PyArg_ParseTuple(a0, &quot;ii&quot;, &amp;iarr[0], &amp;iarr[1]))
        {
            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp -&gt; Klass::foo(iarr);
            Py_END_ALLOW_THREADS
        }
        else
        {
            // PyArg_ParseTuple() will have raised the exception.
            sipIsErr = 1;
        }
%End
%VirtualCatcherCode
        // Convert the 2 element array of integers to the two element
        // tuple.

        PyObject *itup;

        if ((itup = Py_BuildValue(&quot;ii&quot;, a0[0], a0[1])) != NULL)
        {
            // Call the Python method and get the result object.
            PyObject *result = sipCallMethod(&amp;sipIsErr, &quot;R&quot;, itup);

            if (result != NULL)
            {
                // Convert the result to the C++ type.
                sipParseResult(&amp;sipIsErr, &quot;i&quot;, &amp;sipRes);

                Py_DECREF(result);
            }

            Py_DECREF(itup);
        }
        else
        {
            // Py_BuildValue() will have raised the exception.
            sipIsErr = 1;
        }
%End
};
</pre>
</div>
</div>
<div class="section" id="sip-annotations">
<h1><a class="toc-backref" href="#id79" name="sip-annotations">7   SIP Annotations</a></h1>
<p>In this section we describe each of the annotations that can be used in
specification files.</p>
<p>Annotations can either be argument annotations, function annotations, or
license annotations depending on the context in which they can be used.</p>
<p>Annotations are placed between forward slashes (<tt class="literal"><span class="pre">/</span></tt>).  Multiple annotations
are comma separated within the slashes.</p>
<p>Annotations have a type and, possibly, a value.  The type determines the
format of the value.  The name of an annotation and its value are separated by
<tt class="literal"><span class="pre">=</span></tt>.</p>
<p>Annotations can have one of the following types:</p>
<dl>
<dt>boolean</dt>
<dd>This type of annotation has no value and is implicitly true.</dd>
<dt>name</dt>
<dd>The value is a name that is compatible with a C/C++ identifier.  In some
cases the value is optional.</dd>
<dt>string</dt>
<dd>The value is a double quoted string.</dd>
</dl>
<p>The following example shows argument and function annotations:</p>
<pre class="literal-block">
void exec(QWidget * /Transfer/) /ReleaseGIL, PyName=call_exec/;
</pre>
<p>Note that the current version of SIP does not complain about unknown
annotations, or annotations used out of their correct context.</p>
<div class="section" id="argument-annotations">
<h2><a class="toc-backref" href="#id80" name="argument-annotations">7.1   Argument Annotations</a></h2>
<div class="section" id="allownone">
<h3><a class="toc-backref" href="#id81" name="allownone">7.1.1   AllowNone</a></h3>
<p>This boolean annotation specifies that the value of the corresponding argument
(which should be either <a class="reference" href="#sip-pydict">SIP_PYDICT</a>, <a class="reference" href="#sip-pylist">SIP_PYLIST</a>, <a class="reference" href="#sip-pyslice">SIP_PYSLICE</a> or <a class="reference" href="#sip-pytuple">SIP_PYTUPLE</a>)
may be <tt class="literal"><span class="pre">None</span></tt>.</p>
</div>
<div class="section" id="array">
<h3><a class="toc-backref" href="#id82" name="array">7.1.2   Array</a></h3>
<p>This boolean annotation specifies that the corresponding argument (which
should be either <tt class="literal"><span class="pre">char</span> <span class="pre">*</span></tt> or <tt class="literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span></tt>) refers to an array
rather than a <tt class="literal"><span class="pre">'\0'</span></tt> terminated string.  There must be a corresponding
argument with the <a class="reference" href="#arraysize">ArraySize</a> annotation specified.  The annotation may only be
specified once in a list of arguments.</p>
</div>
<div class="section" id="arraysize">
<h3><a class="toc-backref" href="#id83" name="arraysize">7.1.3   ArraySize</a></h3>
<p>This boolean annotation specifies that the corresponding argument (which
should be either <tt class="literal"><span class="pre">short</span></tt>, <tt class="literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt>, <tt class="literal"><span class="pre">int</span></tt>, <tt class="literal"><span class="pre">unsigned</span></tt>,
<tt class="literal"><span class="pre">long</span></tt> or <tt class="literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt>) refers to the size of an array.  There must be
a corresponding argument with the <a class="reference" href="#array">Array</a> annotation specified.  The annotation
may only be specified once in a list of arguments.</p>
</div>
<div class="section" id="constrained">
<h3><a class="toc-backref" href="#id84" name="constrained">7.1.4   Constrained</a></h3>
<p>Python will automatically convert between certain compatible types.  For
example, if a floating pointer number is expected and an integer supplied,
then the integer will be converted appropriately.  This can cause problems
when wrapping C or C++ functions with similar signatures.  For example:</p>
<pre class="literal-block">
// The wrapper for this function will also accept an integer argument
// which Python will automatically convert to a floating point number.
void foo(double);

// The wrapper for this function will never get used.
void foo(int);
</pre>
<p>This boolean annotation specifies that the corresponding argument (which
should be either <tt class="literal"><span class="pre">int</span></tt>, <tt class="literal"><span class="pre">float</span></tt> or <tt class="literal"><span class="pre">double</span></tt>) must match the type without
any automatic conversions.  The following example gets around the above
problem:</p>
<pre class="literal-block">
// The wrapper for this function will only accept floating point numbers.
void foo(double /Constrained/);

// The wrapper for this function will be used for anything that Python can
// convert to an integer, except for floating point numbers.
void foo(int);
</pre>
</div>
<div class="section" id="getwrapper">
<h3><a class="toc-backref" href="#id85" name="getwrapper">7.1.5   GetWrapper</a></h3>
<p>This boolean annotation is only ever used in conjunction with handwritten code
specified with the <a class="reference" href="#methodcode">%MethodCode</a> directive.  It causes an extra variable to
be generated for the corresponding argument (which should be a wrapped C
structure or C++ class instance) which is a pointer to the Python object that
wraps the argument.</p>
<p>See the <a class="reference" href="#methodcode">%MethodCode</a> directive for more detail.</p>
</div>
<div class="section" id="in">
<h3><a class="toc-backref" href="#id86" name="in">7.1.6   In</a></h3>
<p>This boolean annotation is used to specify that the corresponding argument
(which should be a pointer type) is used to pass a value to the function.</p>
<p>For pointers to wrapped C structures or C++ class instances, <tt class="literal"><span class="pre">char</span> <span class="pre">*</span></tt> and
<tt class="literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span></tt> then this annotation is assumed unless the <a class="reference" href="#out">Out</a> annotation
is specified.</p>
<p>For pointers to other types then this annotation must be explicitly specified
if required.  The argument will be dereferenced to obtain the actual value.</p>
<p>Both <a class="reference" href="#in">In</a> and <a class="reference" href="#out">Out</a> may be specified for the same argument.</p>
</div>
<div class="section" id="out">
<h3><a class="toc-backref" href="#id87" name="out">7.1.7   Out</a></h3>
<p>This boolean annotation is used to specify that the corresponding argument
(which should be a pointer type) is used by the function to return a value as
an element of a tuple.</p>
<p>For pointers to wrapped C structures or C++ class instances, <tt class="literal"><span class="pre">char</span> <span class="pre">*</span></tt> and
<tt class="literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span></tt> then this annotation must be explicitly specified if
required.</p>
<p>For pointers to other types then this annotation is assumed unless the <a class="reference" href="#in">In</a>
annotation is specified.</p>
<p>Both <a class="reference" href="#in">In</a> and <a class="reference" href="#out">Out</a> may be specified for the same argument.</p>
</div>
<div class="section" id="transfer">
<h3><a class="toc-backref" href="#id88" name="transfer">7.1.8   Transfer</a></h3>
<p>This boolean annotation is used to specify that ownership of the corresponding
argument (which should be a wrapped C structure or C++ class instance) is
transferred from Python to C++.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
<div class="section" id="transferback">
<h3><a class="toc-backref" href="#id89" name="transferback">7.1.9   TransferBack</a></h3>
<p>This boolean annotation is used to specify that ownership of the corresponding
argument (which should be a wrapped C structure or C++ class instance) is
transferred back to Python from C++.</p>
<p>Note that this can also be used as a function annotation.  In this context
ownership of the value returned by the function is transferred back to Python.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
<div class="section" id="transferthis">
<h3><a class="toc-backref" href="#id90" name="transferthis">7.1.10   TransferThis</a></h3>
<p>This boolean annotation is only used in C++ constructors.  It specifies that
ownership of the instance being constructed is transferred from Python to C++
if the corresponding argument (which should be a wrapped C structure or C++
class instance) is not <tt class="literal"><span class="pre">None</span></tt>.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
</div>
<div class="section" id="function-annotations">
<h2><a class="toc-backref" href="#id91" name="function-annotations">7.2   Function Annotations</a></h2>
<div class="section" id="autogen">
<h3><a class="toc-backref" href="#id92" name="autogen">7.2.1   AutoGen</a></h3>
<p>This optional name annotation is used with class methods to specify that the
method be automatically included in all sub-classes.  The value is the name of
a feature (specified using the <a class="reference" href="#feature">%Feature</a> directive) which must be enabled
for the method to be generated.</p>
</div>
<div class="section" id="default">
<h3><a class="toc-backref" href="#id93" name="default">7.2.2   Default</a></h3>
<p>This boolean annotation is only used with C++ constructors.  Sometimes SIP
needs to create a class instance.  By default it uses a constructor with no
compulsory arguments if one is specified.  (SIP will automatically generate a
constructor with no arguments if no constructors are specified.)  This
annotation is used to explicitly specify which constructor to use.  Zero is
passed as the value of any arguments to the constructor.</p>
</div>
<div class="section" id="factory">
<h3><a class="toc-backref" href="#id94" name="factory">7.2.3   Factory</a></h3>
<p>This boolean annotation specifies that the value returned by the function
(which should be a wrapped C structure or C++ class instance) is owned by
Python (see <a class="reference" href="#ownership-of-objects">Ownership of Objects</a>).  Normally returned values (unless they
are new references to already wrapped values) are owned by C++.</p>
</div>
<div class="section" id="newthread">
<h3><a class="toc-backref" href="#id95" name="newthread">7.2.4   NewThread</a></h3>
<p>This boolean annotation specifies that the function will create a new thread.</p>
</div>
<div class="section" id="posthook">
<h3><a class="toc-backref" href="#id96" name="posthook">7.2.5   PostHook</a></h3>
<p>This name annotation is used to specify the name of a Python builtin that is
called immediately after call to the underlying C or C++ function or any
handwritten code.  The builtin is not called if an error occurred.  It is
primarily used to integrate with debuggers.</p>
</div>
<div class="section" id="prehook">
<h3><a class="toc-backref" href="#id97" name="prehook">7.2.6   PreHook</a></h3>
<p>This name annotation is used to specify the name of a Python builtin that is
called immediately after the function's arguments have been successfully
parsed and before the call to the underlying C or C++ function or any
handwritten code.  It is primarily used to integrate with debuggers.</p>
</div>
<div class="section" id="pyname">
<h3><a class="toc-backref" href="#id98" name="pyname">7.2.7   PyName</a></h3>
<p>Python keywords cannot be used as Python function or method names.  This name
annotation specifies an alternative name for the function being wrapped which
is used when calling the function from Python.</p>
</div>
<div class="section" id="releasegil">
<h3><a class="toc-backref" href="#id99" name="releasegil">7.2.8   ReleaseGIL</a></h3>
<p>This boolean annotation specifies that the Python Global Interpreter Lock
(GIL) is automatically released before the call to the underlying C or C++
function and reacquired afterwards.  It should be used for functions that
might block or take a significant amount of time to execute.</p>
</div>
</div>
<div class="section" id="license-annotations">
<h2><a class="toc-backref" href="#id100" name="license-annotations">7.3   License Annotations</a></h2>
<div class="section" id="licensee">
<h3><a class="toc-backref" href="#id101" name="licensee">7.3.1   Licensee</a></h3>
<p>This optional string annotation specifies the license's licensee.  No
restrictions are placed on the contents of the string.</p>
<p>See the <a class="reference" href="#id16">%License</a> directive.</p>
</div>
<div class="section" id="signature">
<h3><a class="toc-backref" href="#id102" name="signature">7.3.2   Signature</a></h3>
<p>This optional string annotation specifies the license's signature.  No
restrictions are placed on the contents of the string.</p>
<p>See the <a class="reference" href="#id16">%License</a> directive.</p>
</div>
<div class="section" id="timestamp">
<h3><a class="toc-backref" href="#id103" name="timestamp">7.3.3   Timestamp</a></h3>
<p>This optional string annotation specifies the license's timestamp.  No
restrictions are placed on the contents of the string.</p>
<p>See the <a class="reference" href="#id16">%License</a> directive.</p>
</div>
<div class="section" id="type">
<h3><a class="toc-backref" href="#id104" name="type">7.3.4   Type</a></h3>
<p>This string annotation specifies the license's type.  No restrictions are
placed on the contents of the string.</p>
<p>See the <a class="reference" href="#id16">%License</a> directive.</p>
</div>
</div>
</div>
<div class="section" id="sip-api-for-handwritten-code">
<h1><a class="toc-backref" href="#id105" name="sip-api-for-handwritten-code">8   SIP API for Handwritten Code</a></h1>
<p>In this section we describe the API that can be used by handwritten code in
specification files.</p>
<div class="section" id="sip-api-major-nr">
<h2><a class="toc-backref" href="#id106" name="sip-api-major-nr">8.1   SIP_API_MAJOR_NR</a></h2>
<p>This is a C preprocessor symbol that defines the major number of the SIP API.
Its value is a number.  There is no direct relationship between this and the
SIP version number.</p>
</div>
<div class="section" id="sip-api-minor-nr">
<h2><a class="toc-backref" href="#id107" name="sip-api-minor-nr">8.2   SIP_API_MINOR_NR</a></h2>
<p>This is a C preprocessor symbol that defines the minor number of the SIP API.
Its value is a number.  There is no direct relationship between this and the
SIP version number.</p>
</div>
<div class="section" id="sip-build">
<h2><a class="toc-backref" href="#id108" name="sip-build">8.3   SIP_BUILD</a></h2>
<p>This is a C preprocessor symbol that defines a unique SIP build identifier
represented as a string.</p>
</div>
<div class="section" id="sip-version">
<h2><a class="toc-backref" href="#id109" name="sip-version">8.4   SIP_VERSION</a></h2>
<p>This is a C preprocessor symbol that defines the SIP version number
represented as a 3 part hexadecimal number (e.g. v4.0.0 is represented as
<tt class="literal"><span class="pre">0x040000</span></tt>).</p>
</div>
<div class="section" id="sip-version-str">
<h2><a class="toc-backref" href="#id110" name="sip-version-str">8.5   SIP_VERSION_STR</a></h2>
<p>This is a C preprocessor symbol that defines the SIP version number
represented as a string.  For development snapshots it will start with
<tt class="literal"><span class="pre">snapshot-</span></tt>.</p>
</div>
<div class="section" id="sipbadcatcherresult">
<h2><a class="toc-backref" href="#id111" name="sipbadcatcherresult">8.6   sipBadCatcherResult()</a></h2>
<dl>
<dt>void sipBadCatcherResult(PyObject *method)</dt>
<dd>This is raises a Python exception when the result of a Python
reimplementation of a C++ method doesn't have the expected type.  It is
normally called by handwritten code specified with the
<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a> directive.  <em>method</em> is the Python method and would
normally be the supplied <tt class="literal"><span class="pre">sipMethod</span></tt>.</dd>
</dl>
</div>
<div class="section" id="sipbadlengthforslice">
<h2><a class="toc-backref" href="#id112" name="sipbadlengthforslice">8.7   sipBadLengthForSlice()</a></h2>
<dl>
<dt>void sipBadLengthForSlice(int seqlen, int slicelen)</dt>
<dd>This raises a Python exception when the length of a slice object is
inappropriate for a sequence-like object.  It is normally called by
handwritten code specified for <tt class="literal"><span class="pre">__setitem__()</span></tt> methods.  <em>seqlen</em> is the
length of the sequence.  <em>slicelen</em> is the length of the slice.</dd>
</dl>
</div>
<div class="section" id="sipbuildresult">
<h2><a class="toc-backref" href="#id113" name="sipbuildresult">8.8   sipBuildResult()</a></h2>
<dl>
<dt>PyObject *sipBuildResult(int *iserr, char *format, ...)</dt>
<dd><p class="first">This creates a Python object based on a format string and associated
values in a similar way to the Python <tt class="literal"><span class="pre">Py_BuildValue()</span></tt> function.  If
there was an error then <tt class="literal"><span class="pre">NULL</span></tt> is returned and a Python exception is
raised.  If <em>iserr</em> is not <tt class="literal"><span class="pre">NULL</span></tt> then the location it points to is set
to a non-zero value.  <em>format</em> is the string of format characters.</p>
<p>If <em>format</em> begins and ends with parentheses then a tuple of objects is
created.  If <em>format</em> contains more than one format character then
parentheses must be specified.</p>
<p>In the following description the first letter is the format character, the
entry in parentheses is the Python object type that the format character
will create, and the entry in brackets are the types of the C/C++ values
to be passed.</p>
<dl class="last">
<dt><tt class="literal"><span class="pre">a</span></tt> (string) [char *, int]</dt>
<dd>Convert a C/C++ character array and its length to a Python string.  If
the character array is <tt class="literal"><span class="pre">NULL</span></tt> then the length is ignored and the
result is <tt class="literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">b</span></tt> (boolean) [int]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">int</span></tt> to a Python boolean.</dd>
<dt><tt class="literal"><span class="pre">c</span></tt> (string) [char]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">char</span></tt> to a Python string.</dd>
<dt><tt class="literal"><span class="pre">d</span></tt> (float) [double]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">double</span></tt> to a Python floating point number.</dd>
<dt><tt class="literal"><span class="pre">e</span></tt> (integer) [enum]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">enum</span></tt> to a Python integer.</dd>
<dt><tt class="literal"><span class="pre">f</span></tt> (float) [float]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">float</span></tt> to a Python floating point number.</dd>
<dt><tt class="literal"><span class="pre">h</span></tt> (integer) [short]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">short</span></tt> to a Python integer.</dd>
<dt><tt class="literal"><span class="pre">i</span></tt> (integer) [int]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">int</span></tt> to a Python integer.</dd>
<dt><tt class="literal"><span class="pre">l</span></tt> (integer) [long]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">long</span></tt> to a Python integer.</dd>
<dt><tt class="literal"><span class="pre">s</span></tt> (string) [char *]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">'\0'</span></tt> terminated string to a Python string.  If the
string pointer is <tt class="literal"><span class="pre">NULL</span></tt> then the result is <tt class="literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">M</span></tt> (wrapped instance) [<em>type</em> *, sipWrapperType *]</dt>
<dd>Convert a C structure or a C++ class instance to a Python class
instance object.  If the structure or class instance has already been
wrapped then the result is a new reference to the existing class
instance object.  The Python class is influenced by any applicable
<a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.</dd>
<dt><tt class="literal"><span class="pre">N</span></tt> (wrapped instance) [<em>type</em> *, sipWrapperType *]</dt>
<dd>Convert a C structure or a C++ class instance to a Python class
instance object.  This should not be used if the structure or class
instance might already have been wrapped.  The Python class is
influenced by any applicable <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.  It is
recommended that handwritten code use the <tt class="literal"><span class="pre">M</span></tt> format character
instead.</dd>
<dt><tt class="literal"><span class="pre">O</span></tt> (wrapped instance) [<em>type</em> *, sipWrapperType *]</dt>
<dd>Convert a C structure or a C++ class instance to a Python class
instance object.  If the structure or class instance has already been
wrapped then the result is a new reference to the existing class
instance object.  It is recommended that handwritten code use the
<tt class="literal"><span class="pre">M</span></tt> format character instead.</dd>
<dt><tt class="literal"><span class="pre">P</span></tt> (wrapped instance) [<em>type</em> *, sipWrapperType *]</dt>
<dd>Convert a C structure or a C++ class instance to a Python class
instance object.  This should not be used if the structure or class
instance might already have been wrapped.  It is recommended that
handwritten code use the <tt class="literal"><span class="pre">M</span></tt> format character instead.</dd>
<dt><tt class="literal"><span class="pre">R</span></tt> (object) [PyObject *]</dt>
<dd>The result is value passed without any conversions.  The reference
count is unaffected, i.e. a reference is taken.</dd>
<dt><tt class="literal"><span class="pre">S</span></tt> (object) [PyObject *]</dt>
<dd>The result is value passed without any conversions.  The reference
count is incremented.</dd>
<dt><tt class="literal"><span class="pre">T</span></tt> (object) [void *, PyObject *(*)(void *cppptr)]</dt>
<dd>Convert a C structure or a C++ class instance to a Python object using
a convertor function.  See <a class="reference" href="#generated-type-convertors">Generated Type Convertors</a>.</dd>
<dt><tt class="literal"><span class="pre">V</span></tt> (sip.voidptr) [void *]</dt>
<dd>Convert a C/C++ <tt class="literal"><span class="pre">void</span> <span class="pre">*</span></tt> Python <tt class="literal"><span class="pre">sip.voidptr</span></tt> object.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="sipcallmethod">
<h2><a class="toc-backref" href="#id114" name="sipcallmethod">8.9   sipCallMethod()</a></h2>
<dl>
<dt>PyObject *sipCallMethod(int *iserr, PyObject *method, char *format, ...)</dt>
<dd><p class="first">This calls a Python method passing a tuple of arguments based on a format
string and associated values in a similar way to the Python
<tt class="literal"><span class="pre">PyObject_CallObject()</span></tt> function.  If there was an error then <tt class="literal"><span class="pre">NULL</span></tt> is
returned and a Python exception is raised.  If <em>iserr</em> is not <tt class="literal"><span class="pre">NULL</span></tt>
then the location it points to is set to a non-zero value.  <em>method</em> is the
Python bound method to call.  <em>format</em> is the string of format characters
(see <a class="reference" href="#sipbuildresult">sipBuildResult()</a>).</p>
<p class="last">This is normally called by handwritten code specified with the
<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a> directive with <em>method</em> being the supplied
<tt class="literal"><span class="pre">sipMethod</span></tt>.</p>
</dd>
</dl>
</div>
<div class="section" id="sipclassname">
<h2><a class="toc-backref" href="#id115" name="sipclassname">8.10   sipClassName()</a></h2>
<dl>
<dt>PyObject *sipClassName(PyObject *obj)</dt>
<dd>This returns the class name of a wrapped instance as a Python string.  It
comes with a reference.</dd>
</dl>
</div>
<div class="section" id="sipconnectrx">
<h2><a class="toc-backref" href="#id116" name="sipconnectrx">8.11   sipConnectRx()</a></h2>
<dl>
<dt>PyObject *sipConnectRx(PyObject *sender, const char *signal, PyObject *receiver, const char *slot)</dt>
<dd><p class="first">This connects a signal to a signal or slot and returns <tt class="literal"><span class="pre">Py_True</span></tt> if the
signal was connected or <tt class="literal"><span class="pre">Py_False</span></tt> if not.  If there was some other
error then a Python exception is raised and <tt class="literal"><span class="pre">NULL</span></tt> is returned.  <em>sender</em>
is the wrapped <tt class="literal"><span class="pre">QObject</span></tt> derived instance that emits the signal.
<em>signal</em> is the typed name of the signal.  <em>receiver</em> is the wrapped
<tt class="literal"><span class="pre">QObject</span></tt> derived instance or Python callable that the signal is
connected to.  <em>slot</em> is the typed name of the slot, or <tt class="literal"><span class="pre">NULL</span></tt> if
<em>receiver</em> is a Python callable.  It is normally only used by PyQt to
implement <tt class="literal"><span class="pre">QObject.connect()</span></tt>.</p>
<p class="last">This is only available if Qt support is enabled.</p>
</dd>
</dl>
</div>
<div class="section" id="sipconvertfromsequenceindex">
<h2><a class="toc-backref" href="#id117" name="sipconvertfromsequenceindex">8.12   sipConvertFromSequenceIndex()</a></h2>
<dl>
<dt>int sipConvertFromSequenceIndex(int idx, int len)</dt>
<dd>This converts a Python sequence index (i.e. where a negative value refers
to the offset from the end of the sequence) to a C/C++ array index.  If the
index was out of range then a negative value is returned and a Python
exception raised.</dd>
</dl>
</div>
<div class="section" id="sipconvertfromsliceobject">
<h2><a class="toc-backref" href="#id118" name="sipconvertfromsliceobject">8.13   sipConvertFromSliceObject()</a></h2>
<dl>
<dt>int sipConvertFromSliceObject(PyObject *slice, int length, int *start, int *stop, int *step, int *slicelength)</dt>
<dd>This is a thin wrapper around the Python <tt class="literal"><span class="pre">PySlice_GetIndicesEx()</span></tt>
function provided to make it easier to write handwritten code that is
compatible with <a class="reference" href="#sip-v3-x">SIP v3.x</a> and versions of Python earlier that v2.3.</dd>
</dl>
</div>
<div class="section" id="sipconverttocpp">
<h2><a class="toc-backref" href="#id119" name="sipconverttocpp">8.14   sipConvertToCpp()</a></h2>
<dl>
<dt>void *sipConvertToCpp(PyObject *obj, sipWrapperType *type, int *iserr)</dt>
<dd>This extracts the pointer to the C structure or C++ class instance from a
wrapped instance object.  <em>obj</em> is the wrapped instance object (if it is
<tt class="literal"><span class="pre">Py_None</span></tt> then <tt class="literal"><span class="pre">NULL</span></tt> is returned).  <em>type</em> is generated type
corresponding to the C/C++ type returned.  It may be any class in the
object's class hierarchy.  If there is an error then the location <em>iserr</em>
points to is set to a non-zero value.</dd>
</dl>
</div>
<div class="section" id="sipdisconnectrx">
<h2><a class="toc-backref" href="#id120" name="sipdisconnectrx">8.15   sipDisconnectRx()</a></h2>
<dl>
<dt>PyObject *sipDisconnectRx(PyObject *sender, const char *signal, PyObject *receiver, const char *slot)</dt>
<dd><p class="first">This disconnects a signal from a signal or slot and returns <tt class="literal"><span class="pre">Py_True</span></tt> if
the signal was disconnected or <tt class="literal"><span class="pre">Py_False</span></tt> if not.  If there was some
other error then a Python exception is raised and <tt class="literal"><span class="pre">NULL</span></tt> is returned.
<em>sender</em> is the wrapped <tt class="literal"><span class="pre">QObject</span></tt> derived instance that emits the signal.
<em>signal</em> is the typed name of the signal.  <em>receiver</em> is the wrapped
<tt class="literal"><span class="pre">QObject</span></tt> derived instance or Python callable that the signal is
connected to.  <em>slot</em> is the typed name of the slot, or <tt class="literal"><span class="pre">NULL</span></tt> if
<em>receiver</em> is a Python callable.  It is normally only used by PyQt to
implement <tt class="literal"><span class="pre">QObject.disconnect()</span></tt>.</p>
<p class="last">This is only available if Qt support is enabled.</p>
</dd>
</dl>
</div>
<div class="section" id="sipemitsignal">
<h2><a class="toc-backref" href="#id121" name="sipemitsignal">8.16   sipEmitSignal()</a></h2>
<dl>
<dt>int sipEmitSignal(PyObject *txobj, const char *signal, PyObject *args)</dt>
<dd><p class="first">This emits a signal and returns zero if there was no error.  If there was
an error then a Python exception is raised and a negative value is
returned.  <em>txobj</em> is the wrapped <tt class="literal"><span class="pre">QObject</span></tt> derived instance that emits
the signal.  <em>signal</em> is the typed name of the signal.  <em>args</em> is a Python
tuple of the signal arguments.  It is normally only used by PyQt to
implement <tt class="literal"><span class="pre">QObject.emit()</span></tt>.</p>
<p class="last">This is only available if Qt support is enabled.</p>
</dd>
</dl>
</div>
<div class="section" id="sipfree">
<h2><a class="toc-backref" href="#id122" name="sipfree">8.17   sipFree()</a></h2>
<dl>
<dt>void sipFree(void *mem)</dt>
<dd>This returns an area of memory allocated by <a class="reference" href="#sipmalloc">sipMalloc()</a> to the heap.
<em>mem</em> is a pointer to the area of memory.</dd>
</dl>
</div>
<div class="section" id="sipgetsender">
<h2><a class="toc-backref" href="#id123" name="sipgetsender">8.18   sipGetSender()</a></h2>
<dl>
<dt>void *sipGetSender()</dt>
<dd><p class="first">This returns a pointer to the last <tt class="literal"><span class="pre">QObject</span></tt> instance that emitted a Qt
signal.  It is normally only used by PyQt to implement
<tt class="literal"><span class="pre">QObject.sender()</span></tt>.</p>
<p class="last">This is only available if Qt support is enabled.</p>
</dd>
</dl>
</div>
<div class="section" id="sipgetwrapper">
<h2><a class="toc-backref" href="#id124" name="sipgetwrapper">8.19   sipGetWrapper()</a></h2>
<dl>
<dt>PyObject *sipGetWrapper(void *cppptr, sipWrapperType *type)</dt>
<dd>This returns a borrowed reference to the wrapped instance object for a C
structure or C++ class instance.  If the structure or class instance
hasn't been wrapped then <tt class="literal"><span class="pre">NULL</span></tt> is returned (and no Python exception is
raised).  <em>cppptr</em> is the pointer to the structure or class instance.
<em>type</em> is the generated type corresponding to the C/C++ type.</dd>
</dl>
</div>
<div class="section" id="sipinttypeclassmap">
<h2><a class="toc-backref" href="#id125" name="sipinttypeclassmap">8.20   sipIntTypeClassMap</a></h2>
<p>This C structure is used with <a class="reference" href="#sipmapinttoclass">sipMapIntToClass()</a> to define a mapping
between integer based RTTI and <a class="reference" href="#generated-type-objects">generated type objects</a>.  The structure
elements are as follows.</p>
<dl>
<dt>int typeInt</dt>
<dd>The integer RTTI.</dd>
<dt>sipWrapperType **pyType.</dt>
<dd>A pointer to the corresponding Python type object.</dd>
</dl>
</div>
<div class="section" id="sipissubclassinstance">
<h2><a class="toc-backref" href="#id126" name="sipissubclassinstance">8.21   sipIsSubClassInstance()</a></h2>
<dl>
<dt>int sipIsSubClassInstance(PyObject *obj, sipWrapperType *type)</dt>
<dd>This is a thin wrapper around the Python <tt class="literal"><span class="pre">PyObject_TypeCheck()</span></tt>
function provided to make it easier to write handwritten code that is
compatible with <a class="reference" href="#sip-v3-x">SIP v3.x</a> and versions of Python earlier that v2.2.</dd>
</dl>
</div>
<div class="section" id="sipmalloc">
<h2><a class="toc-backref" href="#id127" name="sipmalloc">8.22   sipMalloc()</a></h2>
<dl>
<dt>void *sipMalloc(size_t nbytes)</dt>
<dd>This allocates an area of memory of size <em>nytes</em> on the heap using the
Python <tt class="literal"><span class="pre">PyMem_Malloc()</span></tt> function.  If there was an error then <tt class="literal"><span class="pre">NULL</span></tt> is
returned and a Python exception raised.  See <a class="reference" href="#sipfree">sipFree()</a>.</dd>
</dl>
</div>
<div class="section" id="sipmapinttoclass">
<h2><a class="toc-backref" href="#id128" name="sipmapinttoclass">8.23   sipMapIntToClass()</a></h2>
<dl>
<dt>sipWrapperType *sipMapIntToClass(int type, const sipIntTypeClassMap *map, int maplen)</dt>
<dd>This is used in <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code as a convenient way of
converting integer based RTTI to the corresponding Python type object.
<em>type</em> is the RTTI.  <em>map</em> is the table of known RTTI and the corresponding
type objects (see <a class="reference" href="#sipinttypeclassmap">sipIntTypeClassMap</a>).  The entries in the table must be
sorted in ascending order of RTTI.  <em>maplen</em> is the number of entries in
the table.  The corresponding Python type object is returned, or <tt class="literal"><span class="pre">NULL</span></tt>
if <em>type</em> wasn't in <em>map</em>.</dd>
</dl>
</div>
<div class="section" id="sipmapstringtoclass">
<h2><a class="toc-backref" href="#id129" name="sipmapstringtoclass">8.24   sipMapStringToClass()</a></h2>
<dl>
<dt>sipWrapperType *sipMapStringToClass(char *type, const sipStringTypeClassMap *map, int maplen)</dt>
<dd>This is used in <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code as a convenient way of
converting <tt class="literal"><span class="pre">'\0'</span></tt> terminated string based RTTI to the corresponding
Python type object.  <em>type</em> is the RTTI.  <em>map</em> is the table of known RTTI
and the corresponding type objects (see <a class="reference" href="#sipstringtypeclassmap">sipStringTypeClassMap</a>).  The
entries in the table must be sorted in ascending order of RTTI.  <em>maplen</em>
is the number of entries in the table.  The corresponding Python type
object is returned, or <tt class="literal"><span class="pre">NULL</span></tt> if <em>type</em> wasn't in <em>map</em>.</dd>
</dl>
</div>
<div class="section" id="sipparseresult">
<h2><a class="toc-backref" href="#id130" name="sipparseresult">8.25   sipParseResult()</a></h2>
<dl>
<dt>int sipParseResult(int *iserr, PyObject *method, PyObject *result, char *format, ...)</dt>
<dd><p class="first">This converts a Python object (usually returned by a method) to C/C++ based
on a format string and associated values in a similar way to the Python
<tt class="literal"><span class="pre">PyArg_ParseTuple()</span></tt> function.  If there was an error then <tt class="literal"><span class="pre">NULL</span></tt> is
returned and a Python exception is raised.  If <em>iserr</em> is not <tt class="literal"><span class="pre">NULL</span></tt> then
the location it points to is set to a non-zero value.  <em>method</em> is the
Python bound method that returned the <em>result</em> object.  <em>format</em> is the
string of format characters.</p>
<p>This is normally called by handwritten code specified with the
<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a> directive with <em>method</em> being the supplied
<tt class="literal"><span class="pre">sipMethod</span></tt> and <tt class="literal"><span class="pre">result</span></tt> being the value returned by
<a class="reference" href="#sipcallmethod">sipCallMethod()</a>.</p>
<p>If <em>format</em> begins and ends with parentheses then <em>result</em> must be a Python
tuple and the rest of <em>format</em> is applied to the tuple contents.</p>
<p>In the following description the first letter is the format character, the
entry in parentheses is the Python object type that the format character
will convert, and the entry in brackets are the types of the C/C++ values
to be passed.</p>
<dl class="last">
<dt><tt class="literal"><span class="pre">a</span></tt> (string) [char **, int *]</dt>
<dd>Convert a Python string to a C/C++ character array and its length.  If
the Python object is <tt class="literal"><span class="pre">Py_None</span></tt> then the array and length are <tt class="literal"><span class="pre">NULL</span></tt>
and zero respectively.</dd>
<dt><tt class="literal"><span class="pre">b</span></tt> (integer) [bool *]</dt>
<dd>Convert a Python integer to a C/C++ <tt class="literal"><span class="pre">bool</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">c</span></tt> (string) [char *]</dt>
<dd>Convert a Python string of length 1 to a C/C++ <tt class="literal"><span class="pre">char</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">d</span></tt> (float) [double *]</dt>
<dd>Convert a Python floating point number to a C/C++ <tt class="literal"><span class="pre">double</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">e</span></tt> (integer) [enum *]</dt>
<dd>Convert Python integer to a C/C++ <tt class="literal"><span class="pre">enum</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">f</span></tt> (float) [double *]</dt>
<dd>Convert a Python floating point number to a C/C++ <tt class="literal"><span class="pre">float</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">h</span></tt> (integer) [short *]</dt>
<dd>Convert a Python integer to a C/C++ <tt class="literal"><span class="pre">short</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">i</span></tt> (integer) [int *]</dt>
<dd>Convert a Python integer to a C/C++ <tt class="literal"><span class="pre">int</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">l</span></tt> (integer) [long *]</dt>
<dd>Convert a Python integer to a C/C++ <tt class="literal"><span class="pre">long</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">s</span></tt> (string) [char **]</dt>
<dd>Convert a Python string to a C/C++ <tt class="literal"><span class="pre">'\0'</span></tt> terminated string.  If the
Python object is <tt class="literal"><span class="pre">Py_None</span></tt> then the string is <tt class="literal"><span class="pre">NULL</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">L</span></tt> (object) [<em>type</em> *(*)(PyObject *obj, int *iserr), void **]</dt>
<dd>Convert a Python object to a C structure or a C++ class instance using
a convertor function.  See <a class="reference" href="#generated-type-convertors">Generated Type Convertors</a>.</dd>
<dt><tt class="literal"><span class="pre">M</span></tt> (object) [<em>type</em> *(*)(PyObject *obj, int *iserr), void **]</dt>
<dd>Convert a Python object to a C structure or a C++ class instance using
a convertor function.  If the structure or class instance pointer is
<tt class="literal"><span class="pre">NULL</span></tt> then return an error.  See <a class="reference" href="#generated-type-convertors">Generated Type Convertors</a>.</dd>
<dt><tt class="literal"><span class="pre">N</span></tt> (object) [PyTypeObject *, PyObject **]</dt>
<dd>A Python object is checked to see if it is a certain type and then
returned without any conversions.  The reference count is incremented.
The Python object may be <tt class="literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">O</span></tt> (object) [PyObject **]</dt>
<dd>A Python object is returned without any conversions.  The reference
count is incremented.</dd>
<dt><tt class="literal"><span class="pre">T</span></tt> (object) [PyTypeObject *, PyObject **]</dt>
<dd>A Python object is checked to see if it is a certain type and then
returned without any conversions.  The reference count is incremented.
The Python object may not be <tt class="literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">V</span></tt> (sip.voidptr) [void *]</dt>
<dd>Convert a Python <tt class="literal"><span class="pre">sip.voidptr</span></tt> object to a C/C++ <tt class="literal"><span class="pre">void</span> <span class="pre">*</span></tt>.</dd>
<dt><tt class="literal"><span class="pre">Z</span></tt> (object) []</dt>
<dd>Check that a Python object is <tt class="literal"><span class="pre">Py_None</span></tt>.  No value is returned.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="sipstringtypeclassmap">
<h2><a class="toc-backref" href="#id131" name="sipstringtypeclassmap">8.26   sipStringTypeClassMap</a></h2>
<p>This C structure is used with <a class="reference" href="#sipmapstringtoclass">sipMapStringToClass()</a> to define a mapping
between <tt class="literal"><span class="pre">'\0'</span></tt> terminated string based RTTI and <a class="reference" href="#generated-type-objects">generated type objects</a>.
The structure elements are as follows.</p>
<dl>
<dt>char *typeString</dt>
<dd>The <tt class="literal"><span class="pre">'\0'</span></tt> terminated string RTTI.</dd>
<dt>sipWrapperType **pyType.</dt>
<dd>A pointer to the corresponding Python type object.</dd>
</dl>
</div>
<div class="section" id="siptransfer">
<h2><a class="toc-backref" href="#id132" name="siptransfer">8.27   sipTransfer()</a></h2>
<dl>
<dt>void sipTransfer(PyObject *obj, int tocpp)</dt>
<dd>This transfers ownership of a Python wrapped instance either to or from
Python (see <a class="reference" href="#ownership-of-objects">Ownership of Objects</a>).  <em>obj</em> is the wrapped instance.  If
<em>tocpp</em> is non-zero then ownership is transfered from Python to C/C++. If
<em>tocpp</em> is zero then ownership is transfered from C/C++ to Python.</dd>
</dl>
</div>
<div class="section" id="sipwrappertype">
<h2><a class="toc-backref" href="#id133" name="sipwrappertype">8.28   sipWrapperType</a></h2>
<p>This is a C structure that represents a SIP generated type object.  It is an
extension of the Python <tt class="literal"><span class="pre">PyTypeObject</span></tt> structure (which is itself an
extension of the Python <tt class="literal"><span class="pre">PyObject</span></tt> structure) and so may be safely cast to
<tt class="literal"><span class="pre">PyTypeObject</span></tt> (and <tt class="literal"><span class="pre">PyObject</span></tt>).</p>
</div>
<div class="section" id="generated-type-convertors">
<h2><a class="toc-backref" href="#id134" name="generated-type-convertors">8.29   Generated Type Convertors</a></h2>
<p>SIP generates functions for all types being wrapped (including mapped types
defined with the <a class="reference" href="#mappedtype">%MappedType</a> directive) that convert a Python object to the
C structure or C++ class instance.  The name of this convertor is the name of
the structure or class prefixed by <tt class="literal"><span class="pre">sipForceConvertTo_</span></tt>.</p>
<dl>
<dt>void *sipForceConvertTo_*class*(PyObject *obj, int *iserr)</dt>
<dd><em>obj</em> is the Python object to convert.  If <em>obj</em> is <tt class="literal"><span class="pre">NULL</span></tt> or the
location pointed to by <em>iserr</em> is non-zero then the conversion is not
attempted and <tt class="literal"><span class="pre">NULL</span></tt> is returned.  If there was an error then the
location pointed to by <em>iserr</em> is set to a non-zero value, a Python
exception is raised, and <tt class="literal"><span class="pre">NULL</span></tt> is returned.</dd>
</dl>
<p>SIP also generates functions for mapped types that convert a C structure or
C++ class instance to a Python object.  The name of this convertor is the name
of the structure or class prefixed by <tt class="literal"><span class="pre">sipConvertFrom_</span></tt>.</p>
<dl>
<dt>PyObject *sipConvertFrom_*class*(void *cppptr)</dt>
<dd><em>cppptr</em> is a pointer to the C structure or C++ class instance to convert.
If there was an error then <tt class="literal"><span class="pre">NULL</span></tt> is returned and a Python exception
raised.</dd>
</dl>
<p>The convertor functions of all imported types are available to handwritten
code.</p>
</div>
<div class="section" id="generated-type-objects">
<h2><a class="toc-backref" href="#id135" name="generated-type-objects">8.30   Generated Type Objects</a></h2>
<p>SIP generates a type object for each C structure or C++ class being wrapped.
These are <a class="reference" href="#sipwrappertype">sipWrapperType</a> structures and are used extensively by the SIP API.</p>
<p>These objects are named with the structure or class name prefixed by
<tt class="literal"><span class="pre">sipClass_</span></tt>.  For example, the type object for class <tt class="literal"><span class="pre">Klass</span></tt> is
<tt class="literal"><span class="pre">sipClass_Klass</span></tt>.</p>
<p>The type objects of all imported classes are available to handwritten code.</p>
</div>
<div class="section" id="generated-derived-classes">
<h2><a class="toc-backref" href="#id136" name="generated-derived-classes">8.31   Generated Derived Classes</a></h2>
<p>For most C++ classes being wrapped SIP generates a derived class with the same
name prefixed by <tt class="literal"><span class="pre">sip</span></tt>.  For example, the derived class for class <tt class="literal"><span class="pre">Klass</span></tt>
is <tt class="literal"><span class="pre">sipKlass</span></tt>.</p>
<p>If a C++ class doesn't have any virtual or protected methods in it or any of
it's super-class hierarchy, or does not emit any Qt signals, then a derived
class is not generated.</p>
<p>Most of the time handwritten code should ignore the derived classes.  The only
exception is that handwritten constructor code specified using the
<a class="reference" href="#methodcode">%MethodCode</a> directive should call the derived class's constructor (which
has the same C++ signature) rather then the wrapped class's constructor.</p>
</div>
</div>
<div class="section" id="using-the-sip-module-in-applications">
<h1><a class="toc-backref" href="#id137" name="using-the-sip-module-in-applications">9   Using the SIP Module in Applications</a></h1>
<p>The main purpose of the SIP module is to provide functionality common to all
SIP generated bindings.  It is loaded automatically and most of the time you
will completely ignore it.  However, it does expose some functionality that can
be used by applications.</p>
<dl>
<dt>settracemask(mask)</dt>
<dd><p class="first">If the bindings have been created with SIP's <tt class="literal"><span class="pre">-r</span></tt> command line option
then the generated code will produce debugging statements that trace the
execution of the code.  (It is particularly useful when trying to
understand the operation of a C++ library's virtual function calls.)</p>
<p>Debugging statements are generated at the following points:</p>
<ul class="simple">
<li>in a C++ virtual function (<em>mask</em> is <tt class="literal"><span class="pre">0x0001</span></tt>)</li>
<li>in a C++ constructor (<em>mask</em> is <tt class="literal"><span class="pre">0x0002</span></tt>)</li>
<li>in a C++ destructor (<em>mask</em> is <tt class="literal"><span class="pre">0x0004</span></tt>)</li>
<li>in a Python type's __init__ method (<em>mask</em> is <tt class="literal"><span class="pre">0x0008</span></tt>)</li>
<li>in a Python type's __del__ method (<em>mask</em> is <tt class="literal"><span class="pre">0x0010</span></tt>)</li>
<li>in a Python type's ordinary method (<em>mask</em> is <tt class="literal"><span class="pre">0x0020</span></tt>).</li>
</ul>
<p class="last">By default the trace mask is zero and all debugging statements are
disabled.</p>
</dd>
<dt>transfer(obj, direction)</dt>
<dd>Ownership of the wrapped C/C++ structure or class instance <em>obj</em> (i.e. the
responsibility for deallocating it) is transferred to the C/C++ library (if
<em>direction</em> is non-zero) or to the Python extension module (if <em>direction</em>
is zero).</dd>
<dt>unwrapinstance(obj)</dt>
<dd>Return the address, as a number, of the wrapped C/C++ structure or class
instance <em>obj</em>.</dd>
<dt>wrapinstance(addr, type)</dt>
<dd>A C/C++ structure or class instance is wrapped and the Python object
created is returned.  If the instance has already been wrapped then a new
reference to the existing object is returned.  <em>addr</em> is the address of
the instance represented as a number.  <em>type</em> is the type of the object
(e.g. <tt class="literal"><span class="pre">qt.QWidget</span></tt>).</dd>
</dl>
</div>
<div class="section" id="the-sip-build-system">
<h1><a class="toc-backref" href="#id138" name="the-sip-build-system">10   The SIP Build System</a></h1>
<p>The purpose of the build system is to make it easy for you to write
configuration scripts in Python for your own bindings.  The build system takes
care of the details of particular combinations of platform and compiler.  It
supports over 50 different platform/compiler combinations.</p>
<p>The build system is implemented as a pure Python module called <tt class="literal"><span class="pre">sipconfig</span></tt>
that contains a number of classes and functions.  Using this module you can
write bespoke configuration scripts (e.g. PyQt's <tt class="literal"><span class="pre">configure.py</span></tt>) or use it
with other Python based build systems (e.g.
<a class="reference" href="http://www.python.org/sigs/distutils-sig/distutils.html">Distutils</a> and
<a class="reference" href="http://www.scons.org">SCons</a>).</p>
<p>An important feature of SIP is the ability to generate bindings that are built
on top of existing bindings.  For example, both
<a class="reference" href="http://www.riverbankcomputing.co.uk/pykde/">PyKDE</a> and
<a class="reference" href="http://pyqwt.sourceforge.net/">PyQwt</a> are built on top of PyQt but all three
packages are maintained by different developers.  To make this easier PyQt
includes its own configuration module, <tt class="literal"><span class="pre">pyqtconfig</span></tt>, that contains additional
classes intended to be used by the configuration scripts of bindings built on
top of PyQt.  The SIP build system includes facilities that do a lot of the
work of creating these additional configuration modules.</p>
<div class="section" id="sipconfig-functions">
<h2><a class="toc-backref" href="#id139" name="sipconfig-functions">10.1   <tt class="literal"><span class="pre">sipconfig</span></tt> Functions</a></h2>
<dl>
<dt>create_config_module(module, template, content)</dt>
<dd><p class="first">This creates a configuration module (e.g. <tt class="literal"><span class="pre">pyqtconfig</span></tt>) from a template
file and a string.</p>
<p><tt class="literal"><span class="pre">module</span></tt> is the name of the configuration module file to create.</p>
<p><tt class="literal"><span class="pre">template</span></tt> is the name of the template file.</p>
<p class="last"><tt class="literal"><span class="pre">content</span></tt> is a string which replaces every occurence of the pattern
<tt class="literal"><span class="pre">&#64;SIP_CONFIGURATION&#64;</span></tt> in the template file.  The content string is
usually created from a Python dictionary using
<tt class="literal"><span class="pre">sipconfig.create_content()</span></tt>.</p>
</dd>
<dt>create_content(dict, dictname=&quot;_pkg_config&quot;)</dt>
<dd><p class="first">This converts a Python dictionary to a string that can be parsed by the
Python interpreter and converted back to an equivalent dictionary.  It is
typically used to generate the content string for
<tt class="literal"><span class="pre">sipconfig.create_config_module()</span></tt>.</p>
<p><tt class="literal"><span class="pre">dict</span></tt> is the Python dictionary to convert.</p>
<p><tt class="literal"><span class="pre">dictname</span></tt> is the optional name of the dictionary.</p>
<p class="last">Returns the dictionary as a string.</p>
</dd>
<dt>error(msg)</dt>
<dd><p class="first">This displays an error message on <tt class="literal"><span class="pre">stderr</span></tt> and calls <tt class="literal"><span class="pre">sys.exit()</span></tt> with
a value of 1.</p>
<p class="last"><tt class="literal"><span class="pre">msg</span></tt> is the text of the message and should not include any newline
characters.</p>
</dd>
<dt>format(msg, leftmargin=0, rightmargin=78)</dt>
<dd><p class="first">This formats a message by inserting newline characters at appropriate
places.</p>
<p><tt class="literal"><span class="pre">msg</span></tt> is the text of the message and should not include any newline
characters.</p>
<p><tt class="literal"><span class="pre">leftmargin</span></tt> is the optional position of the left margin.</p>
<p class="last"><tt class="literal"><span class="pre">rightmargin</span></tt> is the optional position of the right margin.</p>
</dd>
<dt>inform(msg)</dt>
<dd><p class="first">This displays an information message on <tt class="literal"><span class="pre">stdout</span></tt>.</p>
<p class="last"><tt class="literal"><span class="pre">msg</span></tt> is the text of the message and should not include any newline
characters.</p>
</dd>
<dt>read_version(filename, description, numdefine=None, strdefine=None)</dt>
<dd><p class="first">This extracts version information for a package from a file, usually a C or
C++ header file.  The version information must each be specified as a
<tt class="literal"><span class="pre">#define</span></tt> of a numeric (hexadecimal or decimal) value and/or a string
value.</p>
<p><tt class="literal"><span class="pre">filename</span></tt> is the name of the file to read.</p>
<p><tt class="literal"><span class="pre">description</span></tt> is a descriptive name of the package used in error
messages.</p>
<p><tt class="literal"><span class="pre">numdefine</span></tt> is the optional name of the <tt class="literal"><span class="pre">#define</span></tt> of the version as a
number.  If it is <tt class="literal"><span class="pre">None</span></tt> then the numeric version is ignored.</p>
<p><tt class="literal"><span class="pre">strdefine</span></tt> is the optional name of the <tt class="literal"><span class="pre">#define</span></tt> of the version as a
string.  If it is <tt class="literal"><span class="pre">None</span></tt> then the string version is ignored.</p>
<p class="last">Returns a tuple of the numeric and string versions.  <tt class="literal"><span class="pre">sipconfig.error()</span></tt>
is called if either were required but could not be found.</p>
</dd>
<dt>version_to_sip_tag(version, tags, description)</dt>
<dd><p class="first">This converts a version number to a SIP version tag.  SIP uses the
<tt class="literal"><span class="pre">%Timeline</span></tt> directive to define the chronology of the different versions
of the C/C++ library being wrapped.  Typically it is not necessary to
define a version tag for every version of the library, but only for those
versions that affect the library's API as SIP sees it.</p>
<p><tt class="literal"><span class="pre">version</span></tt> is the numeric version number of the C/C++ library being
wrapped.  If it is negative then the latest version is assumed.  (This is
typically useful if a snapshot is indicated by a negative version number.)</p>
<p><tt class="literal"><span class="pre">tags</span></tt> is the dictionary of SIP version tags keyed by the corresponding
C/C++ library version number.  The tag used is the one with the smallest
key (i.e. earliest version) that is greater than <tt class="literal"><span class="pre">version</span></tt>.</p>
<p><tt class="literal"><span class="pre">description</span></tt> is a descriptive name of the C/C++ library used in error
messages.</p>
<p class="last">Returns the SIP version tag.  <tt class="literal"><span class="pre">sipconfig.error()</span></tt> is called if the C/C++
library version number did not correspond to a SIP version tag.</p>
</dd>
<dt>version_to_string(v)</dt>
<dd><p class="first">This converts a 3 part version number encoded as a hexadecimal value to a
string.</p>
<p><tt class="literal"><span class="pre">v</span></tt> is the version number.</p>
<p class="last">Returns a string.</p>
</dd>
</dl>
</div>
<div class="section" id="sipconfig-classes">
<h2><a class="toc-backref" href="#id140" name="sipconfig-classes">10.2   <tt class="literal"><span class="pre">sipconfig</span></tt> Classes</a></h2>
<dl>
<dt>Configuration</dt>
<dd><p class="first">This class encapsulates configuration values that can be accessed as
instance objects.  A sub-class may provide a dictionary of additional
configuration values in its constructor the elements of which will have
precedence over the super-class's values.</p>
<p>The following configuration values are provided:</p>
<blockquote>
<dl>
<dt>default_bin_dir</dt>
<dd>The name of the directory where executables should be installed by
default.</dd>
<dt>default_mod_dir</dt>
<dd>The name of the directory where SIP generated modules should be
installed by default.</dd>
<dt>default_sip_dir</dt>
<dd>The name of the base directory where the <tt class="literal"><span class="pre">.sip</span></tt> files for SIP
generated modules should be installed by default.  A sub-directory
with the same name as the module should be created and its <tt class="literal"><span class="pre">.sip</span></tt>
files should be installed in the sub-directory.  The <tt class="literal"><span class="pre">.sip</span></tt>
files only need to be installed if you might want to build other
bindings based on them.</dd>
<dt>py_inc_dir</dt>
<dd>The name of the directory containing the <tt class="literal"><span class="pre">Python.h</span></tt> header file.</dd>
<dt>py_lib_dir</dt>
<dd>The name of the directory containing the Python interpreter
library.</dd>
<dt>py_version</dt>
<dd>The Python version as a 3 part hexadecimal number (e.g. v2.3.3 is
represented as <tt class="literal"><span class="pre">0x020303</span></tt>).</dd>
<dt>qt_dir</dt>
<dd>The name of the Qt base directory.  The value is not present if Qt
support is disabled.</dd>
<dt>qt_edition</dt>
<dd>The name of the Qt edition (e.g. enterprise, professional, free).
The value is not present if Qt support is disabled.</dd>
<dt>qt_inc_dir</dt>
<dd>The name of the Qt include directory.  The value is not present if
Qt support is disabled.</dd>
<dt>qt_lib</dt>
<dd>The name of the Qt library with platform dependent prefixes,
suffixes and version numbers removed (e.g. qt, qt-mt).  The value
is not present if Qt support is disabled.</dd>
<dt>qt_lib_dir</dt>
<dd>The name of the Qt library directory.  The value is not present if
Qt support is disabled.</dd>
<dt>qt_threaded</dt>
<dd>A non-zero value if the Qt library includes support for threads.
The value is not present if Qt support is disabled.</dd>
<dt>qt_version</dt>
<dd>The Qt version as a 3 part hexadecimal number (e.g. v3.3.0 is
represented as <tt class="literal"><span class="pre">0x030300</span></tt>).  It is <tt class="literal"><span class="pre">0</span></tt> if Qt support is
disabled.</dd>
<dt>qt_winconfig</dt>
<dd>A string describing the Qt configuration under Windows.  The value
is not present if Qt support is disabled.</dd>
<dt>sip_bin</dt>
<dd>The full pathname of the SIP executable.</dd>
<dt>sip_inc_dir</dt>
<dd>The name of the directory containing the <tt class="literal"><span class="pre">sip.h</span></tt> header file.</dd>
<dt>sip_mod_dir</dt>
<dd>The name of the directory containing the SIP module.</dd>
<dt>sip_version</dt>
<dd>The SIP version as a 3 part hexadecimal number (e.g. v4.0.0 is
represented as <tt class="literal"><span class="pre">0x040000</span></tt>).</dd>
<dt>sip_version_str</dt>
<dd>The SIP version as a string.  For development snapshots it will
start with <tt class="literal"><span class="pre">snapshot-</span></tt>.</dd>
</dl>
</blockquote>
<dl class="last">
<dt>__init__(self, sub_cfg=None)</dt>
<dd><p class="first">Initialise the instance.</p>
<p class="last"><tt class="literal"><span class="pre">sub_cfg</span></tt> is an optional list of sub-class configurations.  It should
only be used by the <tt class="literal"><span class="pre">__init__()</span></tt> method of a sub-class to append its
own dictionary of configuration values before passing the list to its
super-class.</p>
</dd>
</dl>
</dd>
<dt>Makefile</dt>
<dd><p class="first">This class encapsulates a Makefile.  It is intended to be sub-classed to
generate Makefiles for particular purposes.  It handles all platform and
compiler specific flags, but allows them to be adjusted to suit the
requirements of a particular module or program.  These are defined using a
number of macros which can be accessed as instance objects.</p>
<p>The following instance objects are provided to help in fine tuning the
generated Makefile:</p>
<blockquote>
<dl>
<dt>chkdir</dt>
<dd>A string that will check for the existence of a directory.</dd>
<dt>config</dt>
<dd>A reference to the <tt class="literal"><span class="pre">configuration</span></tt> argument that was passed to
the constructor.</dd>
<dt>console</dt>
<dd>A reference to the <tt class="literal"><span class="pre">console</span></tt> argument that was passed to the
constructor.</dd>
<dt>copy</dt>
<dd>A string that will copy a file.</dd>
<dt>extra_cflags</dt>
<dd>A list of additional flags passed to the C compiler.</dd>
<dt>extra_cxxflags</dt>
<dd>A list of additional flags passed to the C++ compiler.</dd>
<dt>extra_defines</dt>
<dd>A list of additional macro names passed to the C/C++ preprocessor.</dd>
<dt>extra_include_dirs</dt>
<dd>A list of additional include directories passed to the C/C++
preprocessor.</dd>
<dt>extra_lflags</dt>
<dd>A list of additional flags passed to the linker.</dd>
<dt>extra_lib_dirs</dt>
<dd>A list of additional library directories passed to the linker.</dd>
<dt>extra_libs</dt>
<dd>A list of additional libraries passed to the linker.  The names of
the libraries must be in platform neutral form (i.e. without any
platform specific prefixes, version numbers or extensions).</dd>
<dt>generator</dt>
<dd>A string that defines the platform specific style of Makefile.  The
only supported values are <tt class="literal"><span class="pre">UNIX</span></tt> and something else that is not
<tt class="literal"><span class="pre">UNIX</span></tt>.</dd>
<dt>mkdir</dt>
<dd>A string that will create a directory.</dd>
<dt>rm</dt>
<dd>A string that will remove a file.</dd>
</dl>
</blockquote>
<dl class="last">
<dt>__init__(self, configuration, console=0, qt=0, opengl=0, python=0, threaded=0, warnings=None, debug=0, dir=None, makefile=&quot;Makefile&quot;, installs=None)</dt>
<dd><p class="first">Initialise the instance.</p>
<p><tt class="literal"><span class="pre">configuration</span></tt> is the current configuration and is an instance of
the <tt class="literal"><span class="pre">Configuration</span></tt> class or a sub-class.</p>
<p><tt class="literal"><span class="pre">console</span></tt> is set if the target is a console (rather than GUI) target.
This only affects Windows and is ignored on other platforms.</p>
<p><tt class="literal"><span class="pre">qt</span></tt> is set if the target uses Qt.</p>
<p><tt class="literal"><span class="pre">opengl</span></tt> is set if the target uses OpenGL.</p>
<p><tt class="literal"><span class="pre">python</span></tt> is set if the target uses Python.h.</p>
<p><tt class="literal"><span class="pre">threaded</span></tt> is set if the target requires thread support.  It is set
automatically if the target uses Qt and Qt has thread support enabled.</p>
<p><tt class="literal"><span class="pre">warnings</span></tt> is set if compiler warning messages should be enabled.
The default of <tt class="literal"><span class="pre">None</span></tt> means that warnings are enabled for SIP v4.x
and disabled for SIP v3.x.</p>
<p><tt class="literal"><span class="pre">debug</span></tt> is set if debugging symbols should be generated.</p>
<p><tt class="literal"><span class="pre">dir</span></tt> is the name of the directory where build files are read from
and Makefiles are written to.  The default of <tt class="literal"><span class="pre">None</span></tt> means the
current directory is used.</p>
<p><tt class="literal"><span class="pre">makefile</span></tt> is the name of the generated Makefile.</p>
<p class="last"><tt class="literal"><span class="pre">installs</span></tt> is a list of extra install targets.  Each element is a two
part list, the first of which is the source and the second is the
destination.  If the source is another list then it is a list of source
files and the destination is a directory.</p>
</dd>
<dt>clean_build_file_objects(self, mfile, build)</dt>
<dd><p class="first">This generates the Makefile commands that will remove any files
generated during the build of the default target.</p>
<p><tt class="literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
<p class="last"><tt class="literal"><span class="pre">build</span></tt> is the dictionary created from parsing the build file.</p>
</dd>
<dt>finalise(self)</dt>
<dd>This is called just before the Makefile is generated to ensure that it
is fully configured.  It must be reimplemented by a sub-class.</dd>
<dt>generate(self)</dt>
<dd>This generates the Makefile.</dd>
<dt>generate_macros_and_rules(self, mfile)</dt>
<dd><p class="first">This is the default implementation of the Makefile macros and rules
generation.</p>
<p class="last"><tt class="literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
</dd>
<dt>generate_target_clean(self, mfile)</dt>
<dd><p class="first">This is the default implementation of the Makefile clean target
generation.</p>
<p class="last"><tt class="literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
</dd>
<dt>generate_target_default(self, mfile)</dt>
<dd><p class="first">This is the default implementation of the Makefile default target
generation.</p>
<p class="last"><tt class="literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
</dd>
<dt>generate_target_install(self, mfile)</dt>
<dd><p class="first">This is the default implementation of the Makefile install target
generation.</p>
<p class="last"><tt class="literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
</dd>
<dt>install_file(self, mfile, src, dst)</dt>
<dd><p class="first">This generates the Makefile commands to install one or more files to a
directory.</p>
<p><tt class="literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
<p><tt class="literal"><span class="pre">src</span></tt> is the name of a single file to install or a list of a number
of files to install.</p>
<p class="last"><tt class="literal"><span class="pre">dst</span></tt> is the name of the destination directory.</p>
</dd>
<dt>optional_list(self, name)</dt>
<dd><p class="first">This returns an optional Makefile macro as a list.</p>
<p><tt class="literal"><span class="pre">name</span></tt> is the name of the macro.</p>
<p class="last">Returns the macro as a list.</p>
</dd>
<dt>optional_string(self, name, default=&quot;&quot;)</dt>
<dd><p class="first">This returns an optional Makefile macro as a string.</p>
<p><tt class="literal"><span class="pre">name</span></tt> is the name of the macro.</p>
<p><tt class="literal"><span class="pre">default</span></tt> is the optional default value of the macro.</p>
<p class="last">Returns the macro as a string.</p>
</dd>
<dt>parse_build_file(self, filename)</dt>
<dd><p class="first">This parses a build file (created with the <tt class="literal"><span class="pre">-b</span></tt> SIP command line
option).</p>
<p><tt class="literal"><span class="pre">filename</span></tt> is the name of the build file.</p>
<p class="last">Returns a dictionary corresponding to the parsed build file.</p>
</dd>
<dt>platform_lib(self, clib)</dt>
<dd><p class="first">This converts a library name to a platform specific form.</p>
<p><tt class="literal"><span class="pre">clib</span></tt> is the name of the library in cannonical form.</p>
<p class="last">Return the platform specific name.</p>
</dd>
<dt>ready(self)</dt>
<dd>This is called to ensure that the Makefile is fully configured.  It is
normally called automatically when needed.</dd>
<dt>required_string(self, name)</dt>
<dd><p class="first">This returns a required Makefile macro as a string.</p>
<p><tt class="literal"><span class="pre">name</span></tt> is the name of the macro.</p>
<p class="last">Returns the macro as a string.  An exception is raised if the macro
does not exist or has an empty value.</p>
</dd>
</dl>
</dd>
<dt>ModuleMakefile(Makefile)</dt>
<dd><p class="first">This class encapsulates a Makefile to build a generic Python extension
module.</p>
<dl class="last">
<dt>__init__(self, configuration, build_file, install_dir=None, static=0, console=0, opengl=0, threaded=0, warnings=None, debug=0, dir=None, makefile=&quot;Makefile&quot;, installs=None)</dt>
<dd><p class="first">Initialise the instance.</p>
<p><tt class="literal"><span class="pre">configuration</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">build_file</span></tt> is the name of the build file.  Build files are
generated using the <tt class="literal"><span class="pre">-b</span></tt> SIP command line option.</p>
<p><tt class="literal"><span class="pre">install_dir</span></tt> is the name of the directory where the module will be
optionally installed.</p>
<p><tt class="literal"><span class="pre">static</span></tt> is set if the module should be built as a static library.</p>
<p><tt class="literal"><span class="pre">console</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">qt</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">opengl</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">threaded</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">warnings</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">debug</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">dir</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">makefile</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p class="last"><tt class="literal"><span class="pre">installs</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
</dd>
<dt>finalise(self)</dt>
<dd>This is a reimplementation of <tt class="literal"><span class="pre">sipconfig.Makefile.finalise()</span></tt>.</dd>
<dt>generate_macros_and_rules(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_macros_and_rules()</span></tt>.</dd>
<dt>generate_target_clean(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_target_clean()</span></tt>.</dd>
<dt>generate_target_default(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_target_default()</span></tt>.</dd>
<dt>generate_target_install(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_target_install()</span></tt>.</dd>
<dt>module_as_lib(self, mname)</dt>
<dd><p class="first">This returns the name of a SIP v3.x module for when it is used as a
library to be linked against.  An exception will be raised if it is
used with SIP v4.x modules.</p>
<p><tt class="literal"><span class="pre">mname</span></tt> is the name of the module.</p>
<p class="last">Returns the corresponding library name.</p>
</dd>
</dl>
</dd>
<dt>ParentMakefile(Makefile)</dt>
<dd><p class="first">This class encapsulates a Makefile that sits above a number of other
Makefiles in sub-directories.</p>
<dl class="last">
<dt>__init__(self, configuration, subdirs, dir=None, makefile=&quot;Makefile&quot;, installs=None)</dt>
<dd><p class="first">Initialise the instance.</p>
<p><tt class="literal"><span class="pre">configuration</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">subdirs</span></tt> is the sequence of sub-directories.</p>
<p><tt class="literal"><span class="pre">dir</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">makefile</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p class="last"><tt class="literal"><span class="pre">installs</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
</dd>
<dt>generate_macros_and_rules(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_macros_and_rules()</span></tt>.</dd>
<dt>generate_target_clean(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_target_clean()</span></tt>.</dd>
<dt>generate_target_default(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_target_default()</span></tt>.</dd>
<dt>generate_target_install(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_target_install()</span></tt>.</dd>
</dl>
</dd>
<dt>ProgramMakefile(Makefile)</dt>
<dd><p class="first">This class encapsulates a Makefile to build an executable program.</p>
<dl class="last">
<dt>__init__(self, configuration, build_file=None, install_dir=None, console=0, qt=0, opengl=0, python=0, threaded=0, warnings=None, debug=0, dir=None, makefile=&quot;Makefile&quot;, installs=None)</dt>
<dd><p class="first">Initialise the instance.</p>
<p><tt class="literal"><span class="pre">configuration</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">build_file</span></tt> is the name of the optional build file.  Build files are
generated using the <tt class="literal"><span class="pre">-b</span></tt> SIP command line option.</p>
<p><tt class="literal"><span class="pre">install_dir</span></tt> is the name of the directory where the executable
program will be optionally installed.</p>
<p><tt class="literal"><span class="pre">console</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">qt</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">opengl</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">python</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">threaded</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">warnings</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">debug</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">dir</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="literal"><span class="pre">makefile</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p class="last"><tt class="literal"><span class="pre">installs</span></tt> - see <tt class="literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
</dd>
<dt>build_command(self, source)</dt>
<dd><p class="first">This creates a single command line that will create an executable
program from a single source file.</p>
<p><tt class="literal"><span class="pre">source</span></tt> is the name of the source file.</p>
<p class="last">Returns a tuple of the name of the executable that will be created and
the command line.</p>
</dd>
<dt>finalise(self)</dt>
<dd>This is a reimplementation of <tt class="literal"><span class="pre">sipconfig.Makefile.finalise()</span></tt>.</dd>
<dt>generate_macros_and_rules(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_macros_and_rules()</span></tt>.</dd>
<dt>generate_target_clean(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_target_clean()</span></tt>.</dd>
<dt>generate_target_default(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_target_default()</span></tt>.</dd>
<dt>generate_target_install(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="literal"><span class="pre">sipconfig.Makefile.generate_target_install()</span></tt>.</dd>
</dl>
</dd>
<dt>SIPModuleMakefile(ModuleMakefile)</dt>
<dd><p class="first">This class encapsulates a Makefile to build a SIP generated Python
extension module.</p>
<dl class="last">
<dt>finalise(self)</dt>
<dd>This is a reimplementation of <tt class="literal"><span class="pre">sipconfig.Makefile.finalise()</span></tt>.</dd>
</dl>
</dd>
</dl>
</div>
</div>
</div>
</body>
</html>
