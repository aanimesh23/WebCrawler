<html><head><title>Future Work</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">
<HR><TABLE WIDTH=100%><TR ALIGN=CENTER><TD><A HREF="relatedwork.html">Related Work</A></TD><TD><A HREF="index.html#toc">Table of Contents</A></TD><TD><A HREF="conclusions.html">Conclusions</A></TD></TR><TR ALIGN=CENTER><TD>(Previous)</TD><TD></TD><TD>(Next)</TD></TR></TABLE><HR>
<H2>6. Future work</H2>
<P>
This section considers further issues for exploration. First, future plans for the prototype are presented. Second, techniques for increasing the transparency of the integrated toolkit are examined. Finally, this section concludes with a discussion of issues related to scalability.
</P>
<H3><A NAME="sec6.1">6.1</A>. Proof-of-concept prototype</H3>
<P>
The prototype described in <A HREF="prototype.html">Section&nbsp;3</A> will be evolved into a full integration of the Java AWT with the Chimera OHS. As the rest of the widgets are extended, the abstract toolkit and hypermedia interfaces will be developed. Plans are in place to test the reusability benefits provided by these interfaces. The technique will be applied to a different toolkit such as the Tk toolkit associated most closely with the Tcl scripting language. While there will have to be a syntactic conversion of the interfaces, common services, and extended widgets from Java to Tcl (or some other language such as C++), the semantics and structure of the code is expected to be largely preserved.
</P>
<P>
The other area of future research raised by the prototype is the need for session management capabilities for the integrated toolkit. Currently if two applications constructed with the prototype are running and the connection to the Chimera server is lost, then two connection dialogs are shown. This is because the hypermedia infrastructure cannot currently detect when more than one instance of itself is activated. New designs for this component of the conceptual architecture will be investigated so that its run-time sophistication is increased.
</P>
<H3><A NAME="sec6.2">6.2</A>. Transparency</H3>
<P>
Currently, the TI technique constructs a set of extended widgets which are used explicitly by application developers to include hypermedia services in their applications. The advantages of this are the freedom to include hypermedia-enabled widgets into specific areas of a user-interface and the maintenance benefits of having the code for these widgets located in one place. The disadvantages are the slight differences between the original widgets and the extended widgets; more importantly, developers have to modify existing applications or write new applications in order to take advantage of the provided capabilities. To reduce the effort required to use the integrated toolkit, the transparency of the technique to developers will be increased.
</P>
<P>
A first step in this direction is to eliminate the need for the hypermedia context information required by the extended widgets, thus making the interface to the these widgets identical to the originals. In the case of the prototype, Chimera requires as context information the name of the object and the name of the viewer displaying the object. One approach is to automatically construct an object name by using the concatenation of the widget's name and all its parents while using the name of the application containing the widget as the viewer name. For example, a button labelled "Quit" in an application named ChimeraEditor might have the automatically constructed view:
</P>
<PRE>(ChimeraEditor, HFrame:HPanel:HButton:Quit)
</PRE>
<P>
This particular algorithm may not be reusable across all open hypermedia systems (because of potential differences in the kinds of information required) but the conceptual architecture can be protected against these differences by the use of abstraction. Having eliminated the differences in the interfaces of the two sets of widgets, techniques in which one widget library is substituted for another may be possible. This would allow the inclusion of hypermedia-enabled widgets in pre-existing applications simply by relinking them or dynamically loading in the appropriate library at run-time. Thus, the potential exists for significantly reducing the developmental effort required to adopt the services provided by the integrated toolkit.
</P>
<H3><A NAME="sec6.3">6.3</A>. Scalability</H3>
<P>
As discussed previously, the TI technique can be used to integrate a toolkit with other services. For a particular toolkit, this approach creates one set of extended widgets for each service integrated. Unfortunately, there is no guarantee these diverse sets of widgets will interoperate. First, there is the cost of connecting to each integrated service. The prototype typically connects the Java AWT to the Chimera server in less than one second but as additional services are added, the start-up time will increase. This increase will seem cumbersome to users if it is incurred with each toolkit application. Second, the complexity of error handling increases. How should the toolkit indicate the currently available services? Third, integrated services send events to the widgets at unpredictable times. Since these events may cause application state changes, how does the toolkit manage the scheduling of these potentially conflicting events?
</P>
<P>
Fortunately, these problems are not insurmountable. It seems likely the first two problems can be solved with a more sophisticated run-time architecture for the integrated toolkit. In this hypothetical run-time, start-up costs are incurred once for the first toolkit application used but not for subsequent toolkit applications. A common service could display the systems currently connected to the toolkit. The third problem, while difficult, already has a suite of techniques for solving it from the research performed in the CSCW domain of synchronous groupware (See [<A HREF="references.html#ref12">12</A>] for details).
</P>
<P>
The real scalability issue occurs when a single widget provides access to multiple services simultaneously. Using the current technique described in this paper leads to a combinatorial explosion of extended widgets. For instance, for services A, B, and C, the technique would produce (in addition to the original widget) widget A, widget B, widget C, widget AB, widget AC, and widget ABC. This is clearly unacceptable. An alternative conceptual architecture is being investigated based on the idea behind the Decorator design pattern [<A HREF="references.html#ref9">9</A>]. The Decorator pattern is used in object-oriented toolkits to "decorate" a toolkit component such as adding scrollbars and a border to a text edit widget. The benefit of this pattern is any component can be decorated in this manner, allowing a clean separation of functionality. Text widgets can focus on sophisticated text editing capabilities while the scrollbar decorator can focus on providing advanced scrolling capabilities. Applying this pattern to services, may allow a widget's behaviors to be extended without having to modify the widget itself. The problems mentioned in the previous paragraph are still relevant (and still solvable) but there are many advantages to this potential technique such as increased transparency and being able to change a widget's service decorators dynamically at run-time.
</P>
<HR><TABLE WIDTH=100%><TR ALIGN=CENTER><TD><A HREF="relatedwork.html">Related Work</A></TD><TD><A HREF="index.html#toc">Table of Contents</A></TD><TD><A HREF="conclusions.html">Conclusions</A></TD></TR><TR ALIGN=CENTER><TD>(Previous)</TD><TD></TD><TD>(Next)</TD></TR></TABLE>
<hr>
</body></html>
