<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- Page automatically generated from latex_to_html converter. -->
<!-- by cc_extract_html, $Revision: 3.19 $ -->
<!-- LaTeX source file: './Convex_hull_d_ref/Convex_hull_d.tex' -->
<html> <head>  
<title>Convex_hull_d&lt;R&gt;</title>
</head>  
<link href="../latex_to_html.css" rel="STYLESHEET">
<body bgcolor="white">
<!-- ------------------------------------------------------------------- -->


<!-- Top Navigation ---------------------------------------------------- -->
<div class="NavTop">
<hr>
  <strong>Navigation:</strong>
<a href="Chapter_intro.html">Up</a>, 
  <a href="../contents.html">Table of Contents</A>,
  <a href="../biblio.html">Bibliography</a>,
  <a href="../manual_index.html">Index</a>,
  <a href="../title.html">Title Page</a>
<hr><!-- End of Top Navigation ----------------------------------------- -->
</div>


<A NAME="Cross_link_anchor_644"></A>

<A NAME="Cross_link_anchor_645"></A>

      
     
     
     
<A NAME="Index_anchor_585"></A> 

   
<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC="cc_Class.gif"></TD></TR></TABLE>


    <A NAME="ccRef_CGAL::Convex_hull_d<R>"></A>
<h2><I>CGAL::Convex_hull_d&lt;R&gt;</I></h2>
<P>

<H3>Definition</H3>
<P>

An instance <I>C</I> of type <I><A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;</I> is the convex hull
of a multi-set <I>S</I> of points in <MATH><I>d</I></MATH>-dimensional space. We call
<I>S</I> the underlying point set and <MATH><I>d</I></MATH> or <I>dim</I> the dimension of
the underlying space. We use <I>dcur</I> to denote the affine dimension
of <I>S</I>.  The data type supports incremental construction of hulls.
<P>

The closure of the hull is maintained as a simplicial complex, i.e.,
as a collection of simplices. The <A HREF="../Kernel_23_ref/Function_intersection.html#Cross_link_anchor_221">intersection</A> of any two is a face of
both<A HREF="#Footnote_1"><SUP>1</SUP></A>. In the
sequel we reserve the word simplex for the simplices of dimension
<I>dcur</I>. For each simplex there is a handle of type
<I>Simplex_handlex</I> and for each vertex there is a handle of type
<I>Vertex_handle</I>.  Each simplex has <MATH><I>1 + <I>dcur</I></I></MATH> vertices
indexed from <MATH><I>0</I></MATH> to <I>dcur</I>; for a simplex <MATH><I>s</I></MATH> and an index <MATH><I>i</I></MATH>,
<I>C.vertex(s,i)</I> returns the <MATH><I>i</I></MATH>-th vertex of <MATH><I>s</I></MATH>. For any simplex
<MATH><I>s</I></MATH> and any index <MATH><I>i</I></MATH> of <MATH><I>s</I></MATH> there may or may not be a simplex <MATH><I>t</I></MATH>
<A HREF="../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243">opposite</A> to the <MATH><I>i</I></MATH>-th vertex of <MATH><I>s</I></MATH>.  The function
<I>C.opposite_simplex(s,i)</I> returns <MATH><I>t</I></MATH> if it exists and returns
<I>Simplex_handle()</I> (the undefined handle) otherwise. If <MATH><I>t</I></MATH> exists
then <MATH><I>s</I></MATH> and <MATH><I>t</I></MATH> share <I>dcur</I> vertices, namely all but the vertex
with index <MATH><I>i</I></MATH> of <MATH><I>s</I></MATH> and the vertex with index
<I>C.index_of_vertex_in_opposite_simplex(s,i)</I> of <MATH><I>t</I></MATH>. Assume that
<MATH><I>t</I></MATH> exists and let <I>j = C.index_of_vertex_in_opposite_simplex(s,i)</I>.  Then <MATH><I>s =</I></MATH>
<I>C.opposite_simplex(t,j)</I> and <MATH><I>i =</I></MATH>
<I>C.index_of_vertex_in_opposite_simplex(t,j)</I>.
<P>

The boundary of the hull is also a simplicial complex. All simplices
in this complex have dimension <MATH><I><I>dcur</I> - 1</I></MATH>.  For each boundary
simplex there is a handle of type <I>Facet_handle</I>.  Each facet has
<I>dcur</I> vertices indexed from <MATH><I>0</I></MATH> to <MATH><I><I>dcur</I> - 1</I></MATH>. If <I>dcur &gt; 1</I> then for each facet <MATH><I>f</I></MATH> and each index <MATH><I>i</I></MATH>, <MATH><I>0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> i &lt;
<I>dcur</I></I></MATH>, there is a facet <MATH><I>g</I></MATH> <A HREF="../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243">opposite</A> to the <MATH><I>i</I></MATH>-th vertex of
<MATH><I>f</I></MATH>.  The function <I>C.opposite_facet(f,i)</I> returns <MATH><I>g</I></MATH>.  Two
neighboring facets <MATH><I>f</I></MATH> and <MATH><I>g</I></MATH> share <I>dcur - 1</I> vertices, namely
all but the vertex with index <MATH><I>i</I></MATH> of <MATH><I>f</I></MATH> and the vertex with index
<I>C.index_of_vertex_in_opposite_facet(f,i)</I> of <MATH><I>g</I></MATH>.  Let <I>j = C.index_of_vertex_in_opposite_facet(f,i)</I>. Then <I>f = C.opposite_facet(g,j)</I> and <I>i = C.index_of_vertex_in_opposite_facet(g,j)</I>.
<P>

<H3>Types</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::R
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    the representation class.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::<A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    the point type.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::<A HREF="../Kernel_d_ref/Class_Hyperplane_d.html#Cross_link_anchor_499">Hyperplane_d</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    the hyperplane type.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::Simplex_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    handle for simplices.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::Facet_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    handle for facets.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::Vertex_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    handle for vertices.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::Simplex_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator for simplices.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::Facet_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator for facets.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::Vertex_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator for vertices.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::Hull_vertex_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator for vertices that are
part of the convex hull.
<P>

</TD></TR>
        </TABLE>
<P>

Note that each iterator fits the handle concept, i.e. iterators can be
used as handles. Note also that all iterator and handle types come
also in a const flavor, e.g., <I>Vertex_const_iterator</I> is the
constant version of <I>Vertex_iterator</I>. Const correctness requires
to use the const version whenever the the convex hull object is
referenced as constant. The <I>Hull_vertex_iterator</I> is convertible
to <I>Vertex_iterator</I> and <I>Vertex_handle</I>.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::Point_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    const iterator for all inserted
points.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt;::Hull_point_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    const iterator for all points
that are part of the convex hull.
<P>

</TD></TR>
        </TABLE>
<P>

<H3>Creation</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A>&lt;R&gt; C ( int d,  R <A HREF="../Kernel_23_ref/Concept_Kernel.html#Cross_link_anchor_0">Kernel</A> = R());
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates an
instance <I>C</I> of type <I><A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A></I>. The dimension of the
underlying space is <MATH><I>d</I></MATH> and <I>S</I> is initialized to the empty point
set. The traits class <I>R</I> specifies the models of all types and
the implementations of all geometric primitives used by the convex
hull class. The default model is one of the <MATH><I>d</I></MATH>-dimensional
representation classes (e.g., <I>Homogeneous_d</I>).
<P>

</TD></TR>
        </TABLE>
<P>

The data type <I><A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A></I> offers neither copy constructor nor
assignment operator.
<P>

<H3>Requirements</H3>
<P>

<I>R</I> is a model of the concept <I><A HREF="Concept_ConvexHullTraits_d.html#Cross_link_anchor_643">ConvexHullTraits_d</A></I>
  
<A NAME="Index_anchor_586"></A> 
.
<P>

<H3>Operations</H3>
<P>

All operations below that take a point <I>x</I> as argument have the
common precondition that <I>x</I> is a point of ambient space.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_dimension69_;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.dimension ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the dimension of ambient space
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_current_dimension69_;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.current_dimension ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the affine dimension <I>dcur</I> of <MATH><I>S</I></MATH>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Point_d_associated_point6Vertex_handle_v9_;"></A>
<A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.associated_point ( Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the point associated with vertex <MATH><I>v</I></MATH>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_vertex_of_simplex6Simplex_handle_s+_int_i9_;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.vertex_of_simplex ( Simplex_handle s,  int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the vertex corresponding to the <MATH><I>i</I></MATH>-th vertex of <MATH><I>s</I></MATH>.<BR>

<BR>

<EM>Precondition: </EM><MATH><I>0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> <I>dcur</I></I></MATH>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Point_d_point_of_simplex6Simplex_handle_s+int_i9_;"></A>
<A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.point_of_simplex ( Simplex_handle s, int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    same as
<I>C.associated_point(C.vertex_of_simplex(s,i))</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Simplex_handle_opposite_simplex6Simplex_handle_s+int_i9_;"></A>
Simplex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.opposite_simplex ( Simplex_handle s, int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the simplex <A HREF="../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243">opposite</A> to the <MATH><I>i</I></MATH>-th vertex of <MATH><I>s</I></MATH>
(<I>Simplex_handle()</I> if there is no such simplex).<BR>

<EM>Precondition: </EM><MATH><I>0
 <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> <I>dcur</I></I></MATH>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_index_of_vertex_in_opposite_simplex6Simplex_handle_s+int_i9_;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    C.index_of_vertex_in_opposite_simplex ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Simplex_handle s,<BR>

int i)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the index of the vertex <A HREF="../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243">opposite</A> to the <MATH><I>i</I></MATH>-th vertex of
<MATH><I>s</I></MATH>.<BR>

<EM>Precondition: </EM><MATH><I>0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> i  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> <I>dcur</I></I></MATH> and there is a simplex
<A HREF="../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243">opposite</A> to the <MATH><I>i</I></MATH>-th vertex of <MATH><I>s</I></MATH>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Simplex_handle_simplex6Vertex_handle_v9_;"></A>
Simplex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.simplex ( Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a simplex
of which <MATH><I>v</I></MATH> is a node. Note that this simplex is not unique.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_index6Vertex_handle_v9_;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.index ( Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the index of <MATH><I>v</I></MATH> in
<I>simplex(v)</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_vertex_of_facet6Facet_handle_f+_int_i9_;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.vertex_of_facet ( Facet_handle f,  int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the vertex corresponding to the <MATH><I>i</I></MATH>-th vertex of <MATH><I>f</I></MATH>.<BR>

<EM>Precondition: </EM><MATH><I>0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> i &lt; <I>dcur</I></I></MATH>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Point_d_point_of_facet6Facet_handle_f+_int_i9_;"></A>
<A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.point_of_facet ( Facet_handle f,  int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    same as
<I>C.associated_point(C.vertex_of_facet(f,i))</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Facet_handle_opposite_facet6Facet_handle_f+_int_i9_;"></A>
Facet_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.opposite_facet ( Facet_handle f,  int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the facet <A HREF="../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243">opposite</A> to the <MATH><I>i</I></MATH>-th vertex of <MATH><I>f</I></MATH>
(<I>Facet_handle()</I> if there is no such facet).<BR>

<EM>Precondition: </EM><MATH><I>0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> i
&lt; <I>dcur</I></I></MATH> and <I>dcur &gt; 1</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_index_of_vertex_in_opposite_facet6Facet_handle_f+_int_i9_;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    C.index_of_vertex_in_opposite_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Facet_handle f,<BR>

int i)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the index of the vertex <A HREF="../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243">opposite</A> to the <MATH><I>i</I></MATH>-th vertex of
<MATH><I>f</I></MATH>.<BR>

<EM>Precondition: </EM><MATH><I>0  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> i &lt; <I>dcur</I></I></MATH> and <I>dcur &gt; 1</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Hyperplane_d_hyperplane_supporting6Facet_handle_f9_;"></A>
<A HREF="../Kernel_d_ref/Class_Hyperplane_d.html#Cross_link_anchor_499">Hyperplane_d</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.hyperplane_supporting ( Facet_handle f)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a hyperplane supporting facet <I>f</I>. The hyperplane is
oriented such that the interior of <I>C</I> is on the negative side of
it.<BR>

<EM>Precondition: </EM><I>f</I> is a facet of <I>C</I> and <I>dcur &gt; 1</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert6const_Point_d__x9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.insert (  <A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A> x)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    adds point <I>x</I>
to the underlying set of points.  If <MATH><I>x</I></MATH> is equal to (the point
associated with) a vertex of the current hull this vertex is returned
and its associated point is changed to <MATH><I>x</I></MATH>. If <MATH><I>x</I></MATH> lies outside the
current hull, a new vertex <I>v</I> with associated point <MATH><I>x</I></MATH> is added
to the hull and returned. In all other cases, i.e., if <MATH><I>x</I></MATH> lies in the
interior of the hull or on the boundary but not on a vertex, the
current hull is not changed and <I>Vertex_handle()</I> is returned. If
<I>CGAL_CHECK_EXPENSIVE</I> is defined then the validity check
<I>is_valid(true)</I> is executed as a post condition.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;typename Forward_iterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_insert6Forward_iterator_first+_Forward_iterator_last9_;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    C.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Forward_iterator first,<BR>

Forward_iterator last)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    adds <I>S = set [first,last)</I> to the underlying set of points. If any point
<I>S[i]</I> is equal to (the point associated with) a vertex of the
current hull its associated point is changed to <I>S[i]</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_dimension_jump6const_Point_d__x9_;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.is_dimension_jump (  <A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A> x)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns true if
<MATH><I>x</I></MATH> is not contained in the affine hull of <I>S</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_std::list6Facet_handle9_facets_visible_from6const_Point_d__x9;"></A>
std::list&lt;Facet_handle&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.facets_visible_from (  <A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A> x)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the list of all facets that are visible from <I>x</I>.<BR>

<BR>

<EM>Precondition: </EM><I>x</I> is contained in the affine hull of <I>S</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Bounded_side_bounded_side6const_Point_d__x9;"></A>
<A HREF="../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99">Bounded_side</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.bounded_side (  <A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A> x)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns
<I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_BOUNDED_SIDE</A></I> (<I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_BOUNDARY</A></I>,<I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_UNBOUNDED_SIDE</A></I>) if
<I>x</I> is contained in the interior (lies on the boundary, is
contained in the exterior) of <I>C</I>.<BR>

<EM>Precondition: </EM><I>x</I> is contained
in the affine hull of <I>S</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_clear6int_d9_;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.clear ( int d)
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    reinitializes <I>C</I> to an empty hull
in <MATH><I>d</I></MATH>-dimensional space.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_number_of_vertices69_;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.number_of_vertices ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of vertices
of <I>C</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_number_of_facets69_;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.number_of_facets ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of facets of
<I>C</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_number_of_simplices69_;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.number_of_simplices ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of bounded
simplices of <I>C</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_print_statistics69_;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.print_statistics ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    gives information about the size
of the current hull and the number of visibility tests performed.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_valid6bool_throw_exceptions_=_false9_;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.is_valid ( bool throw_exceptions = false)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    checks the
validity of the data structure.  If <I>throw_exceptions == thrue</I>
then the program throws the following exceptions to inform about the
problem.<BR>

<I>chull_has_center_on_wrong_side_of_hull_facet</I> the
hyperplane supporting a facet has the wrong <A HREF="../Kernel_23_ref/Function_orientation.html#Cross_link_anchor_247">orientation</A>.<BR>

<I>chull_has_local_non_convexity</I> a ridge is locally non convex.<BR>

<I>chull_has_double_coverage</I> the hull has a winding number larger
than 1.
        </TD></TR>
        </TABLE>
<P>

<H3>Lists and Iterators</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_iterator_vertices_begin69_;"></A>
Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.vertices_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    an iterator of <I>C</I> to
start the iteration over all vertices of the complex.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_iterator_vertices_end69_;"></A>
Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.vertices_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    the past the end iterator
for vertices.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Simplex_iterator_simplices_begin69_;"></A>
Simplex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.simplices_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    an iterator of <I>C</I>
to start the iteration over all simplices of the complex.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Simplex_iterator_simplices_end69_;"></A>
Simplex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.simplices_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    the past the end
iterator for simplices.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Facet_iterator_facets_begin69_;"></A>
Facet_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.facets_begin ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    an iterator of <I>C</I> to
start the iteration over all facets of the complex.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Facet_iterator_facets_end69_;"></A>
Facet_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.facets_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    the past the end iterator for
facets.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Hull_vertex_iterator_hull_vertices_begin69_;"></A>
Hull_vertex_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.hull_vertices_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    an iterator to
start the iteration over all vertices of <I>C</I> that are part of the
convex hull.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Hull_vertex_iterator_hull_vertices_end69_;"></A>
Hull_vertex_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.hull_vertices_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    the past the end
iterator for hull vertices.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Point_const_iterator_points_begin69_;"></A>
Point_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.points_begin ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the start
iterator for all points that have been inserted to construct <I>C</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Point_const_iterator_points_end69_;"></A>
Point_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.points_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the past the
end iterator for points.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Hull_point_const_iterator_hull_points_begin69_;"></A>
Hull_point_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.hull_points_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns an
iterator to start the iteration over all points in the convex hull
<I>C</I>. Included are points in the interior of facets.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Hull_point_const_iterator_hull_points_end69_;"></A>
Hull_point_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.hull_points_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the
past the end iterator for points in the convex hull.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;typename Visitor&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_visit_all_facets6const_Visitor__V9_;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    C.visit_all_facets (  Visitor V)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    each facet of <I>C</I> is visited by the visitor object
<I>V</I>.  <I>V</I> has to have a function call operator:<BR>

<I>void operator()(Facet_handle) const</I>
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_const_std::list6Point_d9__all_points69_;"></A>
 std::list&lt;<A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A>&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.all_points ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a list of
all points that have been inserted to construct <I>C</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_std::list6Vertex_handle9_all_vertices69_;"></A>
std::list&lt;Vertex_handle&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.all_vertices ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a list of
all vertices of <I>C</I> (also interior ones).
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_std::list6Simplex_handle9_all_simplices69_;"></A>
std::list&lt;Simplex_handle&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.all_simplices ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a list
of all simplices in <I>C</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_std::list6Facet_handle9_all_facets69_;"></A>
std::list&lt;Facet_handle&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    C.all_facets ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a list of
all facets of <I>C</I>.
        </TD></TR>
        </TABLE>
<P>

<H3>Iteration Statements</H3>
<P>

<B>forall_ch_vertices</B>(<MATH><I>v,C</I></MATH>) <MATH><I>{</I></MATH> ``the vertices of <MATH><I>C</I></MATH> are
successively assigned to <MATH><I>v</I></MATH>'' <MATH><I>}</I></MATH>
<P>

<B>forall_ch_simplices</B>(<MATH><I>s,C</I></MATH>) <MATH><I>{</I></MATH> ``the simplices of <MATH><I>C</I></MATH> are
successively assigned to <MATH><I>s</I></MATH>'' <MATH><I>}</I></MATH>
<P>

<B>forall_ch_facets</B>(<MATH><I>f,C</I></MATH>) <MATH><I>{</I></MATH> ``the facets of <MATH><I>C</I></MATH> are
successively assigned to <MATH><I>f</I></MATH>'' <MATH><I>}</I></MATH>
<P>

<H3>Implementation</H3>
<P>

The implementation of type <I><A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A></I> is based on
[<A HREF="../biblio.html#Biblio_cms-frric-93">CMS93</A>] and [<A HREF="../biblio.html#Biblio_bms-dgc-94">BMS94</A>].  The details
of the implementation can be found in the implementation document
available at the download site of this package.
<P>

The time and space requirements are input dependent.  Let <MATH><I>C<SUB>1</SUB></I></MATH>, <MATH><I>C<SUB>2</SUB></I></MATH>,
<MATH><I>C<SUB>3</SUB></I></MATH>, ...be the sequence of hulls constructed and for a point <MATH><I>x</I></MATH>
let <MATH><I>k<SUB>i</SUB></I></MATH> be the number of facets of <MATH><I>C<SUB>i</SUB></I></MATH> that are visible from <MATH><I>x</I></MATH>
and that are not already facets of <MATH><I>C<SUB>i-1</SUB></I></MATH>. Then the time for
inserting <MATH><I>x</I></MATH> is <MATH><I>O(<I>dim</I>  <IMG BORDER=0 WIDTH=13 HEIGHT=24 ALIGN=MIDDLE SRC="cc_sum.gif"> <SUB>i</SUB> k<SUB>i</SUB>)</I></MATH> and the number of new simplices
constructed during the insertion of <MATH><I>x</I></MATH> is the number of facets of the
hull which were not already facets of the hull before the insertion.
<P>

The data type <I><A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A></I> is derived from
<I>Regular_complex_d</I>. The space requirement of regular complexes is
essentially <MATH><I>12(<I>dim</I> +2)</I></MATH> bytes times the number of simplices
plus the space for the points. <I><A HREF="Class_Convex_hull_d.html#Cross_link_anchor_645">Convex_hull_d</A></I> needs an additional
<MATH><I>8 + (4 + x)<I>dim</I></I></MATH> bytes per simplex where <MATH><I>x</I></MATH> is the space
requirement of the underlying number type and an additional <MATH><I>12</I></MATH> bytes
per point. The total is therefore <MATH><I>(16 + x)<I>dim</I> + 32</I></MATH> bytes times
the number of simplices plus <MATH><I>28 + x  &middot; <I>dim</I></I></MATH> bytes times the
number of points.
<P>

<H3>Low Dimensional Conversion Routine</H3>
include <I>&lt;CGAL/Convex_hull_d_to_polyhedron_3.h&gt;</I>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class T, class HDS&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_convex_hull_d_to_polyhedron_36_const_Convex_hull_d6R9__C+_Polyhedron_36T+HDS9__P9_;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    convex_hull_d_to_polyhedron_3 ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     C,<BR>

<A HREF="../Polyhedron_ref/Class_Polyhedron_3.html#Cross_link_anchor_854">Polyhedron_3</A>&lt;T,HDS&gt;&amp; P)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    converts the convex hull <I>C</I> to polyedral surface stored in 
   <I>P</I>.<BR>

<BR>

<EM>Precondition: </EM><I>dim == 3</I> and <I>dcur == 3</I>.
        </TD></TR>
        </TABLE>
<P>

<H3>Low Dimensional Output Routines</H3>
include <I>&lt;CGAL/IO/Convex_hull_d_window_stream.h&gt;</I>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_d2_show6const_Convex_hull_d6R9__C+_CGAL::Window_stream__W9;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    d2_show (  C,  <A HREF="../Colors_and_windows_ref/Class_Window_stream.html#Cross_link_anchor_1757">CGAL::Window_stream</A>&amp; W)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    draws the convex hull <I>C</I> in window <I>W</I>.<BR>

<BR>

<EM>Precondition: </EM><I>dim == 2</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_d3_surface_map6const_Convex_hull_d6R9__C+_GRAPH6_typename_Convex_hull_d6R9::Point_d_+int9__G9;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    d3_surface_map ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     C,<BR>

GRAPH&lt; typename ::<A HREF="../Kernel_d_ref/Class_Point_d.html#Cross_link_anchor_487">Point_d</A> ,int&gt;&amp; G)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    constructs the representation of the surface of <I>C</I> as a 
bidirected LEDA graph <I>G</I>.<BR>

<BR>

<EM>Precondition: </EM><I>dim == 3</I>.
        </TD></TR>
        </TABLE>
<P>

<HR><H3>Footnotes</H3>
<P>

<TABLE><TR><TD VALIGN=TOP>
</TD></TR><TR><TD VALIGN=TOP>
        <A NAME="Footnote_1">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>
The empty set if a facet of every simplex.

</TD></TR></TABLE>
<div class="NavNext"><hr> <b>Next:</b> <a href="Class_Convex_hull_d_traits_3.html"><I>Convex_hull_d_traits_3&lt;R&gt;</I></a> 


    
<div class="NavBottom">
<hr><!-- Bottom Navigation --------------------------------------------- -->
  <strong>Navigation:</strong>
<!Up_chapter_link_6!>
  <a href="../contents.html">Table of Contents</A>,
  <a href="../biblio.html">Bibliography</a>,
  <a href="../manual_index.html">Index</a>,
  <a href="../title.html">Title Page</a>
<!-- End of Bottom Navigation ------------------------------------------ -->


<hr><!-- --------------------------------------------------------------- -->
<div class="NavAddress">

The <A HREF=http://www.cgal.org>CGAL Project</A> .

Tue, December 21, 2004 .
<hr></div>
</body>  </html>  
