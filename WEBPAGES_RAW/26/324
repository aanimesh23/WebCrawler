<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- Page automatically generated from latex_to_html converter. -->
<!-- by cc_extract_html, $Revision: 3.19 $ -->
<!-- LaTeX source file: './Triangulation_3_ref/Triangulation_3.tex' -->
<html> <head>  
<title>Triangulation_3&lt;TriangulationTraits_3,TriangulationDataStructure_3&gt;</title>
</head>  
<link href="../latex_to_html.css" rel="STYLESHEET">
<body bgcolor="white">
<!-- ------------------------------------------------------------------- -->


<!-- Top Navigation ---------------------------------------------------- -->
<div class="NavTop">
<hr>
  <strong>Navigation:</strong>
<a href="Chapter_intro.html">Up</a>, 
  <a href="../contents.html">Table of Contents</A>,
  <a href="../biblio.html">Bibliography</a>,
  <a href="../manual_index.html">Index</a>,
  <a href="../title.html">Title Page</a>
<hr><!-- End of Top Navigation ----------------------------------------- -->
</div>


<A NAME="Cross_link_anchor_971"></A>

<A NAME="Cross_link_anchor_972"></A>

      
     
     
     
<A NAME="Index_anchor_915"></A> 

   
<TABLE ALIGN=RIGHT><TR><TD><IMG ALIGN=TOP SRC="cc_Class.gif"></TD></TR></TABLE>


    <A NAME="ccRef_CGAL::Triangulation_3<TriangulationTraits_3,TriangulationDataStructure_3>"></A>
<h2><I>CGAL::Triangulation_3&lt;TriangulationTraits_3,TriangulationDataStructure_3&gt;</I></h2>
<P>

<H3>Definition</H3>
<P>

The class <I><A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A></I> represents a 3-dimensional tetrahedralization
of points.
<P>

<I>#include &lt;<A HREF="../../../include/CGAL/Triangulation_3.h">CGAL/Triangulation_3.h</A>&gt;</I>
<P>

<H3>Parameters</H3>
<P>

The first template argument must be a model of the
<I><A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A></I> concept.
<P>

The second template argument must be a model of the
<I><A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A></I> concept.
It has the default value <I><A HREF="../TriangulationDS_3_ref/Class_Triangulation_data_structure_3.html#Cross_link_anchor_1008">Triangulation_data_structure_3</A>&lt; <A HREF="Class_Triangulation_vertex_base_3.html#Cross_link_anchor_994">Triangulation_vertex_base_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>&gt;,<A HREF="Class_Triangulation_cell_base_3.html#Cross_link_anchor_990">Triangulation_cell_base_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>&gt;  &gt;</I>.
<P>

<H3>Inherits From</H3><I><A HREF="../TriangulationDS_3_ref/Class_Triangulation_utils_3.html#Cross_link_anchor_1014">Triangulation_utils_3</A></I>
<P>

<H3>Types</H3>The class <I><A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A></I> defines the following types:
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Triangulation_data_structure"></A>
<A NAME="Typedef_Triangulation_data_structure"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Triangulation_data_structure;
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Geom_traits"></A>
<A NAME="Typedef_Geom_traits"></A>
typedef <A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Geom_traits;
        </I></NOBR>
        </TD>
    
        </TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Point"></A>
<A NAME="Typedef_Point"></A>
typedef <A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>::<A HREF="../Kernel_23_ref/Class_Point_3.html#Cross_link_anchor_74">Point_3</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Point;
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Segment"></A>
<A NAME="Typedef_Segment"></A>
typedef <A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>::<A HREF="../Kernel_23_ref/Class_Segment_3.html#Cross_link_anchor_78">Segment_3</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Segment;
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Triangle"></A>
<A NAME="Typedef_Triangle"></A>
typedef <A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>::<A HREF="../Kernel_23_ref/Class_Triangle_3.html#Cross_link_anchor_84">Triangle_3</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Triangle;
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Tetrahedron"></A>
<A NAME="Typedef_Tetrahedron"></A>
typedef <A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>::<A HREF="../Kernel_23_ref/Class_Tetrahedron_3.html#Cross_link_anchor_82">Tetrahedron_3</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Tetrahedron;
        </I></NOBR>
        </TD>
    
        </TR>
        </TABLE>
<P>

Only vertices (<MATH><I>0</I></MATH>-faces) and cells (<MATH><I>3</I></MATH>-faces) are stored. Edges
(<MATH><I>1</I></MATH>-faces) and facets (<MATH><I>2</I></MATH>-faces) are not explicitly represented and
thus there are no corresponding classes (see
Section&nbsp;<A HREF="../Triangulation_3/Chapter_main.html#Triangulation3-sec-intro"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference" WIDTH="10" HEIGHT="10"></A>).
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Vertex"></A>
<A NAME="Typedef_Vertex"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3--Vertex.html#Cross_link_anchor_1004">TriangulationDataStructure_3::Vertex</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Vertex;
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Cell"></A>
<A NAME="Typedef_Cell"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3--Cell.html#Cross_link_anchor_1003">TriangulationDataStructure_3::Cell</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Cell;
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Facet"></A>
<A NAME="Typedef_Facet"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Facet
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Facet;
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Edge"></A>
<A NAME="Typedef_Edge"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Edge
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Edge;
        </I></NOBR>
        </TD>
    
        </TR>
        </TABLE>
<P>

The vertices and faces of the triangulations are accessed through
<I>handles</I>, <I>iterators</I> and <I>circulators</I>. 
A handle is a type which supports the two dereference operators
<I>operator*</I> and <I>operator-&gt;</I>.  The <A HREF="../Handle_ref/Concept_Handle.html#Cross_link_anchor_1663">Handle</A> concept is
documented in the support library.
Iterators and circulators are bidirectional and non-mutable.
The edges and facets of the triangulation can also be visited through
iterators and circulators which are bidirectional and non-mutable.
<P>

Iterators and circulators are convertible to the corresponding handles, thus
the user can pass them directly as arguments to the functions.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Vertex_handle"></A>
<A NAME="Typedef_Vertex_handle"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Vertex_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_handle;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    handle to a vertex
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Cell_handle"></A>
<A NAME="Typedef_Cell_handle"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Cell_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Cell_handle;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    handle to a cell
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_size_type"></A>
<A NAME="Typedef_size_type"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::size_type
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    size_type;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Size type (an unsigned integral type)
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_difference_type"></A>
<A NAME="Typedef_difference_type"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::difference_type
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    difference_type;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Difference type (a signed integral type)
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_All_cells_iterator"></A>
<A NAME="Typedef_All_cells_iterator"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Cell_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    All_cells_iterator;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    iterator over cells
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_All_facets_iterator"></A>
<A NAME="Typedef_All_facets_iterator"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Facet_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    All_facets_iterator;
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    iterator over facets
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_All_edges_iterator"></A>
<A NAME="Typedef_All_edges_iterator"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Edge_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    All_edges_iterator;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    iterator over edges
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_All_vertices_iterator"></A>
<A NAME="Typedef_All_vertices_iterator"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Vertex_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    All_vertices_iterator;
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    iterator over vertices
        </TD></TR>
        </TABLE>
<P>

        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>,<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>&gt;::Finite_cells_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator over finite cells
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>,<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>&gt;::Finite_facets_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator over finite facets
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>,<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>&gt;::Finite_edges_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator over finite edges
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>,<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>&gt;::Finite_vertices_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator over finite vertices
<P>

</TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>,<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>&gt;::Point_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator over the points corresponding to the
finite vertices of the triangulation.
<P>

</TD></TR>
        </TABLE>
<P>

        <TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Cell_circulator"></A>
<A NAME="Typedef_Cell_circulator"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Cell_circulator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Cell_circulator;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    circulator over all cells incident to a given edge
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Facet_circulator"></A>
<A NAME="Typedef_Facet_circulator"></A>
typedef <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>::Facet_circulator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Facet_circulator;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    circulator over all facets incident to a given edge
        </TD></TR>
        </TABLE>
<P>

The triangulation class also defines the following <A HREF="../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum">enum</A> type to specify
which case occurs when locating a point in the triangulation.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Function_Locate_type"></A>
<A NAME="Enum_Locate_type"></A>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="../Polyhedron_ref/Class_Polyhedron_incremental_builder_3#Enum_enum">enum</A> <A HREF="Class_Triangulation_3#Enum_Locate_type">Locate_type</A> { </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
    <A HREF="Class_Triangulation_3#Enum_Locate_type">VERTEX</A>=0<A NAME="Function_Locate_type"></A>
,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">EDGE</A><A NAME="Function_Locate_type"></A>
,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">FACET</A><A NAME="Function_Locate_type"></A>
,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">CELL</A><A NAME="Function_Locate_type"></A>
,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">OUTSIDE_CONVEX_HULL</A><A NAME="Function_Locate_type"></A>
,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">OUTSIDE_AFFINE_HULL</A><A NAME="Function_Locate_type"></A>
};</TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR>
<P>

</TABLE>
<P>

<H3>Creation</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>,<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>&gt; t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A> traits = <A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>());</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a triangulation <I>t</I> having only one vertex which is the
infinite vertex.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>,<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>&gt; t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A> tr);</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Copy constructor. All vertices and faces are duplicated.
<P>

</TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    template &lt; class InputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>,<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>&gt; t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator first,<BR>

InputIterator last,<BR>

<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A> traits = <A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>());</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a triangulation <I>t</I> constructed by the repeated insertion
of the iterator range <I>[first,last)</I> of value type <I>Point</I>.
<P>

</TD></TR>
        </TABLE>
<P>

<H3>Assignment</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A> &amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     t =  <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A> tr<A NAME="Function_Triangulation_3___operator=6const_Triangulation_3___tr9;"></A>

        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The triangulation <I>tr</I> is duplicated, and modifying the copy after the 
duplication does not modify the original. The previous triangulation held
by <I>t</I> is deleted.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_swap6Triangulation_3___tr9;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.swap ( <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A> &amp; tr)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The triangulations <I>tr</I> and <I>t</I> are swapped.
<I>t</I>.<I>swap(tr)</I> should be preferred to <I>t</I> = <I>tr</I> or to
<I>t(tr)</I> if <I>tr</I> is deleted after that. Indeed, there is no
copy of cells and vertices, thus this method runs in constant time.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_clear69;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.clear ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Deletes all finite vertices and all cells of <I>t</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_~Triangulation_369;"></A>
void ~
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.<A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A> ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Destructor. All vertices (including the infinite vertex) and cells are
deleted.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt; class GT, class Tds &gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
      <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;GT, Tds&gt; t1 ==  <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;GT, Tds&gt; t2<A NAME="Function_bool_operator==6const_Triangulation_36GT+_Tds9___t1+_const_Triangulation_36GT+_Tds9___t29;"></A>

        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Equality operator.  Returns true iff there exist a bijection between the
vertices of <I>t1</I> and those of <I>t2</I> and a bijection between the cells of
<I>t1</I> and those of <I>t2</I>, which preserve the geometry of the
triangulation, that is, the points of each corresponding pair of vertices are
equal, and the tetrahedra corresponding to each pair of cells are equal (up to
a permutation of their vertices).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt; class GT, class Tds &gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
      <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;GT, Tds&gt; t1 !=  <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;GT, Tds&gt; t2<A NAME="Function_bool_operator!=6const_Triangulation_36GT+_Tds9___t1+_const_Triangulation_36GT+_Tds9___t29;"></A>

        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The <A HREF="../Kernel_23_ref/Function_opposite.html#Cross_link_anchor_243">opposite</A> of <I>operator==</I>.
        </TD></TR>
        </TABLE>
<P>

<H3>Access Functions</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_const_TriangulationTraits_3___geom_traits69_const;"></A>
 <A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.geom_traits ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a const reference to the geometric traits object.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_const_TriangulationDataStructure_3___tds69_const;"></A>
 <A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.tds ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a const reference to the triangulation data structure.
        </TD></TR>
        </TABLE>
<P>

<BR>

<div class="AdvancedBlock">
  <table><tr><td valign="top">
  <img border="0" src="cc_advanced_begin1.gif" alt="begin of advanced section">
  </td><td valign="top">
  <em class="AdvancedBlockLabel">&nbsp;advanced&nbsp;</em>
  </td><td valign="top">
  <img border="0" src="cc_advanced_begin2.gif" alt="begin of advanced section">
  </td></tr></table>

<H3>Non const access</H3>
The responsibility of keeping a valid triangulation belongs to the user
when using advanced operations allowing a direct manipulation of the <I>tds</I>.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_TriangulationDataStructure_3___tds69;"></A>
<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A> &amp;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.tds ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a reference to the triangulation data structure.
        </TD></TR>
        </TABLE>
<P>

This method is mainly a help for users implementing their own triangulation
algorithms.
<P>

<table><tr><td valign="bottom">
  <img border="0" src="cc_advanced_end1.gif" alt="end of advanced section">
  </td><td valign="bottom">
  <em class="AdvancedBlockLabel">&nbsp;advanced&nbsp;</em>
  </td><td valign="bottom">
  <img border="0" src="cc_advanced_end2.gif" alt="end of advanced section">
  </td></tr></table></div>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_dimension69_const;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.dimension ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the dimension of the affine hull.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_size_type_number_of_vertices69_const;"></A>
size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.number_of_vertices ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the number of finite vertices.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_size_type_number_of_cells69_const;"></A>
size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.number_of_cells ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the number of cells or 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;3</I></MATH>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_infinite_vertex69;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.infinite_vertex ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the infinite vertex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Cell_handle_infinite_cell69_const;"></A>
Cell_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.infinite_cell ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a cell incident to the infinite vertex.
        </TD></TR>
        </TABLE>
<P>

<H3>Non-constant-time access functions</H3>
<P>

As previously said, the triangulation is a collection of cells that
are either infinite or represent a finite tetrahedra, where an
infinite cell is a 
cell incident to the infinite vertex. Similarly we call
an edge (resp. facet) <I>infinite</I> if it is incident to the infinite vertex.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_size_type_number_of_facets69_const;"></A>
size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.number_of_facets ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The number of facets. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;2</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_size_type_number_of_edges69_const;"></A>
size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.number_of_edges ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The number of edges. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;1</I></MATH>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_size_type_number_of_finite_cells69_const;"></A>
size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.number_of_finite_cells ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The number of finite cells. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;3</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_size_type_number_of_finite_facets69_const;"></A>
size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.number_of_finite_facets ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The number of finite facets. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;2</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_size_type_number_of_finite_edges69_const;"></A>
size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.number_of_finite_edges ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The number of finite edges. Returns 0 if <I>t</I>.<I>dimension()</I><MATH><I>&lt;1</I></MATH>.
        </TD></TR>
        </TABLE>
<P>

<H3>Geometric access functions</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Tetrahedron_tetrahedron6const_Cell_handle_c9_const;"></A>
Tetrahedron
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.tetrahedron ( const Cell_handle c)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the tetrahedron formed by the four vertices of <I>c</I>.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH> and the cell is finite.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Triangle_triangle6const_Cell_handle_c+_int_i9_const;"></A>
Triangle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.triangle ( const Cell_handle c,  int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the triangle formed by the three vertices of facet
<I>(c,i)</I>. The triangle is oriented so that its normal points to the
inside of cell <I>c</I>.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 2</I></MATH> and <MATH><I>i  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1,2,3}</I></MATH>
in dimension&nbsp;3, <MATH><I>i = 3</I></MATH> in dimension&nbsp;2, and the facet is finite.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Triangle_triangle6const_Facet___f9_const;"></A>
Triangle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.triangle (  Facet f)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Same as the previous method for facet <I>f</I>.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 2</I></MATH> and the facet is finite.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Segment_segment6const_Edge___e9_const;"></A>
Segment
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.segment (  Edge e)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the line segment formed by the vertices of <I>e</I>.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 1</I></MATH> and <I>e</I> is finite.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Segment_segment6const_Cell_handle_c+_int_i+_int_j9_const;"></A>
Segment
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.segment ( const Cell_handle c,  int i,  int j)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Same as the previous method for edge <I>(c,i,j)</I>.<BR>

<EM>Precondition: </EM>As above and <MATH><I>i <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC="cc_neq.gif"> j</I></MATH>. Moreover <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1,2,3}</I></MATH> in
dimension&nbsp;3, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1,2}</I></MATH> in dimension&nbsp;2, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1}</I></MATH> in 
dimension&nbsp;1.
        </TD></TR>
        </TABLE>
<P>

<H3>Tests for Finite and Infinite Vertices and Faces</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_infinite6const_Vertex_handle_v9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_infinite ( const Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <I>true</I>, iff vertex <I>v</I> is the infinite vertex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_infinite6const_Cell_handle_c9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_infinite ( const Cell_handle c)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <I>true</I>, iff <I>c</I> is incident to the infinite vertex.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_infinite6const_Cell_handle_c+_int_i9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_infinite ( const Cell_handle c,  int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <I>true</I>, iff the facet <I>i</I> of cell <I>c</I> is incident to the
infinite vertex.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 2</I></MATH> and <MATH><I>i <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1,2,3}</I></MATH> in
dimension&nbsp;3, <MATH><I>i=3</I></MATH> in dimension&nbsp;2.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_infinite6const_Facet___f9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_infinite (  Facet f)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <I>true</I> iff facet <I>f</I> is incident to the infinite vertex.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 2</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_infinite6const_Cell_handle_c+_int_i+_int_j9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_infinite ( const Cell_handle c,  int i,  int j)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <I>true</I>, iff the edge <I>(i,j)</I> of cell <I>c</I> is incident to
the infinite vertex.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 1</I></MATH> and <MATH><I>i <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC="cc_neq.gif"> j</I></MATH>. Moreover
<MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1,2,3}</I></MATH> in dimension&nbsp;3, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1,2}</I></MATH> in dimension
2, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1}</I></MATH> in  dimension&nbsp;1.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_infinite6const_Edge___e9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_infinite (  Edge e)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <I>true</I> iff edge <I>e</I> is incident to the infinite vertex.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 1</I></MATH>.
        </TD></TR>
        </TABLE>
<P>

<H3>Queries</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_vertex6const_Point___p+_Vertex_handle___v9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_vertex (  Point p,  Vertex_handle &amp; v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Tests whether <I>p</I> is a vertex of <I>t</I> by locating <I>p</I> in
the triangulation. If <I>p</I> is found, the associated vertex <I>v</I>
is given.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_vertex6Vertex_handle_v9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_vertex ( Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Tests whether <I>v</I> is a vertex of <I>t</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_edge6Vertex_handle_u+_Vertex_handle_v+_Cell_handle___c+_int___i+_int___j9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.is_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_handle u,<BR>

Vertex_handle v,<BR>

Cell_handle &amp; c,<BR>

int &amp; i,<BR>

int &amp; j)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Tests whether <I>(u,v)</I> is an edge of <I>t</I>. If the edge is found,
it gives a cell <I>c</I> having this edge and the indices <I>i</I>
and <I>j</I> of the vertices <I>u</I> and <I>v</I> in <I>c</I>, in this order.<BR>

<EM>Precondition: </EM><I>u</I> and <I>v</I> are vertices of <I>t</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_facet6Vertex_handle_u+_Vertex_handle_v+_Vertex_handle_w+_Cell_handle___c+_int___i+_int___j+_int___k9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.is_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_handle u,<BR>

Vertex_handle v,<BR>

Vertex_handle w,<BR>

Cell_handle &amp; c,<BR>

int &amp; i,<BR>

int &amp; j,<BR>

int &amp; k)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Tests whether <I>(u,v,w)</I> is a facet of <I>t</I>. If the facet is found,
it computes a cell <I>c</I> having this facet and the indices <I>i</I>,
<I>j</I> and <I>k</I> of the vertices <I>u</I>, <I>v</I> and <I>w</I> in <I>c</I>, 
in this order.<BR>

<EM>Precondition: </EM><I>u</I>, <I>v</I> and <I>w</I> are vertices of <I>t</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_cell6Cell_handle_c9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_cell ( Cell_handle c)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Tests whether <I>c</I> is a cell of <I>t</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_cell6Vertex_handle_u+_Vertex_handle_v+_Vertex_handle_w+_Vertex_handle_x+_Cell_handle___c+_int___i+_int___j+_int___k+_int___l9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.is_cell ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_handle u,<BR>

Vertex_handle v,<BR>

Vertex_handle w,<BR>

Vertex_handle x,<BR>

Cell_handle &amp; c,<BR>

int &amp; i,<BR>

int &amp; j,<BR>

int &amp; k,<BR>

int &amp; l)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Tests whether <I>(u,v,w,x)</I> is a cell of <I>t</I>. 
If the cell <I>c</I> is found, the method
computes the indices <I>i</I>, <I>j</I>, <I>k</I> and <I>l</I> of the
vertices <I>u</I>, <I>v</I>, <I>w</I> and <I>x</I> in <I>c</I>, in this
order.<BR>

<EM>Precondition: </EM><I>u</I>, <I>v</I>, <I>w</I> and <I>x</I> are vertices of <I>t</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_cell6Vertex_handle_u+_Vertex_handle_v+_Vertex_handle_w+_Vertex_handle_x+_Cell_handle___c9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.is_cell ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_handle u,<BR>

Vertex_handle v,<BR>

Vertex_handle w,<BR>

Vertex_handle x,<BR>

Cell_handle &amp; c)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Tests whether <I>(u,v,w,x)</I> is a cell of <I>t</I> and computes 
this cell <I>c</I>.<BR>

<EM>Precondition: </EM><I>u</I>, <I>v</I>, <I>w</I> and <I>x</I> are vertices of <I>t</I>.
        </TD></TR>
        </TABLE>
<P>

There is a method <I>has_vertex</I> in the cell class. The analogous
methods for facets are defined here.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_has_vertex6const_Facet___f+_Vertex_handle_v+_int___j9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.has_vertex (  Facet f,  Vertex_handle v,  int &amp; j)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    If <I>v</I> is a vertex of <I>f</I>, then <I>j</I> is the index of
<I>v</I> in the cell <I>f.first</I>, and the method returns <I>true</I>.<BR>

<EM>Precondition: </EM><I>t</I>.dimension()=3
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_has_vertex6Cell_handle_c+_int_i+_Vertex_handle_v+_int___j9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.has_vertex ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Cell_handle c,<BR>

int i,<BR>

Vertex_handle v,<BR>

int &amp; j)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Same for facet <I>(c,i)</I>. Computes the index <I>j</I> of <I>v</I> in
<I>c</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_has_vertex6const_Facet___f+_Vertex_handle_v9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.has_vertex (  Facet f,  Vertex_handle v)
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_has_vertex6Cell_handle_c+_int_i+_Vertex_handle_v9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.has_vertex ( Cell_handle c,  int i,  Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Same as the first two methods, but these two methods do not return the
index of the vertex.
        </TD></TR>
        </TABLE>
<P>

The following three methods test whether two facets have the same
vertices.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_are_equal6Cell_handle_c+_int_i+_Cell_handle_n+_int_j9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.are_equal ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Cell_handle c,<BR>

int i,<BR>

Cell_handle n,<BR>

int j)</I></TD></TR></TABLE>
    
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_are_equal6const_Facet___f+_const_Facet___g9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.are_equal (  Facet f,  Facet g)
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_are_equal6const_Facet___f+_Cell_handle_n+_int_j9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.are_equal (  Facet f,  Cell_handle n,  int j)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    For these three methods:<BR>

<EM>Precondition: </EM><I>t</I>.dimension()=3.
        </TD></TR>
        </TABLE>
<P>

<H3>Point location</H3>
<P>

The class <I><A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A>&lt;<A HREF="Concept_TriangulationTraits_3.html#Cross_link_anchor_979">TriangulationTraits_3</A>,<A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A>&gt;</I>  provides two functions to locate
a given point with respect to a triangulation. It provides
also functions to test if a given point is inside a finite face
or not.  Note that the class <I><A HREF="Class_Delaunay_triangulation_3.html#Cross_link_anchor_974">Delaunay_triangulation_3</A></I> also
provides a <I>nearest_vertex()</I> function.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Cell_handle_locate6const_Point___query+_Cell_handle_start_=_Cell_handle699_const;"></A>
Cell_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.locate ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point query,<BR>

Cell_handle start = Cell_handle())</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    If the point <I>query</I> lies inside the convex hull of the points, the cell 
that contains the query in its interior is returned. If <I>query</I> lies on a
facet, an edge or on a vertex, one of the cells having <I>query</I> on
its boundary is returned.<BR>

If the point <I>query</I> lies outside the convex hull of the points,
an infinite cell with vertices <MATH><I>{ p, q, r,  <IMG BORDER=0 WIDTH=15 HEIGHT=8 ALIGN=BOTTOM SRC="cc_infty.gif"> }</I></MATH> is returned such that
the tetrahedron <MATH><I>( p, q, r, query )</I></MATH> is positively oriented
(the rest of the triangulation lies on the other side of facet 
<MATH><I>( p, q, r )</I></MATH>).<BR>

Note that locate works even in degenerate dimensions: in dimension 2
(resp. 1, 0) the <I>Cell_handle</I> returned is the one that represents
the facet (resp. edge, vertex) containing the query point.<BR>

The optional argument <I>start</I> is used as a starting place for the search.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Cell_handle_locate6const_Point___query+_Locate_type___lt+_int___li+_int___lj+_Cell_handle_start_=_Cell_handle69_9_const;"></A>
Cell_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.locate ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point query,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">Locate_type</A> &amp; lt,<BR>

int &amp; li,<BR>

int &amp; lj,<BR>

Cell_handle start = Cell_handle())</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    If <I>query</I> lies inside the affine hull of the points, the <MATH><I>k</I></MATH>-face
(finite or infinite) that contains <I>query</I> in its interior is
returned, by means of the cell returned together with <I>lt</I>, which
is set to the locate type of the query (<I><A HREF="Class_Triangulation_3#Enum_Locate_type">VERTEX</A>, <A HREF="Class_Triangulation_3#Enum_Locate_type">EDGE</A>, <A HREF="Class_Triangulation_3#Enum_Locate_type">FACET</A>, <A HREF="Class_Triangulation_3#Enum_Locate_type">CELL</A></I>, or <I><A HREF="Class_Triangulation_3#Enum_Locate_type">OUTSIDE_CONVEX_HULL</A></I> if the cell is infinite and <I>query</I>
lies strictly in it) and two indices <I>li</I> and <I>lj</I> that
specify the <MATH><I>k</I></MATH>-face of the cell containing <I>query</I>.<BR>

If the <MATH><I>k</I></MATH>-face is a cell, <I>li</I> and <I>lj</I> have no
meaning; if it is a facet (resp. vertex), <I>li</I> gives the index of
the facet (resp. vertex) and <I>lj</I> has no meaning; if it is and
edge, <I>li</I> and <I>lj</I> give the indices of its vertices.<BR>

If the point <I>query</I> lies outside the affine hull of the points,
which can happen in case of degenerate dimensions, <I>lt</I> is set to
<I><A HREF="Class_Triangulation_3#Enum_Locate_type">OUTSIDE_AFFINE_HULL</A></I>, and the cell returned has no meaning.
As a particular case, if there is no finite vertex yet in the
triangulation, <I>lt</I> is set to <I><A HREF="Class_Triangulation_3#Enum_Locate_type">OUTSIDE_AFFINE_HULL</A></I> and
<I>locate</I> returns the default constructed handle.<BR>

The optional argument <I>start</I> is used as a starting place for the search.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Bounded_side_side_of_cell6const_Point___p+_Cell_handle_c+_Locate_type___lt+_int___li+_int___lj9_const;"></A>
<A HREF="../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99">Bounded_side</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.side_of_cell ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p,<BR>

Cell_handle c,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">Locate_type</A> &amp; lt,<BR>

int &amp; li,<BR>

int &amp; lj)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a value indicating on which side of the oriented boundary
of <I>c</I> the point <I>p</I> lies. More precisely, it returns:<BR>

- <I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_BOUNDED_SIDE</A></I> if <I>p</I> is inside the cell. For an infinite
cell this means that <I>p</I> lies strictly in the half space limited by
its finite facet and not containing any other point of the triangulation.<BR>

- <I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_BOUNDARY</A></I> if p on the boundary of the cell. For an infinite
cell this means that <I>p</I> lies on the <I>finite</I> facet. Then
<I>lt</I> together with <I>li</I> and <I>lj</I> give the precise location
on the boundary. (See the descriptions of the <I>locate</I> methods.)<BR>

- <I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_UNBOUNDED_SIDE</A></I> if <I>p</I> lies outside the cell. For an
infinite cell this means that <I>p</I> does not satisfy either of the
two previous conditions.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH>
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Bounded_side_side_of_facet6const_Point___p+_const_Facet___f+_Locate_type___lt+_int___li+_int___lj9_const;"></A>
<A HREF="../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99">Bounded_side</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.side_of_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p,<BR>

Facet f,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">Locate_type</A> &amp; lt,<BR>

int &amp; li,<BR>

int &amp; lj)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a value indicating on which side of the oriented boundary
of <I>f</I> the point <I>p</I> lies:<BR>

- <I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_BOUNDED_SIDE</A></I> if <I>p</I> is inside the facet. For an
infinite facet this means that <I>p</I> lies strictly in the half plane
limited by its finite edge and not containing any other point of the
triangulation .<BR>

- <I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_BOUNDARY</A></I> if <I>p</I> is on the boundary of the facet.
For an infinite facet this means that <I>p</I> lies on the finite
edge. <I>lt</I>, <I>li</I> and <I>lj</I> give the precise location of
<I>p</I> on the boundary of the facet. <I>li</I> and <I>lj</I> refer to
indices in the degenerate cell <I>c</I> representing <I>f</I>.<BR>

- <I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_UNBOUNDED_SIDE</A></I> if <I>p</I> lies outside the facet. For
an infinite facet this means that <I>p</I> does not satisfy either of
the two previous conditions.<BR>

<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=2</I></MATH> and <I>p</I> lies in the
plane containing the triangulation. <I>f.second</I> <MATH><I>=3</I></MATH> (in dimension&nbsp;2 
there is only one facet per cell).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Bounded_side_side_of_facet6const_Point___p+_Cell_handle_c+_Locate_type___lt+_int___li+_int___lj9_const;"></A>
<A HREF="../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99">Bounded_side</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.side_of_facet ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p,<BR>

Cell_handle c,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">Locate_type</A> &amp; lt,<BR>

int &amp; li,<BR>

int &amp; lj)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Same as the previous method for the facet <I>(c,3)</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Bounded_side_side_of_edge6const_Point___p+_const_Edge___e+_Locate_type___lt+_int___li9_const;"></A>
<A HREF="../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99">Bounded_side</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.side_of_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p,<BR>

Edge e,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">Locate_type</A> &amp; lt,<BR>

int &amp; li)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a value indicating on which side of the oriented boundary
of <I>e</I> the point <I>p</I> lies:<BR>

- <I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_BOUNDED_SIDE</A></I> if <I>p</I> is inside the edge. For an
infinite edge this means that <I>p</I> lies in the half line defined by
the vertex and not containing any other point of the triangulation.<BR>

- <I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_BOUNDARY</A></I> if <I>p</I> equals one of the vertices,
<I>li</I> give the index of the vertex in the cell storing <I>e</I><BR>

- <I><A HREF="../Kernel_23_ref/Enum_Bounded_side#Enum_Bounded_side">ON_UNBOUNDED_SIDE</A></I> if <I>p</I> lies outside the edge. For
an infinite edge this means that <I>p</I> lies on the other half line,
which contains the other points of the triangulation.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=1</I></MATH> and <I>p</I> is <A HREF="../Kernel_23_ref/Function_collinear.html#Cross_link_anchor_167">collinear</A>
with the points of the triangulation. <I>e.second</I> <MATH><I>=0</I></MATH> and
<I>e.third</I> <MATH><I>=1</I></MATH> (in dimension&nbsp;1 there is only one edge per cell).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Bounded_side_side_of_edge6const_Point___p+_Cell_handle_c+_Locate_type___lt+_int___li9_const;"></A>
<A HREF="../Kernel_23_ref/Enum_Bounded_side.html#Cross_link_anchor_99">Bounded_side</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.side_of_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p,<BR>

Cell_handle c,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">Locate_type</A> &amp; lt,<BR>

int &amp; li)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Same as the previous method for edge <MATH><I>(c,0,1)</I></MATH>.
        </TD></TR>
        </TABLE>
<P>

<H3>Flips</H3>
<P>

Two kinds of flips exist for a three-dimensional triangulation. They
are reciprocal. To be flipped, an edge must be incident to three
tetrahedra. During the flip, these three tetrahedra disappear and two
tetrahedra appear. Figure&nbsp;<A HREF="Class_Triangulation_3.html#Triangulation3-fig-flips"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference" WIDTH="10" HEIGHT="10"></A>(left) shows the
edge that is flipped as bold dashed, and one of its three incident
facets is shaded. On the right, the facet shared by the two new
tetrahedra is shaded.
<P>

Flips are possible only under the following conditions:<BR>

- the edge or facet to be flipped is not on the boundary of the convex
hull of the triangulation<BR>

- the five points involved are in convex position.
<P>

<B>Figure:&nbsp;&nbsp;</B>Flips.
<A NAME="Triangulation3-fig-flips"></A>

<CENTER>
<img border=0 src="./flips.gif" align=center
alt="Flips">
</CENTER>
<P>

The following methods guarantee the validity of the resulting 3D
triangulation.
<P>

<I>Flips for a 2d triangulation are not implemented yet</I>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_flip6Edge_e9;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.flip ( Edge e)
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_flip6Cell_handle_c+_int_i+_int_j9;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.flip ( Cell_handle c,  int i,  int j)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Before flipping, these methods check that edge <I>e=(c,i,j)</I> is
flippable (which is quite expensive). They return <I>false</I> or
<I>true</I> according to this test.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_flip_flippable6Edge_e9;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.flip_flippable ( Edge e)
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_flip_flippable6Cell_handle_c+_int_i+_int_j9;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.flip_flippable ( Cell_handle c,  int i,  int j)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Should be preferred to the previous methods when the edge is
known to be flippable.<BR>

<EM>Precondition: </EM>The edge is flippable.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_flip6Facet_f9;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.flip ( Facet f)
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_flip6Cell_handle_c+_int_i9;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.flip ( Cell_handle c,  int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Before flipping, these methods check that facet <I>f=(c,i)</I> is
flippable (which is quite expensive). They return <I>false</I> or
<I>true</I> according to this test.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_flip_flippable6Facet_f9;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.flip_flippable ( Facet f)
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_void_flip_flippable6Cell_handle_c+_int_i9;"></A>
void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.flip_flippable ( Cell_handle c,  int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Should be preferred to the previous methods when the facet is
known to be flippable.<BR>

<EM>Precondition: </EM>The facet is flippable.
        </TD></TR>
        </TABLE>
<P>

<H3>Insertions</H3>
<P>

The following operations are guaranteed to lead to a valid triangulation 
when they are applied on a valid triangulation.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert6const_Point___p+_Cell_handle_start_=_Cell_handle69_9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.insert (  Point p,  Cell_handle start = Cell_handle())
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts point <I>p</I> in the triangulation and returns the corresponding
 vertex.<BR>

If point <I>p</I> coincides with an already existing vertex, this 
vertex is returned and the triangulation remains unchanged.<BR>

If point <I>p</I> lies in the convex hull of the points, it is added
naturally: if it lies inside a cell, the cell is split into four
cells, if it lies on a facet, the two incident cells are split into
three cells, if it lies on an edge, all the cells incident to this
edge are split into two cells.<BR>

If point <I>p</I> is strictly outside the convex hull but in the affine
hull, <I>p</I> is linked to all visible points on the convex hull to
form the new triangulation. See
Figure&nbsp;<A HREF="Class_Triangulation_3.html#Triangulation3-fig-insert_outside_convex_hull"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference" WIDTH="10" HEIGHT="10"></A>.<BR>

If point <I>p</I> is outside the affine hull of the points, <I>p</I> is
linked to all the points, and the dimension of the triangulation is
incremented. All the points now belong to the boundary of the convex
hull, so, the infinite vertex is linked to all the points to
triangulate the new infinite face. See 
Figure&nbsp;<A HREF="Class_Triangulation_3.html#Triangulation3-fig-insert_outside_affine_hull"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference" WIDTH="10" HEIGHT="10"></A>.
The optional argument <I>start</I> is used as a starting place for the search.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert6const_Point___p+_Locate_type_lt+_Cell_handle_loc+_int_li+_int_lj9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p,<BR>

<A HREF="Class_Triangulation_3#Enum_Locate_type">Locate_type</A> lt,<BR>

Cell_handle loc,<BR>

int li,<BR>

int lj)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts point <I>p</I> in the triangulation and returns the corresponding
 vertex. Similar to the above <I>insert()</I> function, but takes as additional
 parameter the return values of a previous location query.  See description of
 <I>locate()</I> above.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt; class InputIterator &gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_int_insert6InputIterator_first+_InputIterator_last9;"></A>
int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.insert ( InputIterator first,  InputIterator last)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the points in the range <MATH><I>[.</I></MATH><I>first</I>,
<I>last</I><MATH><I>.)</I></MATH>.  Returns the number of inserted points.<BR>

<EM>Precondition: </EM>The <I>value_type</I> of <I>first</I> and <I>last</I> is
<I>Point</I>.
        </TD></TR>
        </TABLE>
<P>

The previous methods are sufficient to build a whole triangulation. We
also provide some other methods that can be used instead of
<I>insert(p)</I> when the place where the new point <I>p</I> must be inserted
is already known. They are also guaranteed to lead to a valid
triangulation when they are applied on a valid triangulation.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert_in_cell6const_Point___p+_Cell_handle_c9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.insert_in_cell (  Point p,  Cell_handle c)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts point <I>p</I> in cell <I>c</I>. Cell <I>c</I> is split into 4
tetrahedra.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH> and <I>p</I> lies strictly
inside cell <I>c</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert_in_facet6const_Point___p+_const_Facet___f9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.insert_in_facet (  Point p,  Facet f)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts point <I>p</I> in facet <I>f</I>. In dimension&nbsp;3, the 2
neighboring cells are split into 3 tetrahedra; in dimension&nbsp;2, the facet 
is split into 3 triangles.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 2</I></MATH> and <I>p</I> lies strictly
inside face <I>f</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert_in_facet6const_Point___p+_Cell_handle_c+_int_i9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.insert_in_facet (  Point p,  Cell_handle c,  int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    As above, insertion in facet <I>(c,i)</I>.<BR>

<EM>Precondition: </EM>As above and <MATH><I>i  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1,2,3}</I></MATH> in dimension&nbsp;3, <MATH><I>i = 3</I></MATH> in
dimension&nbsp;2.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert_in_edge6const_Point___p+_const_Edge___e9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.insert_in_edge (  Point p,  Edge e)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts <I>p</I> in edge <I>e</I>. In dimension&nbsp;3, 
all the cells having this edge are split into 2 tetrahedra; in
dimension&nbsp;2, the 2 neighboring facets are split into 2 triangles; in
dimension&nbsp;1, the edge is split into 2 edges.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 1</I></MATH> and <I>p</I> lies on edge
<I>e</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert_in_edge6Point_p+_Cell_handle_c+_int_i+_int_j9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.insert_in_edge ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Point p,<BR>

Cell_handle c,<BR>

int i,<BR>

int j)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    As above, inserts <I>p</I> in edge <MATH><I>(<I>i</I>, <I>j</I>)</I></MATH> of <I>c</I>.<BR>

<EM>Precondition: </EM>As above and <MATH><I>i <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC="cc_neq.gif"> j</I></MATH>. Moreover <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1,2,3}</I></MATH> in
dimension&nbsp;3, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1,2}</I></MATH> in dimension&nbsp;2, <MATH><I>i,j  <IMG BORDER=0 WIDTH=9 HEIGHT=21 ALIGN=MIDDLE SRC="cc_in.gif"> {0,1}</I></MATH> in 
dimension&nbsp;1.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert_outside_convex_hull6const_Point___p+_Cell_handle_c9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.insert_outside_convex_hull (  Point p,  Cell_handle c)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The cell <I>c</I> must be an infinite cell containing <I>p</I>.<BR>

Links <I>p</I> to all  points in the triangulation that are visible from
<I>p</I>. Updates consequently the infinite faces. See
Figure&nbsp;<A HREF="Class_Triangulation_3.html#Triangulation3-fig-insert_outside_convex_hull"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference" WIDTH="10" HEIGHT="10"></A>.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>&gt;0</I></MATH>, <I>c</I>, and the <MATH><I>k</I></MATH>-face
represented by <I>c</I> is infinite and contains <I>t</I>.
        </TD></TR>
        </TABLE>
<P>

<B>Figure:&nbsp;&nbsp;</B><I>insert_outside_convex_hull</I> (2-dimensional case).
<A NAME="Triangulation3-fig-insert_outside_convex_hull"></A>

<CENTER>
<img border=0 src="./insert_outside_convex_hull.gif" align=center 
alt="insert_outside_convex_hull} (2-dimensional case)">
</CENTER>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert_outside_affine_hull6const_Point___p9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.insert_outside_affine_hull (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <I>p</I> is linked to all the points, and the infinite vertex is linked
to all the points (including <I>p</I>) to triangulate the new infinite
face, so that all the points now belong to the boundary of the convex
hull. See Figure&nbsp;<A HREF="Class_Triangulation_3.html#Triangulation3-fig-insert_outside_affine_hull"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference" WIDTH="10" HEIGHT="10"></A>.<BR>

This method can be used to insert the first point in an empty
triangulation.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>&lt;3</I></MATH> and <I>p</I> lies outside the
affine hull of the points.
        </TD></TR>
        </TABLE>
<P>

<B>Figure:&nbsp;&nbsp;</B><I>insert_outside_affine_hull</I> (2-dimensional case).
<A NAME="Triangulation3-fig-insert_outside_affine_hull"></A>

<CENTER>
<img border=0 src="./insert_outside_affine_hull.gif" align=center
alt="insert_outside_affine_hull} (2-dimensional case)">
</CENTER>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class CellIt&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Vertex_handle_insert_in_hole6Point_p+_CellIt_cell_begin+_CellIt_cell_end+_Cell_handle_begin+_int_i9;"></A>
Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.insert_in_hole ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Point p,<BR>

CellIt cell_begin,<BR>

CellIt cell_end,<BR>

Cell_handle begin,<BR>

int i)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Creates a new vertex by starring a hole.  It takes an iterator range
[<I>cell_begin</I>; <I>cell_end</I>[ of <I>Cell_handle</I>s which specifies
a hole: a set of connected cells (resp. facets in dimension 2) which is
star-shaped wrt <I>p</I>.
(<I>begin</I>, <I>i</I>) is a facet (resp. an edge) on the boundary of the hole,
that is, <I>begin</I> belongs to the set of cells (resp.  facets) previously
described, and <I>begin-&gt;neighbor(i)</I> does not.  Then this function deletes
all the cells (resp. facets) describing the hole, creates a new vertex
<I>v</I>, and for each facet (resp. edge) on the boundary of the hole, creates
a new cell (resp. facet) with <I>v</I> as vertex.  Then <I>v-&gt;set_point(p)</I>
is called and <I>v</I> is returned.<BR>

This operation is equivalent to calling
<I>tds().insert_in_hole(cell_begin, cell_end, begin, i); v-&gt;set_point(p)</I>.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif"> 2</I></MATH>, the set of cells (resp. facets in
dimension 2) is connected, its boundary is connected, and <I>p</I> lies inside
the hole, which is star-shaped wrt <I>p</I>.
        </TD></TR>
        </TABLE>
<P>

<H3>Traversal of the Triangulation</H3>
<P>

The triangulation class provides several iterators and circulators
that allow one to traverse it (completely or partially).
<P>

<H3>Cell, Face, Edge and Vertex Iterators</H3>
<P>

The following iterators allow the user to visit cells,
facets, edges and vertices of the
triangulation. These iterators are non-mutable, bidirectional and
their value types are respectively <I>Cell</I>, <I>Facet</I>, <I>Edge</I>
and <I>Vertex</I>. They are all invalidated by any change in the
triangulation.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Finite_vertices_iterator_finite_vertices_begin69_const;"></A>
Finite_vertices_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.finite_vertices_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary finite vertex. Then <I>++</I> and <I>--</I> will
iterate over finite vertices. Returns <I>finite_vertices_end()</I> when
<I>t</I>.<I>number_of_vertices()</I> <MATH><I>=0</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Finite_vertices_iterator_finite_vertices_end69_const;"></A>
Finite_vertices_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.finite_vertices_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Past-the-end iterator
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Finite_edges_iterator_finite_edges_begin69_const;"></A>
Finite_edges_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.finite_edges_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary finite edge. Then <I>++</I> and <I>--</I> will
iterate over finite edges. Returns <I>finite_edges_end()</I> when
<I>t</I>.<I>dimension()</I> <MATH><I>&lt;1</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Finite_edges_iterator_finite_edges_end69_const;"></A>
Finite_edges_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.finite_edges_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Past-the-end iterator
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Finite_facets_iterator_finite_facets_begin69_const;"></A>
Finite_facets_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.finite_facets_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary finite facet. Then <I>++</I> and <I>--</I> will
iterate over finite facets. Returns <I>finite_facets_end()</I> when
<I>t</I>.<I>dimension()</I> <MATH><I>&lt;2</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Finite_facets_iterator_finite_facets_end69_const;"></A>
Finite_facets_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.finite_facets_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Past-the-end iterator
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Finite_cells_iterator_finite_cells_begin69_const;"></A>
Finite_cells_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.finite_cells_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary finite cell. Then <I>++</I> and <I>--</I> will
iterate over finite cells. Returns <I>finite_cells_end()</I> when
<I>t</I>.<I>dimension()</I> <MATH><I>&lt;3</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_Finite_cells_iterator_finite_cells_end69_const;"></A>
Finite_cells_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.finite_cells_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Past-the-end iterator
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_All_vertices_iterator_all_vertices_begin69_const;"></A>
All_vertices_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.all_vertices_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary vertex. Iterates over all vertices (even the infinite
one). Returns <I>vertices_end()</I> when
<I>t</I>.<I>number_of_vertices()</I> <MATH><I>=0</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_All_vertices_iterator_all_vertices_end69_const;"></A>
All_vertices_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.all_vertices_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Past-the-end iterator
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_All_edges_iterator_all_edges_begin69_const;"></A>
All_edges_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.all_edges_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary edge. Iterates over all edges (even infinite
ones). Returns <I>edges_end()</I> when <I>t</I>.<I>dimension()</I> <MATH><I>&lt;1</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_All_edges_iterator_all_edges_end69_const;"></A>
All_edges_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.all_edges_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Past-the-end iterator
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_All_facets_iterator_all_facets_begin69_const;"></A>
All_facets_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.all_facets_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary facet. Iterates over all facets (even infinite
ones). Returns <I>facets_end()</I> when 
<I>t</I>.<I>dimension()</I> <MATH><I>&lt;2</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_All_facets_iterator_all_facets_end69_const;"></A>
All_facets_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.all_facets_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Past-the-end iterator
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_All_cells_iterator_all_cells_begin69_const;"></A>
All_cells_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.all_cells_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary cell. Iterates over all cells (even infinite
ones). Returns <I>cells_end()</I> when 
<I>t</I>.<I>dimension()</I> <MATH><I>&lt;3</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_All_cells_iterator_all_cells_end69_const;"></A>
All_cells_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.all_cells_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Past-the-end iterator
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Point_iterator_points_begin69_const;"></A>
Point_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.points_begin ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Iterates over the points of the triangulation.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Point_iterator_points_end69_const;"></A>
Point_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    t.points_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Past-the-end iterator
        </TD></TR>
        </TABLE>
<P>

<H3>Cell and Facet Circulators</H3>
<P>

The following circulators respectively visit all cells or all facets
incident to a given edge. They are non-mutable and bidirectional. They
are invalidated by any modification of one of the cells traversed.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Cell_circulator_incident_cells6Edge_e9_const;"></A>
Cell_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.incident_cells ( Edge e)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary cell incident to <I>e</I>.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Cell_circulator_incident_cells6Cell_handle_c+_int_i+_int_j9_const;"></A>
Cell_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.incident_cells ( Cell_handle c,  int i,  int j)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    As above for edge <I>(i,j)</I> of <I>c</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Cell_circulator_incident_cells6Edge_e+_Cell_handle_start9_const;"></A>
Cell_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.incident_cells ( Edge e,  Cell_handle start)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at cell <I>start</I>.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I> <MATH><I>=3</I></MATH> and <I>start</I> is incident to
<I>e</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Cell_circulator_incident_cells6Cell_handle_c+_int_i+_int_j+_Cell_handle_start9_const;"></A>
Cell_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.incident_cells ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Cell_handle c,<BR>

int i,<BR>

int j,<BR>

Cell_handle start)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    As above for edge <I>(i,j)</I> of <I>c</I>.
        </TD></TR>
        </TABLE>
<P>

The following circulators on facets are defined only in dimension&nbsp;3,
though facets are defined also in dimension&nbsp;2: there are only two
facets sharing an edge in dimension&nbsp;2.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Facet_circulator_incident_facets6Edge_e9_const;"></A>
Facet_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.incident_facets ( Edge e)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at an arbitrary facet incident to <I>e</I>.<BR>

<EM>Precondition: </EM><I>t</I>.<I>dimension()</I>&nbsp;<MATH><I>=3</I></MATH>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Facet_circulator_incident_facets6Cell_handle_c+_int_i+_int_j9_const;"></A>
Facet_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.incident_facets ( Cell_handle c,  int i,  int j)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    As above for edge <I>(i,j)</I> of <I>c</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Facet_circulator_incident_facets6Edge_e+_Facet_start9_const;"></A>
Facet_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.incident_facets ( Edge e,  Facet start)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at facet <I>start</I>.<BR>

<EM>Precondition: </EM><I>start</I> is incident to <I>e</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Facet_circulator_incident_facets6Edge_e+_Cell_handle_start+_int_f9_const;"></A>
Facet_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.incident_facets ( Edge e,  Cell_handle start,  int f)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Starts at facet of index <I>f</I> in <I>start</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Facet_circulator_incident_facets6Cell_handle_c+_int_i+_int_j+_Facet_start9_const;"></A>
Facet_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.incident_facets ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Cell_handle c,<BR>

int i,<BR>

int j,<BR>

Facet start)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    As above for edge <I>(i,j)</I> of <I>c</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Facet_circulator_incident_facets6Cell_handle_c+_int_i+_int_j+_Cell_handle_start+_int_f9_const;"></A>
Facet_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.incident_facets ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Cell_handle c,<BR>

int i,<BR>

int j,<BR>

Cell_handle start,<BR>

int f)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    As above for edge <I>(i,j)</I> of <I>c</I> and facet <I>(start,f)</I>.
        </TD></TR>
        </TABLE>
<P>

<H3>Traversal of the incident cells and the adjacent vertices
of a given vertex</H3>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_incident_cells6Vertex_handle_v+_OutputIterator_cells9_const;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.incident_cells ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_handle v,<BR>

OutputIterator cells)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Copies the <I>Cell_handle</I>s of all cells incident to <I>v</I> to the output
iterator <I>cells</I>.  If <I>t</I>.<I>dimension()</I> <MATH><I>&lt;3</I></MATH>, then do nothing.
Returns the resulting output iterator.<BR>

<EM>Precondition: </EM><I>v</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC="cc_neq.gif"> </I></MATH> <I>Vertex_handle()</I>, <I>t</I>.<I>is_vertex(v)</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_incident_vertices6Vertex_handle_v+_OutputIterator_vertices9_const;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    t.incident_vertices ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_handle v,<BR>

OutputIterator vertices)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Copies the <I>Vertex_handle</I>s of all vertices incident to <I>v</I> to the
output iterator <I>vertices</I>.  If <I>t</I>.<I>dimension()</I> <MATH><I>&lt;2</I></MATH>, then do
nothing.  Returns the resulting output iterator.<BR>

<EM>Precondition: </EM><I>v</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC="cc_neq.gif"> </I></MATH> <I>Vertex_handle()</I>, <I>t</I>.<I>is_vertex(v)</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_size_type_degree6Vertex_handle_v9_const;"></A>
size_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.degree ( Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the degree of a vertex, that is, the number of incident vertices.
The infinite vertex is counted.<BR>

<EM>Precondition: </EM><I>v</I> <MATH><I> <IMG BORDER=0 WIDTH=11 HEIGHT=27 ALIGN=MIDDLE SRC="cc_neq.gif"> </I></MATH> <I>Vertex_handle()</I>, <I>t</I>.<I>is_vertex(v)</I>.
        </TD></TR>
        </TABLE>
<P>

<BR>

<div class="AdvancedBlock">
  <table><tr><td valign="top">
  <img border="0" src="cc_advanced_begin1.gif" alt="begin of advanced section">
  </td><td valign="top">
  <em class="AdvancedBlockLabel">&nbsp;advanced&nbsp;</em>
  </td><td valign="top">
  <img border="0" src="cc_advanced_begin2.gif" alt="begin of advanced section">
  </td></tr></table>

<H3>Checking</H3>
The responsibility of keeping a valid triangulation belongs to the user
when using advanced operations allowing a direct manipulation of cells
and vertices. We provide the user with the following methods to help
debugging.
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_valid6bool_verbose_=_false9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_valid ( bool verbose = false)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Checks the combinatorial validity of the triangulation. Checks also the
validity of its geometric embedding (see
Section&nbsp;<A HREF="../Triangulation_3/Chapter_main.html#Triangulation3-sec-intro"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference" WIDTH="10" HEIGHT="10"></A>).<BR>

When <I>verbose</I> is set to true, 
messages describing the first invalidity encountered are printed.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_is_valid6Cell_handle_c+_bool_verbose_=_false9_const;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    t.is_valid ( Cell_handle c,  bool verbose = false)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Checks the combinatorial validity of the cell by calling the
<I>is_valid</I> method of the <I><A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3.html#Cross_link_anchor_1002">TriangulationDataStructure_3</A></I> cell class. Also checks the
geometric validity of <I>c</I>, if <I>c</I> is finite. (See
Section&nbsp;<A HREF="../Triangulation_3/Chapter_main.html#Triangulation3-sec-intro"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference" WIDTH="10" HEIGHT="10"></A>.)<BR>

When <I>verbose</I> is set to <I>true</I>, messages are printed to give
a precise indication of the kind of invalidity encountered.
        </TD></TR>
        </TABLE>
<P>

<table><tr><td valign="bottom">
  <img border="0" src="cc_advanced_end1.gif" alt="end of advanced section">
  </td><td valign="bottom">
  <em class="AdvancedBlockLabel">&nbsp;advanced&nbsp;</em>
  </td><td valign="bottom">
  <img border="0" src="cc_advanced_end2.gif" alt="end of advanced section">
  </td></tr></table></div>
<P>

<H3>I/O</H3>
<P>

C<SMALL>GAL</SMALL> provides an interface to Geomview for a 3D-triangulation. 
See the chapter on Geomview in the Support Library manual.
<I>#include &lt;<A HREF="../../../include/CGAL/IO/Triangulation_geomview_ostream_3.h">CGAL/IO/Triangulation_geomview_ostream_3.h</A>&gt;</I>
<P>

<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    istream&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     istream&amp; is &gt;&gt;  <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A> &amp;t<A NAME="Function_istream__operator99_6istream__is+_Triangulation_3__t9;"></A>

        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Reads the underlying combinatorial triangulation from <I>is</I> by
calling the corresponding input operator of the triangulation data
structure class, and the non-combinatorial information by calling the
corresponding input operators of the vertex and the cell
classes. Assigns the resulting triangulation to <I>t</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    ostream&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     ostream&amp; os &lt;&lt;  <A HREF="Class_Triangulation_3.html#Cross_link_anchor_972">Triangulation_3</A> t<A NAME="Function_ostream__operator66_6ostream__os+_const_Triangulation_3__t9;"></A>

        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Writes the triangulation <I>t</I> into <I>os</I>.
        </TD></TR>
        </TABLE>
<P>

The information in the <I>iostream</I> is: the dimension, the number of
finite vertices, the non-combinatorial information about vertices (point,
etc), the number of cells, the indices of the vertices of each cell,
plus the non-combinatorial information about each cell, 
then the indices of the neighbors of each cell, where the index
corresponds to the preceding list of cells. When dimension <MATH><I>&lt;</I></MATH> 3, the
same information is stored for faces of maximal dimension instead of
cells.
<P>

<H3>See Also</H3>
<P>

<I><A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3--Vertex.html#Cross_link_anchor_1004">TriangulationDataStructure_3::Vertex</A></I><BR>

<I><A HREF="../TriangulationDS_3_ref/Concept_TriangulationDataStructure_3--Cell.html#Cross_link_anchor_1003">TriangulationDataStructure_3::Cell</A></I>
<P>

<div class="NavNext"><hr> <b>Next:</b> <a href="Class_Delaunay_triangulation_3.html"><I>Delaunay_triangulation_3&lt;DelaunayTriangulationTraits_3,TriangulationDataStructure_3&gt;</I></a> 


    
<div class="NavBottom">
<hr><!-- Bottom Navigation --------------------------------------------- -->
  <strong>Navigation:</strong>
<!Up_chapter_link_36!>
  <a href="../contents.html">Table of Contents</A>,
  <a href="../biblio.html">Bibliography</a>,
  <a href="../manual_index.html">Index</a>,
  <a href="../title.html">Title Page</a>
<!-- End of Bottom Navigation ------------------------------------------ -->


<hr><!-- --------------------------------------------------------------- -->
<div class="NavAddress">

The <A HREF=http://www.cgal.org>CGAL Project</A> .

Tue, December 21, 2004 .
<hr></div>
</body>  </html>  
