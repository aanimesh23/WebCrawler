<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="GENERATOR" CONTENT="Globetrotter 1.1.1">
<META HTTP-EQUIV="AUTHOR" CONTENT="David G. Kay">
<META HTTP-EQUIV="UPDATED" CONTENT="Wednesday, March 12, 2003 6:41 AM">
<TITLE>Eighth Homework</TITLE>
<META HTTP-EQUIV="X-GLOBETROTTERDATA" CONTENT="D726EB6E">
<META HTTP-EQUIV=KEYWORDS CONTENT="CS 2, CS2, assignment, performance measurement">
<META HTTP-EQUIV="DESCRIPTION" CONTENT="An assignment involving measuring and analyzing the performance of alternative search algorithms for ICS H22, an honors second-quarter course in computer science in Information and Computer Science, UC Irvine.">
<META HTTP-EQUIV="COPYRIGHT" CONTENT="Copyright &#169; 2000, 2003 by David G. Kay.  All rights reserved.">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME="_top"></A>
<P>
<IMG SRC="Eighth_Homework_files/Sidebar_123.gif" WIDTH=575 HEIGHT=77>
<BR>
<FONT FACE="AGaramond" SIZE=4> &#160; <A NAME="_14_30"></A></FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>This assignment is due on Wednesday, March
12.  There&#39;s not much coding here except for the last part, which you
may do in pairs.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(a) </B>Below is some code that implements
a finite-state machine.<A NAME="_14_234"></A></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>final int Secret1 = 35;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>final int Secret2 = 127;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>final int Secret3 = 33;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>String[] stateList = {&quot;Init&quot;,
&quot;GotFirst&quot;, &quot;GotSecond&quot;, &quot;Success&quot;);</TT></FONT></P>
<BR>
<P>
<FONT FACE="Courier" SIZE=2><TT>int number;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>int count = 1;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>String state;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>void main()</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>{</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160; state = &quot;Init&quot;;   </TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160; while ((!state.equals(&quot;Success&quot;))
&amp;&amp; (count &lt;= 3))</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160; {</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;   number = getNext();</TT></FONT></P>
<BR>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;   if (state.equals(&quot;Init&quot;))</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;    {</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;&#160;     if (number == Secret1)</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;&#160;  &#160; state = &quot;GotFirst&quot;;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;&#160;     else state = &quot;Init&quot;;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;    }</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;   else if (state.equals(&quot;GotFirst&quot;))</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;    {</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;&#160;     if (number == Secret2)</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;&#160;  &#160; state = &quot;GotSecond&quot;;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;&#160;     else state = &quot;Init&quot;;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;    }</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;   else if (state.equals(&quot;GotSecond&quot;))</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;    {</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;&#160;     if (number == Secret3)</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;&#160;  &#160; state = &quot;Success&quot;;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;&#160;     else state = &quot;Init&quot;;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;    }</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;   count++;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160; }</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160; </TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>if (state.equals(&quot;Success&quot;))</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;   System.out.println(&quot;Input
accepted.&quot;);</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>else</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>&#160;   System.out.println(&quot;Input
rejected.&quot;);</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>}</TT></FONT></P>
<BR>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(a.1) </B>Draw the state transition diagram
that represents the FSA this program implements.  The input tokens here
are whole integers, not individual characters.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(a.2)</B> Describe in one brief English
sentence what this FSA does.  Try to think of a simple, real-world, non-computer-related
object that this FSA models.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>Intermezzo:</B>  State transition diagrams
are one way to describe FSAs.  Another way (which is easier to represent
in a computer) is a <B>transition table.</B>  A transition table has a row
for each state and a column for each input; the value at each position in
the table tells you what state to go to when you read a given input in a
given state.  Below is a transition table for the program above:<A NAME="_14_1778"></A></FONT>
<TABLE BORDER=1 CELLSPACING=1 WIDTH=100% CELLPADDING=1>
<COL WIDTH=17%><COL WIDTH=17%><COL WIDTH=17%><COL WIDTH=17%><COL WIDTH=31%>
<TR>
<TD WIDTH=17% VALIGN=TOP>
&#160;</TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="AGaramond" SIZE=4><B>Secret1</B></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="AGaramond" SIZE=4><B>Secret2</B></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="AGaramond" SIZE=4><B>Secret3</B></FONT></TD>
<TD WIDTH=31% VALIGN=TOP>
<FONT FACE="AGaramond" SIZE=4><B>other</B></FONT><BR></TD>
</TR>
<TR>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="AGaramond" SIZE=4><B>Init<A NAME="_14_1837"></A></B></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="Courier"><TT>GotFirst</TT></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="Courier"><TT>Init</TT></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="Courier"><TT>Init</TT></FONT></TD>
<TD WIDTH=31% VALIGN=TOP>
<FONT FACE="Courier"><TT>Init</TT></FONT><BR></TD>
</TR>
<TR>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="AGaramond" SIZE=4><B>GotFirst<A NAME="_14_1878"></A></B></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="Courier"><TT>Init</TT></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="Courier"><TT>GotSecond</TT></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="Courier"><TT>Init</TT></FONT></TD>
<TD WIDTH=31% VALIGN=TOP>
<FONT FACE="Courier"><TT>Init</TT></FONT><BR></TD>
</TR>
<TR>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="AGaramond" SIZE=4><B>GotSecond<A NAME="_14_1921"></A></B></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="Courier"><TT>Init</TT></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="Courier"><TT>Init</TT></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="Courier"><TT>Success</TT></FONT></TD>
<TD WIDTH=31% VALIGN=TOP>
<FONT FACE="Courier"><TT>Init</TT></FONT><BR></TD>
</TR>
<TR>
<TD WIDTH=17% VALIGN=TOP>
<FONT FACE="AGaramond" SIZE=4><B>Success<A NAME="_14_1960"></A></B></FONT></TD>
<TD WIDTH=17% VALIGN=TOP>
&#160;</TD>
<TD WIDTH=17% VALIGN=TOP>
&#160;</TD>
<TD WIDTH=17% VALIGN=TOP>
&#160;</TD>
<TD WIDTH=31% VALIGN=TOP>
<BR></TD>
</TR>
</TABLE>
</P>
<P>
<FONT FACE="AGaramond" SIZE=4>This table says just what the program and
the state transition diagram say:  If you&#39;re in </FONT><FONT FACE="Courier"><TT>Init</TT></FONT><FONT FACE="AGaramond" SIZE=4>
and you read </FONT><FONT FACE="Courier"><TT>Secret1</TT></FONT><FONT FACE="AGaramond" SIZE=4>,
you go into state </FONT><FONT FACE="Courier"><TT>GotFirst</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
if you&#39;re in state </FONT><FONT FACE="Courier"><TT>Init</TT></FONT><FONT FACE="AGaramond" SIZE=4>
and you read anything else, you stay in </FONT><FONT FACE="Courier"><TT>Init</TT></FONT><FONT FACE="AGaramond" SIZE=4>.
 If you&#39;re in state </FONT><FONT FACE="Courier"><TT>GotFirst</TT></FONT><FONT FACE="AGaramond" SIZE=4>
and you read </FONT><FONT FACE="Courier"><TT>Secret2</TT></FONT><FONT FACE="AGaramond" SIZE=4>,
you go into state </FONT><FONT FACE="Courier"><TT>GotSecond</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
if you read anything else in state </FONT><FONT FACE="Courier"><TT>GotFirst</TT></FONT><FONT FACE="AGaramond" SIZE=4>
you go to state </FONT><FONT FACE="Courier"><TT>Init</TT></FONT><FONT FACE="AGaramond" SIZE=4>.
 And finally, if you&#39;re in state </FONT><FONT FACE="Courier"><TT>GotSecond</TT></FONT><FONT FACE="AGaramond" SIZE=4>
and you read </FONT><FONT FACE="Courier"><TT>Secret3</TT></FONT><FONT FACE="AGaramond" SIZE=4>,
you go to state </FONT><FONT FACE="Courier" SIZE=2><TT>Success</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
otherwise, you go to </FONT><FONT FACE="Courier"><TT>Init</TT></FONT><FONT FACE="AGaramond" SIZE=4>.
 In state </FONT><FONT FACE="Courier"><TT>Success</TT></FONT><FONT FACE="AGaramond" SIZE=4>
the machine stops, so you don&#39;t make any transitions out of that state;
it&#39;s the accept state.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>As we noted, transition tables make FSAs easy
to represent in a computer.  In fact, we can write a very simple but very
general FSA simulator according to the following pseudocode:</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>initialize TransitionTable;
<BR>
state </FONT><FONT FACE="Symbol" SIZE=4><IMG SRC="Eighth_Homework_files/Symbol14_AC.gif" WIDTH=17 HEIGHT=15 DESCENT=3 ALIGN="absbottom" ALT="&#168;"></FONT><FONT FACE="AGaramond" SIZE=4>
initial state;
<BR>
while there are more tokens:
<BR>
&#160;&#160;  &#160; get a token;
<BR>
&#160;&#160;  &#160; state </FONT><FONT FACE="Symbol" SIZE=4><IMG SRC="Eighth_Homework_files/Symbol14_AC.gif" WIDTH=17 HEIGHT=15 DESCENT=3 ALIGN="absbottom" ALT="&#168;">
</FONT><FONT FACE="AGaramond" SIZE=4>TransitionTable[state][token];
<BR>
if state = accept state
<BR>
&#160;&#160;  &#160; then accept
<BR>
&#160;&#160;  &#160; else reject.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Because this code is so simple, it&#39;s the
preferred way to implement FSAs in programs.  The only tricky part is finding
a data type that will represent the range of tokens and will at the same
time be acceptable as an array index in your programming language.  Scheme,
for example, handles symbolic names very easily.  But in the above Java
code, you can&#39;t have an array with four columns labeled 35, 127, 33,
and &#39;other&#39;.  The cleanest way to deal with this is to have a routine
that would translate each token (or category of tokens) to its corresponding
column in the transition table--effectively a switch statement or sequence
of if-statements that map the tokens (or token categories) to the range
0..3.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(b)</B>  Think about the task of extracting
words from a stream of text.  In Java, StringTokenizer does this for you,
but sometimes you need to specify &quot;words&quot; idiosyncratically (as
with the DVD information).  You can do this kind of input-parsing task much
more easily using state machines than by writing code directly.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(b.1)</B>  Draw a state transition diagram
that accepts words defined as follows:  a sequence of non-separator characters
whose end is marked by a separator.  Separators are symbols that separate
English words--space, comma, semicolon, colon, and so on.  Note that the
hyphen (-), the apostrophe (&#39;), and the percent sign (%) are not separators:
 treat &quot;mother-in-law,&quot; &quot;don&#39;t,&quot; and &quot;23%&quot;
as single words.   The end of the line is a separator, unless the last word
of the line ends with a hyphen.  That way, if a word like mother-in-law
is hyphenated across two lines, it will still count as one word.  (We will
assume that in our input, only words that are always hyphenated will be
hyphenated at the end of a line; that is, you should not expect normally-unhyphenated
words to be broken across two lines.)  Watch for multiple separators in
a row--for example, a comma followed by a space is two separators, but there
is no word between them.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>You could code up this FSA into a method called
<A NAME="_14_5045"></A></FONT><FONT FACE="Courier"><TT>getNextWord</TT></FONT><FONT FACE="AGaramond" SIZE=4>,
and call it to parse a stream of input.  Coding this isn&#39;t a required
part of this assignment, though.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(b.2)</B>  Write a transition table for
the state machine you drew in part <B>(b.1)</B>.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(c)</B>  Now it&#39;s time to think about
finite-state machines and the DVD information fields defined in the Sixth
Homework.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(c.1)</B>  Draw a state transition diagram
that accepts DVD information.  You should design your machine to accept
a single field--maybe a quoted string, maybe an integer, maybe a date--and
to go back to the initial state when it encounters a comma (that isn&#39;t
quoted, of course).  This makes processing quite simple so long as you&#39;re
willing to forego checking which field is of which type, or that you have
the correct number of fields.  (In coding, you could easily add actions
for some transitions that would maintain a field count.  It might also help
to assume that there&#39;s an input token or character called EOS, for &quot;end
of string,&quot; that your character-reading routine would return and that
your machine could check for.)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(c.2)</B>  For extra credit, recode your
DVD-parsing program to implement the FSA you designed above.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(d)</B>  (This part is optional, but don&#39;t
stop here; subsequent parts of this homework are required.)  Available on
the web is a program called JFLAP, written at Duke University (</FONT><FONT FACE="Courier New"><A HREF="http://www.cs.duke.edu/~rodger/tools/jflaptmp/">http://www.cs.duke.edu/~rodger/tools/jflaptmp/</A></FONT><FONT FACE="AGaramond" SIZE=4>).
 You can download this Java application and use it to build and test your
own simple FSAs (as well as do other formal-language activities).  Other
state machine simulators are available on the web; you can find some of
them by using search strings like &quot;state machine applet&quot; or &quot;FSA
animation.&quot;  If you&#39;d like to work on building or enhancing tools
like these (especially to allow graphical construction of useful FSAs with
regular expressions as the transitions), come talk to me some time.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(e)</B>  The programming language Lisp
(whose name is a contraction of the words &quot;LISt Processing&quot;) was
invented by John McCarthy in 1958.  It was such an advanced language for
its time that existing machines could not run it efficiently, and its early
use was mostly limited to researchers in artificial intelligence.  Today,
however, computers are thousands of times faster than they were in the 1950s,
and Lisp&#39;s power is practical for a very wide range of programming tasks.
 Scheme and Common Lisp are two modern members of the Lisp family of programming
languages.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>One of Scheme&#39;s attractions is that its
syntax is very simple.  Unlike Java, which has a few dozen different statements,
each with its own grammar and punctuation rules, every program or expression
in Scheme is just a list of words surrounded by parentheses.  This provides
a rich variety of expression because a &quot;word&quot; can be (a) any sequence
of characters delimited (separated from other words) by white space, or
(b) a parenthesized list of words nested within the outside list.  The following
are all valid Scheme expressions (each is one line long except the last,
which starts with the word <A NAME="_14_8087"></A></FONT><FONT FACE="Courier"><TT>define</TT></FONT><FONT FACE="AGaramond" SIZE=4>):<A NAME="_14_8103"></A></FONT></P>
<P>
<FONT FACE="Courier"><TT>(Fee fie fo fum)
<BR>
(+ 3.14159 1776 -45 quantity)
<BR>
(equal? (+ 2 2) (+ 3 1))
<BR>
(define square
<BR>
&#160;&#160; (lambda (x)
<BR>
&#160;&#160;  &#160; (* x x)))</TT></FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Novice Scheme programmers sometimes worry
about keeping all the parentheses balanced, but most Scheme systems have
&quot;syntax-based&quot; text editors that automatically keep track of the
parentheses, so that any time you type a right parenthesis it automatically
flashes the left parenthesis that matches it.  That way you can see effortlessly
what matches what.  (This idea has found its way into some program editors
for Java and other languages, where it&#39;s also useful.)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Suppose you decide to write a syntax-based
editor for Scheme, and as your first task you want to write some code that
checks whether the parentheses are balanced in a Scheme expression.  Astutely,
you start by designing a FSA.  To make it truly a <I>finite-</I>state machine,
we have to put an upper limit on the depth to which parentheses can be nested;
the example below shows the FSA for an upper limit of three-deep nesting.
(In the diagram, &quot;other&quot; means an input symbol other than an open
or close parenthesis.)</FONT></P>
<BR>
<P>
<IMG SRC="Eighth_Homework_files/Picture_261.gif" WIDTH=429 HEIGHT=144 ALT="">
</P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(e.1) </B>After scanning the entire Scheme
expression, in what state should your machine be if the parentheses were
correctly balanced?</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(e.2) </B>This FSA works fine in theory,
but for a realistic nesting depth of a few dozen, the diagram would be tediously
repetitious.  So you decide to simplify things and encapsulate the state
information in a simple integer counter.  Then you can have a single state
on the page, and all the action happens in the transition steps, where you
increment the counter for each left parenthesis and decrement it for each
right parenthesis.  (Having a variable may appear to violate the definition
of a finite-state machine, all of whose information is encapsulated in a
finite number of states.  But since integer variables on computers (as opposed
to integers in mathematics) always have a finite upper bound, we&#39;re
technically safe.  If our machine used a stack to keep track of the unbalanced
parentheses (which is what our integer counter is modeling), it would no
longer be an FSA--it would be a PDA (push-down automaton), which can accept
a broader class of languages.)  </FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>The modified (augmented) machine appears below.</FONT></P>
<BR>
<P>
<CENTER>
<IMG SRC="Eighth_Homework_files/Sidebar_250.gif" WIDTH=530 HEIGHT=304 HSPACE=6 VSPACE=6>
</CENTER>
<BR>
<FONT FACE="AGaramond" SIZE=4>In the augmented machine, being in the stop
state is not enough to know that the Scheme program has balanced parentheses;
the value of the counter must be considered as well. What should the counter&#39;s
value be if the machine accepts the Scheme source (that is, if the parentheses
are correctly balanced)? What must have happened for the machine to end
up in the error state?</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(e.3) </B> Things are never quite as simple
as they first seem.  Comments in Scheme programs start with a semicolon
and extend to the end of the line.  Thus, the following is a valid Scheme
expression; everything to the right of the semicolon on each line is a comment.
 Of course the contents of comments are ignored when checking for balanced
parentheses.<A NAME="_14_11113"></A></FONT></P>
<P>
<FONT SIZE=1>&#160;&#160; <A NAME="_14_11118"></A>
<BR>
</FONT><FONT FACE="Courier"><TT>&#160;&#160; (define print-it    ;In this
routine we
<BR>
&#160;&#160;    (lambda (p) &#160;    ; a) accept a parameter,
<BR>
&#160;&#160;       (display p)   ; b) display it, and
<BR>
&#160;&#160;       (newline)))   ; c) hit carriage return</TT></FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Draw a new FSA-like machine, similar to the
one above, to account for comments correctly; you will have to add more
states.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(e.4)</B>  And there&#39;s one more wrinkle.
 Literal character strings in Scheme are enclosed in double-quote marks.
 As in Java, the contents of literal strings are ignored when analyzing
the syntax of the program.  The following three expressions are valid in
Scheme.<A NAME="_14_11694"></A></FONT></P>
<P>
<FONT FACE="Courier"><TT>(display &quot;Oh; really?&quot;)
<BR>
(list  &quot;a)&quot;  &quot;b)&quot;  &quot;c)&quot; )
<BR>
(let ((delims &quot;.,;:)((&quot;))) ; This has an extra '(' in quotes</TT></FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Draw a new FSA-like machine to handle both
strings and comments correctly.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(e.5)</B>  Write a transition table for
the state machine you designed in part <B>(e.4)</B>.  Note that some of
the transitions in some conditions will also increment or decrement the
count of parentheses.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(e.6)</B>  Test your FSA from part <B>(e.4)
 </B>thoroughly on paper--devise a thorough test plan and work each test
through your FSA.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(f)</B>  A grammar is a set of rules that
can generate all the strings in a formal language.  In the right form, a
grammar for a programming language can be used with other software to produce
<I>automatically</I> part of a compiler for that language.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Below is a grammar (in Backus-Naur Form, or
BNF notation) that describes arithmetic expressions:</FONT></P>
<P>
<FONT FACE="Palatino">&lt;expression&gt; ::=  &#160; &lt;real&gt; | &lt;variable&gt;
| </FONT><FONT FACE="Courier"><TT><B>(</B></TT></FONT><FONT FACE="Palatino">
&lt;expression&gt; </FONT><FONT FACE="Courier"><TT><B>)</B></TT></FONT><FONT FACE="Palatino">
|
<BR>
&#160;&#160;  &lt;expression&gt; &lt;operator&gt; &lt;expression&gt; |
<BR>
&#160;&#160; </FONT><FONT FACE="Courier"><TT><B>(</B></TT></FONT><FONT FACE="Palatino">
&lt;variable&gt;  </FONT><FONT FACE="Courier"><TT><B>=</B></TT></FONT><FONT FACE="Palatino">
 &lt;expression&gt; </FONT><FONT FACE="Courier"><TT><B>)
<BR>
</B></TT></FONT><FONT FACE="Palatino">&lt;real&gt; ::=  &#160; &lt;positive-real&gt;
 | </FONT><FONT FACE="Courier"><TT><B>-</B></TT></FONT><FONT FACE="Palatino">
 &lt;positive-real&gt;
<BR>
&lt;positive-real&gt; ::=  &#160; &lt;integer-part&gt;  | &lt;integer-part&gt;
</FONT><FONT FACE="Courier" SIZE=4><TT><B>.</B></TT></FONT><FONT FACE="Palatino">
&lt;integer-part&gt; 
<BR>
&lt;integer-part&gt; ::=  &#160; &lt;digit&gt; | &lt;digit&gt; &lt;integer-part&gt;
<BR>
&lt;variable&gt; ::=  &#160; &lt;letter&gt;
<BR>
&lt;digit&gt; ::= </FONT><FONT FACE="Courier"><TT> &#160; 0</TT></FONT><FONT FACE="Palatino">
| </FONT><FONT FACE="Courier"><TT>1</TT></FONT><FONT FACE="Palatino"> |
</FONT><FONT FACE="Courier"><TT>2</TT></FONT><FONT FACE="Palatino"> | </FONT><FONT FACE="Courier"><TT>3</TT></FONT><FONT FACE="Palatino">
| </FONT><FONT FACE="Courier"><TT>4</TT></FONT><FONT FACE="Palatino"> |
</FONT><FONT FACE="Courier"><TT>5</TT></FONT><FONT FACE="Palatino"> | </FONT><FONT FACE="Courier"><TT>6</TT></FONT><FONT FACE="Palatino">
| </FONT><FONT FACE="Courier"><TT>7</TT></FONT><FONT FACE="Palatino"> |
</FONT><FONT FACE="Courier"><TT>8</TT></FONT><FONT FACE="Palatino"> | </FONT><FONT FACE="Courier"><TT>9
<BR>
</TT></FONT><FONT FACE="Palatino">&lt;letter&gt; ::=<FONT SIZE=2>     &#160;
</FONT><FONT FACE="Courier"><TT>a | b | c | d | e | f | g | h | i | j |
k | l | m |
<BR>
&#160;&#160; n | o | p | q | r | s | t | u | v | w | x | y | z 
<BR>
</TT></FONT><FONT FACE="Palatino">&lt;operator&gt; ::= </FONT><FONT FACE="Courier"><TT>
&#160; +</TT></FONT><FONT FACE="Palatino"> | </FONT><FONT FACE="Courier"><TT>-</TT></FONT><FONT FACE="Palatino">
| </FONT><FONT FACE="Courier"><TT>*</TT></FONT><FONT FACE="Palatino"> |
</FONT><FONT FACE="Courier"><TT>/ | %</TT></FONT></P>
<BR>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(f.1)</B>  Some of the following expressions
can be generated by this grammar; others can not.  Indicate which are the
valid expressions.  (The easiest way to do this might be to photocopy the
page, or print it from the on-line version, and circle the valid expressions.)</FONT></P>
<P>
<CENTER>
<IMG SRC="Eighth_Homework_files/Sidebar_225.gif" WIDTH=546 HEIGHT=162 HSPACE=6 VSPACE=6 ALT="3">
</CENTER>
</P>
<BR><BR><BR><BR>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(f.2)</B>  Using the grammar, generate
four more expressions that aren&#39;t on the above list.  Each expression
should involve applying at least ten rules.  For each expression, show its
derivation tree (with &lt;expression&gt; at the root and terminal symbols--i.e.,
without angle brackets--at the leaves).</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(f.3)</B>  Give three arithmetic expressions
that are syntactically valid in Java but are not generated by this grammar.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(f.4)</B>  Modify the grammar to allow
multi-letter variable names.  This requires changing only one of the existing
rules.<A NAME="_14_14005"></A></FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(g)</B>  Write regular expressions to match
each of the following patterns.  Note that these are natural language descriptions,
so they will certainly be ambiguous; disambiguate them as you see fit and
note what decisions you made.  In some cases you may not be able to match
the described set perfectly; don&#39;t obsess over it.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>*  Comma-separated dollars-and-cents amounts
(e.g., $1,234.56 and $17)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>*  Lines that are empty or all blanks.  (The
caret (&quot;</FONT><FONT FACE="Courier New" SIZE=4>^</FONT><FONT FACE="AGaramond" SIZE=4>&quot;)
matches the start of a line and the dollar sign matches the end of the line.)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>*  Email addresses</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>*  URLs in HTML anchor tags (e.g., </FONT><FONT FACE="Courier New" SIZE=4>&lt;A
href=&quot;http://www.ics.uci.edu/~kay&quot;&gt;</FONT><FONT FACE="AGaramond" SIZE=4>)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>*  Lines containing exactly one integer (perhaps
surrounded by non-numeric characters)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(h) </B>Write a program that generates
random sentences according to a user-supplied grammar, as specified below.
 The final product doesn&#39;t require a lot of code, but it does require
careful, thoughtful design in advance.  You may do this assignment in pairs.
 Each member of a pair should turn in the (identical) program via Checkmate;
each source code file should have a comment at the top that says something
like &quot;</FONT><FONT FACE="Courier New">// Joint work of Carl Coder and
Petra Programmer.</FONT><FONT FACE="AGaramond" SIZE=4>&quot;</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(h.1)</B>  Get an idea of what this assignment
can do by trying out the applet at </FONT><FONT FACE="Courier New"><A HREF="http://www-cs-faculty.stanford.edu/~zelenski/rsg/">http://www-cs-faculty.stanford.edu/~zelenski/rsg/</A></FONT><FONT FACE="AGaramond" SIZE=4>
.  The &quot;Extension Request&quot; grammar (the default) is pretty funny;
also try out &quot;CS assignment,&quot; &quot;Programming bug,&quot; and
&quot;Math expression,&quot; along with any others that strike your fancy.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(h.2)</B>  Follow the &quot;Directory of
the collected grammar files&quot; link at the bottom of the page.  Pick
grammars that you chose in part <B>(h.1)</B> (&quot;Math expression&quot;
is the easiest to follow) and look at them to get an idea of your program&#39;s
input.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>A grammar file for input to your program contains
one or more rules of the following form:</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>-- Each rule starts with a left brace &quot;{&quot;
on its own line and ends with a right brace &quot;}&quot; on its own line.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>-- After the opening brace, the first line
of the rule is its left-hand side; this non-terminal is a string delimited
by angle brackets.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>-- Subsequent lines of the rule are alternative
productions, different ways of rewriting the left-hand side.  Each production
consists of non-terminals (enclosed in angle brackets) and terminals (other
characters) in any combination, ending with a semicolon.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>-- There may be lines of text outside of the
braces that delimit the rules; those lines are ignored by the program (and
thus can serve as comments in the grammar).</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>You may assume that the grammar files take
this form; you do not have to check for errors. </FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(h.3)</B>  Write code to read grammar files
and store the grammars.  Use a symbol table (either a hash table or a BST)
keyed on the non-terminals; the value of each entry in the table contains
the non-terminal&#39;s alternative productions.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(h.4)</B>  Now, write code to generate
sentences from the grammar.  Each grammar contains one non-terminal symbol
named </FONT><FONT FACE="Courier New">&lt;start&gt;</FONT><FONT FACE="AGaramond" SIZE=4>,
which (obviously enough) is the start symbol for each derivation.  As your
program expands each non-terminal, it chooses at random one of the non-terminal&#39;s
alternative productions, and so on recursively until every non-terminal
is expanded.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>You may assume that every non-terminal in
the grammar will appear on the left side of exactly one rule; you do not
have to check for undefined or multiply-defined non-terminals (though for
a bit of extra credit you may check for and handle those issues and a missing
start symbol).</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Your output should include a hierarchical
description of the derivation process as well as the final sentence, as
shown in the following example.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Here is a simple grammar:</FONT></P>
<BR>
<P>
<CENTER>
<IMG SRC="Eighth_Homework_files/Sidebar_207.gif" WIDTH=537 HEIGHT=145 HSPACE=6 VSPACE=6 ALT="{">
</CENTER>
</P>
<BR>
<P>
<FONT FACE="AGaramond" SIZE=4>Here is the output, showing the final generated
sentence at the bottom.  The first level of indentation shows the first
production taken (</FONT><FONT FACE="Courier New">This&#160;&lt;Y&gt;&#160;!</FONT><FONT FACE="AGaramond" SIZE=4>),
the second level shows the expansion of </FONT><FONT FACE="Courier New">&lt;Y&gt;</FONT><FONT FACE="AGaramond" SIZE=4>
(</FONT><FONT FACE="Courier New">&lt;Z&gt;&#160;cool</FONT><FONT FACE="AGaramond" SIZE=4>),
and so on.<A NAME="_14_17927"></A></FONT></P>
<BR>
<P>
<FONT FACE="Courier" SIZE=4><TT>&lt;start&gt;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=4><TT>&#160;&#160;&#160;This</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=4><TT>&#160;&#160;&#160;&lt;Y&gt;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=4><TT>&#160;&#160;&#160;&#160;&#160;&#160;&lt;Z&gt;</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=4><TT>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;is
really</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=4><TT>&#160;&#160;&#160;&#160;&#160;&#160;cool</TT></FONT></P>
<P>
<FONT FACE="Courier" SIZE=4><TT>&#160;&#160;&#160;!</TT></FONT></P>
<BR>
<P>
<FONT FACE="Courier" SIZE=4><TT>This is really cool !</TT></FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(h.5)</B>  Design and build an interface.
 The simplest would be a console interface that prompts the user for the
name of a grammar file and then generates a sentence from that grammar.
 Enhancements could include letting the user request new sentences repeatedly
or specify a new grammar file.  Building an applet or GUI application is
another alternative.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(h.6)</B>  Make up a grammar for (a tiny
subset of) Java and see what kinds of programs it generates.  (You could
copy your random program output into a Java environment like DrJava, not
to run it but to get it automatically formatted to make it readable.)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(h.7)</B>  Make up at least one other grammar
of your choice and generate some sentences with it.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(h.8)</B>  On the last day of class, bring
a printed copy of your best, cleverest, or funniest grammar and some of
the sentences it generates; we can share them (anonymously if you like).</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(i)</B>  The GUI you may have built as
extra credit suggested by the Sixth Homework is due at the same time this
assignment is due.<A NAME="_14_19049"></A><B> </B></FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>What to turn in:</B>  For parts <B>(a)</B>
through <B>(g)</B>, which involve so many diagrams and tables, you will
probably find it easiest to produce and submit your work on paper (clearly
marked with your name, of course) and turn it in during section.  Checkmate
will accept a Word document for those parts, but please use Checkmate for
those parts only if everything, including all the diagrams, is included
in the electronic copy.  Of course you may use Word to produce a printed
copy onto which you draw some of your answers by hand, but we need everything
in one place, not split between Checkmate and paper.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>For part <B>(h)</B>, turn in via Checkmate
your Java code, your grammar for (partial) Java, and the other grammars
you designed.</FONT></P>
<BR>
<P>
<FONT FACE="Helvetica" SIZE=1>FSA exercises written by David G. Kay, Winter
1991 (based on materials from 1990 and earlier).
<BR>
Revised by Joe Hummel, Norman Jacobson, Theresa Millette, Brian Pitterle,
Alex Thornton, Rasheed Baqai, Li-Wei (Gary) Chen, and David G. Kay, 1992-1999
<BR>
Revised to include BNF grammars by David G. Kay, Spring 1999. 
<BR>
Revised and consolidated by David G. Kay, Winter 2000; revised to add DVD
information, Winter 2003.</FONT></P>
<P>
<FONT FACE="Helvetica" SIZE=1>Random sentence generator original concept
by Mike Cleron of Stanford University; modified by Allison Hansen, Julie
Zelenski, and others.
<BR>
Revised and adapted by David G. Kay, Winter 2000 and Winter 2003.</FONT></P>
<BR>
<BR CLEAR=ALL>
</BODY>
</HTML>
